<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CAPSENSE™ Middleware Library 8.0.0: Low-level Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="IFXCYP_one-line.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CAPSENSE™ Middleware Library 8.0.0</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group__capsense__low__level.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Low-level Functions</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<p>The Low-level functions represent the lower layer of abstraction in support of <a class="el" href="group__group__capsense__high__level.html">High-level Functions</a>. </p>
<p>These functions also enable implementation of special case designs requiring performance optimization and non-typical functionalities.</p>
<p>All functions are general to all sensing methods. Some of the functions detect the sensing method used by the widget and execute tasks as appropriate. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gafbfe743a98bd2c24a623a2c734c03f0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#gafbfe743a98bd2c24a623a2c734c03f0e">Cy_CapSense_ProcessWidgetExt</a> (uint32_t widgetId, uint32_t mode, <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:gafbfe743a98bd2c24a623a2c734c03f0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs customized data processing on the selected widget.  <a href="#gafbfe743a98bd2c24a623a2c734c03f0e">More...</a><br /></td></tr>
<tr class="separator:gafbfe743a98bd2c24a623a2c734c03f0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05d3f6e7d7fbef845ab4eb575e653dec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#ga05d3f6e7d7fbef845ab4eb575e653dec">Cy_CapSense_ProcessSensorExt</a> (uint32_t widgetId, uint32_t sensorId, uint32_t mode, const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga05d3f6e7d7fbef845ab4eb575e653dec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs customized data processing on the selected sensor.  <a href="#ga05d3f6e7d7fbef845ab4eb575e653dec">More...</a><br /></td></tr>
<tr class="separator:ga05d3f6e7d7fbef845ab4eb575e653dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9282e8184026228ec7b8e1cf22829e55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#ga9282e8184026228ec7b8e1cf22829e55">Cy_CapSense_ReadWidgetCdacParam</a> (uint8_t *ptrBuffer, uint32_t widgetId, <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga9282e8184026228ec7b8e1cf22829e55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the CDAC parameters of the widget and writes them into the buffer.  <a href="#ga9282e8184026228ec7b8e1cf22829e55">More...</a><br /></td></tr>
<tr class="separator:ga9282e8184026228ec7b8e1cf22829e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95c9816b8cb62a2c555ee3398558cf38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#ga95c9816b8cb62a2c555ee3398558cf38">Cy_CapSense_WriteWidgetCdacParam</a> (uint8_t *ptrBuffer, uint32_t widgetId, <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga95c9816b8cb62a2c555ee3398558cf38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse buffer as CDAC parameters and writes them into a CAPSENSE&trade; Data Structure.  <a href="#ga95c9816b8cb62a2c555ee3398558cf38">More...</a><br /></td></tr>
<tr class="separator:ga95c9816b8cb62a2c555ee3398558cf38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b6d787bf68eea9a889d8c7eec40af78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#ga2b6d787bf68eea9a889d8c7eec40af78">Cy_CapSense_SetWidgetCalibrationState</a> (uint32_t widgetId, uint32_t state, <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga2b6d787bf68eea9a889d8c7eec40af78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets widget calibration state.  <a href="#ga2b6d787bf68eea9a889d8c7eec40af78">More...</a><br /></td></tr>
<tr class="separator:ga2b6d787bf68eea9a889d8c7eec40af78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b8f58a0d6db406bca0c7caf94379854"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#ga3b8f58a0d6db406bca0c7caf94379854">Cy_CapSense_IsLlwCalibrationValid</a> (uint32_t widgetId, <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga3b8f58a0d6db406bca0c7caf94379854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the status of the liquid level calibration the widget, by validating the one-time calibration and the liquid level calibration states.  <a href="#ga3b8f58a0d6db406bca0c7caf94379854">More...</a><br /></td></tr>
<tr class="separator:ga3b8f58a0d6db406bca0c7caf94379854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa35b107fb94a8c8ff6d53463c62d0481"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#gaa35b107fb94a8c8ff6d53463c62d0481">Cy_CapSense_InitializeAllBaselines</a> (<a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:gaa35b107fb94a8c8ff6d53463c62d0481"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the baselines of all the sensors of all active widgets.  <a href="#gaa35b107fb94a8c8ff6d53463c62d0481">More...</a><br /></td></tr>
<tr class="separator:gaa35b107fb94a8c8ff6d53463c62d0481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6dd0e7c6db3f269948623d2e0fa0c2d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#ga6dd0e7c6db3f269948623d2e0fa0c2d7">Cy_CapSense_InitializeWidgetBaseline</a> (uint32_t widgetId, <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga6dd0e7c6db3f269948623d2e0fa0c2d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the baselines of all the sensors in a specific widget.  <a href="#ga6dd0e7c6db3f269948623d2e0fa0c2d7">More...</a><br /></td></tr>
<tr class="separator:ga6dd0e7c6db3f269948623d2e0fa0c2d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga723aa8ba790fcc07ca42611aba99fb88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#ga723aa8ba790fcc07ca42611aba99fb88">Cy_CapSense_InitializeSensorBaseline</a> (uint32_t widgetId, uint32_t sensorId, <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga723aa8ba790fcc07ca42611aba99fb88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the baseline of a sensor in a widget specified by the input parameters.  <a href="#ga723aa8ba790fcc07ca42611aba99fb88">More...</a><br /></td></tr>
<tr class="separator:ga723aa8ba790fcc07ca42611aba99fb88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fcb002d0216bb96ab818276954606e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#ga1fcb002d0216bb96ab818276954606e7">Cy_CapSense_InitializeAllFilters</a> (const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga1fcb002d0216bb96ab818276954606e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes (or re-initializes) all the firmware filter history, except the baseline.  <a href="#ga1fcb002d0216bb96ab818276954606e7">More...</a><br /></td></tr>
<tr class="separator:ga1fcb002d0216bb96ab818276954606e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga101174469c4b6a2df8d44bddb0e33fcf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#ga101174469c4b6a2df8d44bddb0e33fcf">Cy_CapSense_InitializeWidgetFilter</a> (uint32_t widgetId, const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga101174469c4b6a2df8d44bddb0e33fcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes (or re-initializes) the raw count filter history of all the sensors in a widget specified by the input parameter.  <a href="#ga101174469c4b6a2df8d44bddb0e33fcf">More...</a><br /></td></tr>
<tr class="separator:ga101174469c4b6a2df8d44bddb0e33fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76d2e232d2e5247954a15a45de62d235"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#ga76d2e232d2e5247954a15a45de62d235">Cy_CapSense_UpdateAllBaselines</a> (const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga76d2e232d2e5247954a15a45de62d235"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the baseline for all the sensors in all the active widgets (skipping low power widgets).  <a href="#ga76d2e232d2e5247954a15a45de62d235">More...</a><br /></td></tr>
<tr class="separator:ga76d2e232d2e5247954a15a45de62d235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53420b198a6de128b82b3edb31f250c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#ga53420b198a6de128b82b3edb31f250c6">Cy_CapSense_UpdateWidgetBaseline</a> (uint32_t widgetId, const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga53420b198a6de128b82b3edb31f250c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the baselines for all the sensors in a widget specified by the input parameter.  <a href="#ga53420b198a6de128b82b3edb31f250c6">More...</a><br /></td></tr>
<tr class="separator:ga53420b198a6de128b82b3edb31f250c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d2ceb23fa0e3731878ad777f39474d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#ga4d2ceb23fa0e3731878ad777f39474d2">Cy_CapSense_UpdateSensorBaseline</a> (uint32_t widgetId, uint32_t sensorId, const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga4d2ceb23fa0e3731878ad777f39474d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the baseline for a sensor in a widget specified by the input parameters.  <a href="#ga4d2ceb23fa0e3731878ad777f39474d2">More...</a><br /></td></tr>
<tr class="separator:ga4d2ceb23fa0e3731878ad777f39474d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a42bc8b8c045d4c4fa3ea9b4411c247"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#ga1a42bc8b8c045d4c4fa3ea9b4411c247">Cy_CapSense_InitializeWidgetGestures</a> (uint32_t widgetId, const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga1a42bc8b8c045d4c4fa3ea9b4411c247"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs initialization of all gestures for the specified widget.  <a href="#ga1a42bc8b8c045d4c4fa3ea9b4411c247">More...</a><br /></td></tr>
<tr class="separator:ga1a42bc8b8c045d4c4fa3ea9b4411c247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91d3ccdc21ed235f4e3b61a0a583c7a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#ga91d3ccdc21ed235f4e3b61a0a583c7a1">Cy_CapSense_InitializeAllStatuses</a> (const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga91d3ccdc21ed235f4e3b61a0a583c7a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs initialization of all statuses and related modules including debounce counters and touch positions of all the widgets.  <a href="#ga91d3ccdc21ed235f4e3b61a0a583c7a1">More...</a><br /></td></tr>
<tr class="separator:ga91d3ccdc21ed235f4e3b61a0a583c7a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cd8087cced318d7a2ddd0aabe5d0b65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#ga0cd8087cced318d7a2ddd0aabe5d0b65">Cy_CapSense_InitializeWidgetStatus</a> (uint32_t widgetId, const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga0cd8087cced318d7a2ddd0aabe5d0b65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs initialization of all statuses, debounce counters, and touch positions of the specified widget.  <a href="#ga0cd8087cced318d7a2ddd0aabe5d0b65">More...</a><br /></td></tr>
<tr class="separator:ga0cd8087cced318d7a2ddd0aabe5d0b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1460eefc048d987a811dbb7deba56e0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#ga1460eefc048d987a811dbb7deba56e0f">Cy_CapSense_ProcessWidgetMpDeconvolution</a> (uint32_t widgetId, <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga1460eefc048d987a811dbb7deba56e0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs raw count deconvolution for the specified widget:  <a href="#ga1460eefc048d987a811dbb7deba56e0f">More...</a><br /></td></tr>
<tr class="separator:ga1460eefc048d987a811dbb7deba56e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf58d5ee3d30799c52819dccecad6730b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#gaf58d5ee3d30799c52819dccecad6730b">Cy_CapSense_PreProcessSensor</a> (uint32_t widgetId, uint32_t sensorId, const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:gaf58d5ee3d30799c52819dccecad6730b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the pre-processing of scan raw data for specified sensor.  <a href="#gaf58d5ee3d30799c52819dccecad6730b">More...</a><br /></td></tr>
<tr class="separator:gaf58d5ee3d30799c52819dccecad6730b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0772250c35cb3f630a8522b0b156692"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#gad0772250c35cb3f630a8522b0b156692">Cy_CapSense_PreProcessWidget</a> (uint32_t widgetId, const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:gad0772250c35cb3f630a8522b0b156692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the pre-processing of scan raw data for specified widgets.  <a href="#gad0772250c35cb3f630a8522b0b156692">More...</a><br /></td></tr>
<tr class="separator:gad0772250c35cb3f630a8522b0b156692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0226119d718185acba8bfb8098682ec7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#ga0226119d718185acba8bfb8098682ec7">Cy_CapSense_RunMfsMedian</a> (uint32_t widgetId, const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga0226119d718185acba8bfb8098682ec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the median filter to the specified multi-frequency widget and updates the specified widget diff counts.  <a href="#ga0226119d718185acba8bfb8098682ec7">More...</a><br /></td></tr>
<tr class="separator:ga0226119d718185acba8bfb8098682ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8266fcf05ad962580844a2c9c01f2fb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__enums.html#gafbe67572b1e6a637676b0a6e1040857c">cy_en_capsense_bist_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#ga8266fcf05ad962580844a2c9c01f2fb8">Cy_CapSense_CheckCRCWidget</a> (uint32_t widgetId, <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga8266fcf05ad962580844a2c9c01f2fb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the stored CRC of the <a class="el" href="structcy__stc__capsense__widget__context__t.html">cy_stc_capsense_widget_context_t</a> data structure of the specified widget.  <a href="#ga8266fcf05ad962580844a2c9c01f2fb8">More...</a><br /></td></tr>
<tr class="separator:ga8266fcf05ad962580844a2c9c01f2fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga617c2c407a13538ca6662314402e3f61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__enums.html#gafbe67572b1e6a637676b0a6e1040857c">cy_en_capsense_bist_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#ga617c2c407a13538ca6662314402e3f61">Cy_CapSense_CheckIntegritySensorRawcount</a> (uint32_t widgetId, uint32_t sensorId, uint16_t rawcountHighLimit, uint16_t rawcountLowLimit, <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga617c2c407a13538ca6662314402e3f61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the raw count of the specified widget/sensor is within the specified range.  <a href="#ga617c2c407a13538ca6662314402e3f61">More...</a><br /></td></tr>
<tr class="separator:ga617c2c407a13538ca6662314402e3f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5574b4c085f9cf891457cbf835e6ca1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__enums.html#gafbe67572b1e6a637676b0a6e1040857c">cy_en_capsense_bist_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#gab5574b4c085f9cf891457cbf835e6ca1">Cy_CapSense_CheckIntegritySensorBaseline</a> (uint32_t widgetId, uint32_t sensorId, uint16_t baselineHighLimit, uint16_t baselineLowLimit, <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:gab5574b4c085f9cf891457cbf835e6ca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the baseline of the specified sensor is not corrupted by comparing it with its inverse copy and checks if the baseline is within the specified range.  <a href="#gab5574b4c085f9cf891457cbf835e6ca1">More...</a><br /></td></tr>
<tr class="separator:gab5574b4c085f9cf891457cbf835e6ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcc9fa570b4c5aa91c66570f5c6f57d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__enums.html#gafbe67572b1e6a637676b0a6e1040857c">cy_en_capsense_bist_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#gadcc9fa570b4c5aa91c66570f5c6f57d4">Cy_CapSense_CheckIntegritySensorPins</a> (uint32_t widgetId, uint32_t sensorId, <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:gadcc9fa570b4c5aa91c66570f5c6f57d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the specified widget/sensor for shorts to GND, VDD or other sensors.  <a href="#gadcc9fa570b4c5aa91c66570f5c6f57d4">More...</a><br /></td></tr>
<tr class="separator:gadcc9fa570b4c5aa91c66570f5c6f57d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80ad1c421ea794bd493bb37e76c48a2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__enums.html#gafbe67572b1e6a637676b0a6e1040857c">cy_en_capsense_bist_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#ga80ad1c421ea794bd493bb37e76c48a2b">Cy_CapSense_MeasureCapacitanceCap</a> (<a class="el" href="group__group__capsense__enums.html#ga07f6f8cbe8fa1cebb08e2bd44e9de29b">cy_en_capsense_bist_external_cap_id_t</a> integrationCapId, uint32_t *ptrValue, uint32_t maxCapacitance, <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga80ad1c421ea794bd493bb37e76c48a2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measures the capacitance in picofarads of the specified CAPSENSE&trade; integration (external) capacitor.  <a href="#ga80ad1c421ea794bd493bb37e76c48a2b">More...</a><br /></td></tr>
<tr class="separator:ga80ad1c421ea794bd493bb37e76c48a2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0214428f5737ef46a2f755620c4e7316"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__enums.html#gafbe67572b1e6a637676b0a6e1040857c">cy_en_capsense_bist_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#ga0214428f5737ef46a2f755620c4e7316">Cy_CapSense_MeasureVdda</a> (uint32_t *ptrValue, <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga0214428f5737ef46a2f755620c4e7316"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measures a VDDA voltage, returns the measured voltage in millivolts through the ptrValue argument and stores it to the .vddaVoltage field of the <a class="el" href="structcy__stc__capsense__bist__context__t.html">cy_stc_capsense_bist_context_t</a> structure.  <a href="#ga0214428f5737ef46a2f755620c4e7316">More...</a><br /></td></tr>
<tr class="separator:ga0214428f5737ef46a2f755620c4e7316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23f23f4e684b25788f999851f20aa58c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__enums.html#gafbe67572b1e6a637676b0a6e1040857c">cy_en_capsense_bist_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#ga23f23f4e684b25788f999851f20aa58c">Cy_CapSense_MeasureCapacitanceSensorElectrode</a> (uint32_t widgetId, uint32_t eltdId, <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga23f23f4e684b25788f999851f20aa58c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measures the specified CSD sensor / CSX electrode capacitance in femtofarads.  <a href="#ga23f23f4e684b25788f999851f20aa58c">More...</a><br /></td></tr>
<tr class="separator:ga23f23f4e684b25788f999851f20aa58c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb467c284dc3fea4c7347a25c5ff57df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__enums.html#gafbe67572b1e6a637676b0a6e1040857c">cy_en_capsense_bist_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#gadb467c284dc3fea4c7347a25c5ff57df">Cy_CapSense_MeasureCapacitanceSlotSensors</a> (uint32_t slotId, uint32_t skipChMask, <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:gadb467c284dc3fea4c7347a25c5ff57df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measures the specified slot sensor capacitance in femtofarads.  <a href="#gadb467c284dc3fea4c7347a25c5ff57df">More...</a><br /></td></tr>
<tr class="separator:gadb467c284dc3fea4c7347a25c5ff57df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff014dbf80fc7824a7e6e3e377d2942f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__enums.html#gafbe67572b1e6a637676b0a6e1040857c">cy_en_capsense_bist_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#gaff014dbf80fc7824a7e6e3e377d2942f">Cy_CapSense_MeasureCapacitanceShieldElectrode</a> (uint32_t skipChMask, <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:gaff014dbf80fc7824a7e6e3e377d2942f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measures shield electrode capacitances in femtofarads.  <a href="#gaff014dbf80fc7824a7e6e3e377d2942f">More...</a><br /></td></tr>
<tr class="separator:gaff014dbf80fc7824a7e6e3e377d2942f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga667ff2892eb5a53d09f2207d5d178686"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__enums.html#gafbe67572b1e6a637676b0a6e1040857c">cy_en_capsense_bist_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#ga667ff2892eb5a53d09f2207d5d178686">Cy_CapSense_MeasureCapacitanceLpSlotSensors</a> (uint32_t slotId, <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga667ff2892eb5a53d09f2207d5d178686"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measures the specified low power slot sensor capacitance in femtofarads.  <a href="#ga667ff2892eb5a53d09f2207d5d178686">More...</a><br /></td></tr>
<tr class="separator:ga667ff2892eb5a53d09f2207d5d178686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bf9894c313d4ffce1be841141d6b8e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__enums.html#gafbe67572b1e6a637676b0a6e1040857c">cy_en_capsense_bist_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#ga3bf9894c313d4ffce1be841141d6b8e5">Cy_CapSense_MeasureCapacitanceSensor</a> (uint32_t widgetId, uint32_t sensorId, uint32_t *ptrValue, <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga3bf9894c313d4ffce1be841141d6b8e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measures the specified CSD sensor / CSX electrode capacitance in femtofarads.  <a href="#ga3bf9894c313d4ffce1be841141d6b8e5">More...</a><br /></td></tr>
<tr class="separator:ga3bf9894c313d4ffce1be841141d6b8e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc9c800180cd40a8ca3e53321d6a249b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__enums.html#gafbe67572b1e6a637676b0a6e1040857c">cy_en_capsense_bist_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#gacc9c800180cd40a8ca3e53321d6a249b">Cy_CapSense_MeasureCapacitanceShield</a> (uint32_t *ptrValue, <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:gacc9c800180cd40a8ca3e53321d6a249b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measures shield electrode capacitance in femtofarads.  <a href="#gacc9c800180cd40a8ca3e53321d6a249b">More...</a><br /></td></tr>
<tr class="separator:gacc9c800180cd40a8ca3e53321d6a249b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a30f2e4cdef59eab57f589b0091d937"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#ga3a30f2e4cdef59eab57f589b0091d937">Cy_CapSense_CalibrateAllWidgets</a> (<a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga3a30f2e4cdef59eab57f589b0091d937"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes CapDAC/IDAC auto-calibration for all the sensors in all widgets of some sensing groups (CSD, CSX, or ISX) if calibration is enabled for such group of widgets.  <a href="#ga3a30f2e4cdef59eab57f589b0091d937">More...</a><br /></td></tr>
<tr class="separator:ga3a30f2e4cdef59eab57f589b0091d937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1130ee418f843fce4e68832efa37e28f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#ga1130ee418f843fce4e68832efa37e28f">Cy_CapSense_CalibrateAllSlots</a> (<a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga1130ee418f843fce4e68832efa37e28f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes CapDAC/IDAC auto-calibration for all the sensors in all widgets of some sensing groups (CSD, CSX, or ISX) if calibration is enabled for such group of widgets.  <a href="#ga1130ee418f843fce4e68832efa37e28f">More...</a><br /></td></tr>
<tr class="separator:ga1130ee418f843fce4e68832efa37e28f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f9c2fe584e7038a923d28bf445205ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#ga2f9c2fe584e7038a923d28bf445205ee">Cy_CapSense_SetCalibrationTarget</a> (uint32_t calibrTarget, uint32_t snsMethod, <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga2f9c2fe584e7038a923d28bf445205ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the CapDAC auto-calibration raw count target for CSD, CSX or ISX widgets.  <a href="#ga2f9c2fe584e7038a923d28bf445205ee">More...</a><br /></td></tr>
<tr class="separator:ga2f9c2fe584e7038a923d28bf445205ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga889e60b9ca2470b37b37c772558f44ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#ga889e60b9ca2470b37b37c772558f44ad">Cy_CapSense_CalibrateWidget</a> (uint32_t widgetId, <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga889e60b9ca2470b37b37c772558f44ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the CapDAC/IDAC calibration for all the sensors in the specified widget to the default target value.  <a href="#ga889e60b9ca2470b37b37c772558f44ad">More...</a><br /></td></tr>
<tr class="separator:ga889e60b9ca2470b37b37c772558f44ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3f80b48c2596c149ca0b392a9a3da62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#gae3f80b48c2596c149ca0b392a9a3da62">Cy_CapSense_ScanSensor</a> (uint32_t widgetId, uint32_t sensorId, <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:gae3f80b48c2596c149ca0b392a9a3da62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiates the scanning of the selected sensor in the widget.  <a href="#gae3f80b48c2596c149ca0b392a9a3da62">More...</a><br /></td></tr>
<tr class="separator:gae3f80b48c2596c149ca0b392a9a3da62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf51fd91df09631045f83396237395777"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#gaf51fd91df09631045f83396237395777">Cy_CapSense_SetPinState</a> (uint32_t widgetId, uint32_t sensorElement, uint32_t state, const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:gaf51fd91df09631045f83396237395777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the state (drive mode and HSIOM state) of the GPIO used by a sensor.  <a href="#gaf51fd91df09631045f83396237395777">More...</a><br /></td></tr>
<tr class="separator:gaf51fd91df09631045f83396237395777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d8f778457e13ccfa3f34239aef25f47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#ga5d8f778457e13ccfa3f34239aef25f47">Cy_CapSense_SlotPinState</a> (uint32_t slotId, const <a class="el" href="structcy__stc__capsense__electrode__config__t.html">cy_stc_capsense_electrode_config_t</a> *ptrEltdCfg, uint32_t pinState, <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga5d8f778457e13ccfa3f34239aef25f47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the specified electrode to the desired state in the specified slot (Active slot for fifth-generation low power CAPSENSE&trade;) by updating the CAPSENSE&trade; configuration.  <a href="#ga5d8f778457e13ccfa3f34239aef25f47">More...</a><br /></td></tr>
<tr class="separator:ga5d8f778457e13ccfa3f34239aef25f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga760c8b9c8e17b5c9689bf9305a34e393"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#ga760c8b9c8e17b5c9689bf9305a34e393">Cy_CapSense_SetInactiveElectrodeState</a> (uint32_t inactiveState, uint32_t sensingGroup, <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga760c8b9c8e17b5c9689bf9305a34e393"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a desired state for all inactive CAPSENSE&trade;-related electrodes for CSD, CSX, ISX scans, or BIST measurement scans.  <a href="#ga760c8b9c8e17b5c9689bf9305a34e393">More...</a><br /></td></tr>
<tr class="separator:ga760c8b9c8e17b5c9689bf9305a34e393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga264c6bafda78c56a0d620a7c88363269"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#ga264c6bafda78c56a0d620a7c88363269">Cy_CapSense_ScanAbort</a> (<a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga264c6bafda78c56a0d620a7c88363269"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the sequencer to the idle state by resetting the hardware, it can be used to abort current scan.  <a href="#ga264c6bafda78c56a0d620a7c88363269">More...</a><br /></td></tr>
<tr class="separator:ga264c6bafda78c56a0d620a7c88363269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga182defda982b92d1f098b5b74184ef55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#ga182defda982b92d1f098b5b74184ef55">Cy_CapSense_LpSlotPinState</a> (uint32_t lpSlotId, const <a class="el" href="structcy__stc__capsense__electrode__config__t.html">cy_stc_capsense_electrode_config_t</a> *ptrEltdCfg, uint32_t pinState, <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga182defda982b92d1f098b5b74184ef55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the specified electrode to the desired state in the specified Low Power slot by updating the CAPSENSE&trade; configuration.  <a href="#ga182defda982b92d1f098b5b74184ef55">More...</a><br /></td></tr>
<tr class="separator:ga182defda982b92d1f098b5b74184ef55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5977d1af9e19f447f861bb9919afb30a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#ga5977d1af9e19f447f861bb9919afb30a">Cy_CapSense_CalibrateAllLpWidgets</a> (<a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga5977d1af9e19f447f861bb9919afb30a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes CapDAC auto-calibration for all relevant low power widgets if enabled.  <a href="#ga5977d1af9e19f447f861bb9919afb30a">More...</a><br /></td></tr>
<tr class="separator:ga5977d1af9e19f447f861bb9919afb30a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cebf3e9d41b7e874369d1a083ab88c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#ga5cebf3e9d41b7e874369d1a083ab88c6">Cy_CapSense_CalibrateAllLpSlots</a> (<a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga5cebf3e9d41b7e874369d1a083ab88c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calibrates CapDACs for all Low power widgets.  <a href="#ga5cebf3e9d41b7e874369d1a083ab88c6">More...</a><br /></td></tr>
<tr class="separator:ga5cebf3e9d41b7e874369d1a083ab88c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99c4c3b3a577706d47fb4b01ca8d29c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#ga99c4c3b3a577706d47fb4b01ca8d29c0">Cy_CapSense_ScanInitializeHwIirAllSlots</a> (<a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga99c4c3b3a577706d47fb4b01ca8d29c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes (or re-initializes) the hardware IIR filter for all slots.  <a href="#ga99c4c3b3a577706d47fb4b01ca8d29c0">More...</a><br /></td></tr>
<tr class="separator:ga99c4c3b3a577706d47fb4b01ca8d29c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8445556444b88df5ecab63085e698c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#gac8445556444b88df5ecab63085e698c7">Cy_CapSense_ScanInitializeHwIirSlots</a> (uint32_t startSlotId, uint32_t numberSlots, <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:gac8445556444b88df5ecab63085e698c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes (or re-initializes) the hardware IIR filter for specified slots.  <a href="#gac8445556444b88df5ecab63085e698c7">More...</a><br /></td></tr>
<tr class="separator:gac8445556444b88df5ecab63085e698c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf43c0cf61a95f11a5981f82f5b0d4e86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#gaf43c0cf61a95f11a5981f82f5b0d4e86">Cy_CapSense_SetupWidgetExt</a> (uint32_t widgetId, uint32_t sensorId, <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:gaf43c0cf61a95f11a5981f82f5b0d4e86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs extended initialization for the specified widget and also performs initialization required for a specific sensor in the widget.  <a href="#gaf43c0cf61a95f11a5981f82f5b0d4e86">More...</a><br /></td></tr>
<tr class="separator:gaf43c0cf61a95f11a5981f82f5b0d4e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31834a3fce1f5b57c72107b419626bab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#ga31834a3fce1f5b57c72107b419626bab">Cy_CapSense_ScanExt</a> (<a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga31834a3fce1f5b57c72107b419626bab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a conversion on the pre-configured sensor.  <a href="#ga31834a3fce1f5b57c72107b419626bab">More...</a><br /></td></tr>
<tr class="separator:ga31834a3fce1f5b57c72107b419626bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa89c8ed15cddd778c2232c85300eb02d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#gaa89c8ed15cddd778c2232c85300eb02d">Cy_CapSense_GetParam</a> (uint32_t paramId, uint32_t *value, const void *ptrTuner, const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:gaa89c8ed15cddd778c2232c85300eb02d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a value of the specified parameter from the cy_capsense_tuner structure.  <a href="#gaa89c8ed15cddd778c2232c85300eb02d">More...</a><br /></td></tr>
<tr class="separator:gaa89c8ed15cddd778c2232c85300eb02d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6049654627a08e866ebe5e93ac414177"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#ga6049654627a08e866ebe5e93ac414177">Cy_CapSense_SetParam</a> (uint32_t paramId, uint32_t value, void *ptrTuner, <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga6049654627a08e866ebe5e93ac414177"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a new value for the specified parameter in cy_capsense_tuner structure.  <a href="#ga6049654627a08e866ebe5e93ac414177">More...</a><br /></td></tr>
<tr class="separator:ga6049654627a08e866ebe5e93ac414177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2de812825cd421ee05fec733206e157a"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#ga2de812825cd421ee05fec733206e157a">Cy_CapSense_GetCRC</a> (const uint8_t *ptrData, uint32_t len)</td></tr>
<tr class="memdesc:ga2de812825cd421ee05fec733206e157a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates CRC for the specified buffer and length.  <a href="#ga2de812825cd421ee05fec733206e157a">More...</a><br /></td></tr>
<tr class="separator:ga2de812825cd421ee05fec733206e157a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ad536f018dd41e585fdd27107355a47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#ga2ad536f018dd41e585fdd27107355a47">Cy_CapSense_SetWidgetStatus</a> (uint32_t widgetId, uint32_t mode, uint32_t value, <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga2ad536f018dd41e585fdd27107355a47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs configuring of the selected widget.  <a href="#ga2ad536f018dd41e585fdd27107355a47">More...</a><br /></td></tr>
<tr class="separator:ga2ad536f018dd41e585fdd27107355a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1ce2644b0e056f861befcf8180de138"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#gad1ce2644b0e056f861befcf8180de138">Cy_CapSense_IsWidgetEnabled</a> (uint32_t widgetId, const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:gad1ce2644b0e056f861befcf8180de138"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns widget enable/working status.  <a href="#gad1ce2644b0e056f861befcf8180de138">More...</a><br /></td></tr>
<tr class="separator:gad1ce2644b0e056f861befcf8180de138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fbab9345b72bd9fe35d7f6084feed52"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__low__level.html#ga4fbab9345b72bd9fe35d7f6084feed52">Cy_CapSense_IsSlotEnabled</a> (uint32_t slotId, const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga4fbab9345b72bd9fe35d7f6084feed52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns slot enable/working status.  <a href="#ga4fbab9345b72bd9fe35d7f6084feed52">More...</a><br /></td></tr>
<tr class="separator:ga4fbab9345b72bd9fe35d7f6084feed52"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="gafbfe743a98bd2c24a623a2c734c03f0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafbfe743a98bd2c24a623a2c734c03f0e">&#9670;&nbsp;</a></span>Cy_CapSense_ProcessWidgetExt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_ProcessWidgetExt </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>widgetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs customized data processing on the selected widget. </p>
<p>This function performs customized data processing specified by the mode parameter on a widget. This function can be used with any of the available scan functions. This function should be called only after all the sensors in the specified widget are scanned. Calling this function multiple times with the same mode without new sensor scan causes unexpected behavior. This function ignores the widget statuses like disabled and/or non-working and performs processing in any case.</p>
<p>The CY_CAPSENSE_PROCESS_CALC_NOISE and CY_CAPSENSE_PROCESS_THRESHOLDS masks for mode parameter are supported only when smart sensing algorithm is enabled.</p>
<p>The execution order of processing tasks starts from LSB to MSB of the mode parameter. To implement a different order of execution, call this function multiple times with the required mode parameter.</p>
<p>For more details, refer to function usage example below.</p>
<dl class="section note"><dt>Note</dt><dd>For the fifth-generation CAPSENSE&trade; and fifth-generation low power CAPSENSE&trade; extra processing should be performed prior a call of this function:<ul>
<li>A raw count pre-processing calling either the <a class="el" href="group__group__capsense__low__level.html#gad0772250c35cb3f630a8522b0b156692" title="Executes the pre-processing of scan raw data for specified widgets. ">Cy_CapSense_PreProcessWidget()</a> or <a class="el" href="group__group__capsense__low__level.html#gaf58d5ee3d30799c52819dccecad6730b" title="Executes the pre-processing of scan raw data for specified sensor. ">Cy_CapSense_PreProcessSensor()</a> functions.</li>
<li>A deconvolution for widgets with multi-phase Tx or Self calling the <a class="el" href="group__group__capsense__low__level.html#ga1460eefc048d987a811dbb7deba56e0f" title="Performs raw count deconvolution for the specified widget: ">Cy_CapSense_ProcessWidgetMpDeconvolution()</a> function (multi-phase Self is available only for the fifth-generation low power CAPSENSE&trade;) In this case a full processing flow consists of the following:</li>
<li><a class="el" href="group__group__capsense__low__level.html#gad0772250c35cb3f630a8522b0b156692" title="Executes the pre-processing of scan raw data for specified widgets. ">Cy_CapSense_PreProcessWidget()</a></li>
<li><a class="el" href="group__group__capsense__low__level.html#ga1460eefc048d987a811dbb7deba56e0f" title="Performs raw count deconvolution for the specified widget: ">Cy_CapSense_ProcessWidgetMpDeconvolution()</a></li>
<li><a class="el" href="group__group__capsense__low__level.html#gafbfe743a98bd2c24a623a2c734c03f0e" title="Performs customized data processing on the selected widget. ">Cy_CapSense_ProcessWidgetExt()</a></li>
</ul>
</dd></dl>
<p>For liquid level widget this function updates only widget status, other is skipped.</p>
<dl class="section note"><dt>Note</dt><dd>For the fifth generation and fifth-generation low power CAPSENSE&trade; if the specified widget has the enabled multi-frequency scan feature then the processing must follow the following order:<ul>
<li>Sub-widget channel 2</li>
<li>Sub-widget channel 1</li>
<li>Main widget channel 0 The CY_CAPSENSE_PROCESS_MFS_FILTER option is skipped for sub-widgets, however CY_CAPSENSE_PROCESS_STATUS option is available.</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">widgetId</td><td>Specifies the ID number of the widget. A macro for the widget ID can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;WIDGET_NAME&gt;_WDGT_ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>For the fifth-generation low power CAPSENSE&trade; widgets of the <a class="el" href="group__group__capsense__enums.html#gga855d894b24929f0d7d2774dfc4266d60aef4c95b7c358505b7e5b110dfc26a97e">CY_CAPSENSE_WD_LOW_POWER_E</a> type are not processed and <a class="el" href="group__group__capsense__macros__status.html#ga8497b8b090398be7d1550d31946c6013">CY_CAPSENSE_STATUS_BAD_PARAM</a> is returned if a widget of this type is passed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Specifies the type of widget processing to be executed for the specified widget:<ol type="1">
<li>Bits [31..7] - Reserved.</li>
<li>Bits [6..0] - CY_CAPSENSE_PROCESS_ALL - Execute all of the below tasks.</li>
<li>Bit [6] - CY_CAPSENSE_PROCESS_STATUS - Update the status (on/off, centroid position).</li>
<li>Bit [5] - CY_CAPSENSE_PROCESS_MFS_FILTER - Run the firmware filters for MFS on sensor rawcounts (applicable only for fifth-generation CAPSENSE&trade; and fifth-generation low power CAPSENSE&trade;).</li>
<li>Bit [4] - CY_CAPSENSE_PROCESS_THRESHOLDS - Update the thresholds (only in full auto-tuning mode).</li>
<li>Bit [3] - CY_CAPSENSE_PROCESS_CALC_NOISE - Calculate the noise (only in full auto-tuning mode).</li>
<li>Bit [2] - CY_CAPSENSE_PROCESS_DIFFCOUNTS - Update the difference counts of each sensor.</li>
<li>Bit [1] - CY_CAPSENSE_PROCESS_BASELINE - Update the baselines for all sensor.</li>
<li>Bit [0] - CY_CAPSENSE_PROCESS_FILTER - Run the firmware filters on sensor rawcounts.</li>
</ol>
</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the widget processing operation:<ul>
<li>CY_CAPSENSE_STATUS_SUCCESS - The processing is successfully performed.</li>
<li>CY_CAPSENSE_STATUS_BAD_PARAM - The input parameter is invalid.</li>
<li>CY_CAPSENSE_STATUS_BAD_DATA - The processing failed.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd></dd></dl>
<p>An example of customized data processing, changed processing order: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/*...*/</span></div><div class="line">    <span class="comment">/* Standard execution order (smart sensing algorithm is disabled):</span></div><div class="line"><span class="comment">    * - Filtering</span></div><div class="line"><span class="comment">    * - Baselining</span></div><div class="line"><span class="comment">    * - Difference calculation</span></div><div class="line"><span class="comment">    * - Status / Position calculation</span></div><div class="line"><span class="comment">    *</span></div><div class="line"><span class="comment">    * An example below makes a different order:</span></div><div class="line"><span class="comment">    * - filtering is executed as a last task</span></div><div class="line"><span class="comment">    */</span></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__capsense__macros__status.html#ga83824bf450f79f26a70da2b619cd07c7">CY_CAPSENSE_STATUS_SUCCESS</a> != <a class="code" href="group__group__capsense__low__level.html#gafbfe743a98bd2c24a623a2c734c03f0e">Cy_CapSense_ProcessWidgetExt</a>(CY_CAPSENSE_TOUCHPAD0_WDGT_ID,</div><div class="line">                                                                   <a class="code" href="group__group__capsense__macros__process.html#ga459185fc700d0afc4556d995730f6052">CY_CAPSENSE_PROCESS_BASELINE</a> |</div><div class="line">                                                                   <a class="code" href="group__group__capsense__macros__process.html#ga69cbf309ed5306c0845fbef6d31ba3e8">CY_CAPSENSE_PROCESS_DIFFCOUNTS</a> |</div><div class="line">                                                                   <a class="code" href="group__group__capsense__macros__process.html#ga1575721ebbdd600b13f843e068dbf282">CY_CAPSENSE_PROCESS_STATUS</a>,</div><div class="line">                                                                   &amp;cy_capsense_context))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Insert the error handle code here, for instance as below */</span></div><div class="line">        CY_ASSERT(0u);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__capsense__macros__status.html#ga83824bf450f79f26a70da2b619cd07c7">CY_CAPSENSE_STATUS_SUCCESS</a> != <a class="code" href="group__group__capsense__low__level.html#gafbfe743a98bd2c24a623a2c734c03f0e">Cy_CapSense_ProcessWidgetExt</a>(CY_CAPSENSE_TOUCHPAD0_WDGT_ID,</div><div class="line">                                                                   <a class="code" href="group__group__capsense__macros__process.html#gaa3b890d5a6646b1c990093614f904b7c">CY_CAPSENSE_PROCESS_FILTER</a>,</div><div class="line">                                                                   &amp;cy_capsense_context))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Insert the error handle code here, for instance as below */</span></div><div class="line">        CY_ASSERT(0u);</div><div class="line">    }</div><div class="line">    <span class="comment">/*...*/</span></div><div class="line"></div></div><!-- fragment -->
</div>
</div>
<a id="ga05d3f6e7d7fbef845ab4eb575e653dec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05d3f6e7d7fbef845ab4eb575e653dec">&#9670;&nbsp;</a></span>Cy_CapSense_ProcessSensorExt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_ProcessSensorExt </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>widgetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sensorId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs customized data processing on the selected sensor. </p>
<p>This function performs customized data processing specified by the mode parameter on a sensor. This function performs the exact same task of the <a class="el" href="group__group__capsense__low__level.html#gafbfe743a98bd2c24a623a2c734c03f0e" title="Performs customized data processing on the selected widget. ">Cy_CapSense_ProcessWidgetExt()</a> function but only on the specified sensor instead of all sensors in the widget.</p>
<p>The pipeline scan method (i.e. during scanning of a sensor, processing of a previously scanned sensor is performed) can be implemented using this function and it may reduce the total scan/process time, increase the refresh rate, and decrease the power consumption. For more details, refer to function usage example below.</p>
<dl class="section note"><dt>Note</dt><dd>For the fifth-generation CAPSENSE&trade; and fifth-generation low power CAPSENSE&trade; HW generation an extra processing should be performed prior a call of this function:<ul>
<li>A raw count pre-processing calling either the <a class="el" href="group__group__capsense__low__level.html#gad0772250c35cb3f630a8522b0b156692" title="Executes the pre-processing of scan raw data for specified widgets. ">Cy_CapSense_PreProcessWidget()</a> or <a class="el" href="group__group__capsense__low__level.html#gaf58d5ee3d30799c52819dccecad6730b" title="Executes the pre-processing of scan raw data for specified sensor. ">Cy_CapSense_PreProcessSensor()</a> functions.</li>
<li>A deconvolution for widgets with multi-phase Tx or Self calling the <a class="el" href="group__group__capsense__low__level.html#ga1460eefc048d987a811dbb7deba56e0f" title="Performs raw count deconvolution for the specified widget: ">Cy_CapSense_ProcessWidgetMpDeconvolution()</a> function (multi-phase Self is available only for the fifth-generation low power CAPSENSE&trade;) In this case a full processing flow consists of the following:</li>
<li><a class="el" href="group__group__capsense__low__level.html#gad0772250c35cb3f630a8522b0b156692" title="Executes the pre-processing of scan raw data for specified widgets. ">Cy_CapSense_PreProcessWidget()</a></li>
<li><a class="el" href="group__group__capsense__low__level.html#ga1460eefc048d987a811dbb7deba56e0f" title="Performs raw count deconvolution for the specified widget: ">Cy_CapSense_ProcessWidgetMpDeconvolution()</a></li>
<li><a class="el" href="group__group__capsense__low__level.html#ga05d3f6e7d7fbef845ab4eb575e653dec" title="Performs customized data processing on the selected sensor. ">Cy_CapSense_ProcessSensorExt()</a> - each sensor</li>
<li><a class="el" href="group__group__capsense__low__level.html#gafbfe743a98bd2c24a623a2c734c03f0e" title="Performs customized data processing on the selected widget. ">Cy_CapSense_ProcessWidgetExt()</a></li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">widgetId</td><td>Specifies the ID number of the widget. A macro for the widget ID can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;WIDGET_NAME&gt;_WDGT_ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>For the fifth-generation low power CAPSENSE&trade; widgets of the <a class="el" href="group__group__capsense__enums.html#gga855d894b24929f0d7d2774dfc4266d60aef4c95b7c358505b7e5b110dfc26a97e">CY_CAPSENSE_WD_LOW_POWER_E</a> type are not processed and <a class="el" href="group__group__capsense__macros__status.html#ga8497b8b090398be7d1550d31946c6013">CY_CAPSENSE_STATUS_BAD_PARAM</a> is returned if a widget of this type is passed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sensorId</td><td>Specifies the ID number of the sensor within the widget. A macro for the sensor ID within a specified widget can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;WIDGET_NAME&gt;_SNS&lt;SENSOR_NUMBER&gt;_ID.</td></tr>
    <tr><td class="paramname">mode</td><td>Specifies the type of the sensor processing that must be executed for the specified sensor:<ol type="1">
<li>Bits [31..7] - Reserved.</li>
<li>Bits [6..0] - CY_CAPSENSE_PROCESS_ALL - Execute all of the below tasks.</li>
<li>Bit [6] - CY_CAPSENSE_PROCESS_STATUS - Update the status (on/off, centroid position) - not available for this function.</li>
<li>Bit [5] - CY_CAPSENSE_PROCESS_MFS_FILTER - Run the firmware filters for MFS on sensor rawcounts - not available for this function. (applicable only for fifth-generation CAPSENSE&trade; and fifth-generation low power CAPSENSE&trade;).</li>
<li>Bit [4] - CY_CAPSENSE_PROCESS_THRESHOLDS - Update the thresholds (only in full auto-tuning mode).</li>
<li>Bit [3] - CY_CAPSENSE_PROCESS_CALC_NOISE - Calculate the noise (only in full auto-tuning mode).</li>
<li>Bit [2] - CY_CAPSENSE_PROCESS_DIFFCOUNTS - Update the difference counts of each sensor.</li>
<li>Bit [1] - CY_CAPSENSE_PROCESS_BASELINE - Update the baselines for all sensor.</li>
<li>Bit [0] - CY_CAPSENSE_PROCESS_FILTER - Run the firmware filters on sensor rawcounts.</li>
</ol>
</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the sensor process operation:<ul>
<li>CY_CAPSENSE_STATUS_SUCCESS - The processing is successfully performed.</li>
<li>CY_CAPSENSE_STATUS_BAD_PARAM - The input parameter is invalid.</li>
<li>CY_CAPSENSE_STATUS_BAD_DATA - The processing failed.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd></dd></dl>
<p>An example demonstrates pipeline implementation of sensor scanning and processing: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/*...*/</span></div><div class="line">    currentSenorsIndex = 0u;</div><div class="line"></div><div class="line">    <span class="comment">/* The first sensor scan start */</span></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__capsense__macros__status.html#ga83824bf450f79f26a70da2b619cd07c7">CY_CAPSENSE_STATUS_SUCCESS</a> != <a class="code" href="group__group__capsense__low__level.html#gae3f80b48c2596c149ca0b392a9a3da62">Cy_CapSense_ScanSensor</a>(CY_CAPSENSE_TOUCHPAD0_WDGT_ID,</div><div class="line">                                                             currentSenorsIndex,</div><div class="line">                                                             &amp;cy_capsense_context))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Insert the error handle code here, for instance as below */</span></div><div class="line">        CY_ASSERT(0u);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (;;)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">if</span> (<a class="code" href="group__group__capsense__macros__mw__state.html#ga1bd45eed2be393b7f53c20f1bae2814e">CY_CAPSENSE_NOT_BUSY</a> == <a class="code" href="group__group__capsense__high__level.html#ga7f8739755bba6b51c274f45b569b9ba0">Cy_CapSense_IsBusy</a>(&amp;cy_capsense_context))</div><div class="line">        {</div><div class="line">            <span class="comment">/* Store the current sensor index */</span></div><div class="line">            previousSensorIndex = currentSenorsIndex;</div><div class="line"></div><div class="line">            <span class="comment">/* Go to the next sensor */</span></div><div class="line">            currentSenorsIndex++;</div><div class="line">            <span class="keywordflow">if</span> (currentSenorsIndex == cy_capsense_context.ptrWdConfig[CY_CAPSENSE_TOUCHPAD0_WDGT_ID].numSns)</div><div class="line">            {</div><div class="line">                <span class="comment">/* Reset sensor index to start from the first sensor */</span></div><div class="line">                currentSenorsIndex = 0u;</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">/* The next sensor scan start */</span></div><div class="line">            <a class="code" href="group__group__capsense__low__level.html#gae3f80b48c2596c149ca0b392a9a3da62">Cy_CapSense_ScanSensor</a>(CY_CAPSENSE_TOUCHPAD0_WDGT_ID, currentSenorsIndex, &amp;cy_capsense_context);</div><div class="line"></div><div class="line">            <span class="comment">/* Process the previous sensor while scanning the next one */</span></div><div class="line">            <span class="keywordflow">if</span> (<a class="code" href="group__group__capsense__macros__status.html#ga83824bf450f79f26a70da2b619cd07c7">CY_CAPSENSE_STATUS_SUCCESS</a> != <a class="code" href="group__group__capsense__low__level.html#ga05d3f6e7d7fbef845ab4eb575e653dec">Cy_CapSense_ProcessSensorExt</a>(CY_CAPSENSE_TOUCHPAD0_WDGT_ID,</div><div class="line">                                                                           previousSensorIndex,</div><div class="line">                                                                           <a class="code" href="group__group__capsense__macros__process.html#gaa84b286a4e106b5eeed0141339f7ab6b">CY_CAPSENSE_PROCESS_ALL</a>,</div><div class="line">                                                                           &amp;cy_capsense_context))</div><div class="line">            {</div><div class="line">                <span class="comment">/* Insert the error handle code here, for instance as below */</span></div><div class="line">                CY_ASSERT(0u);</div><div class="line">            }</div><div class="line"></div><div class="line">            previousSensorIndex++;</div><div class="line">            <span class="keywordflow">if</span> (previousSensorIndex == cy_capsense_context.ptrWdConfig[CY_CAPSENSE_TOUCHPAD0_WDGT_ID].numSns)</div><div class="line">            {</div><div class="line">                <span class="comment">/* All widget sensors are processed, therefore process only widget-related task */</span></div><div class="line">                <span class="keywordflow">if</span> (<a class="code" href="group__group__capsense__macros__status.html#ga83824bf450f79f26a70da2b619cd07c7">CY_CAPSENSE_STATUS_SUCCESS</a> != <a class="code" href="group__group__capsense__low__level.html#gafbfe743a98bd2c24a623a2c734c03f0e">Cy_CapSense_ProcessWidgetExt</a>(CY_CAPSENSE_TOUCHPAD0_WDGT_ID,</div><div class="line">                                                                               <a class="code" href="group__group__capsense__macros__process.html#ga1575721ebbdd600b13f843e068dbf282">CY_CAPSENSE_PROCESS_STATUS</a>,</div><div class="line">                                                                              &amp;cy_capsense_context))</div><div class="line">                {</div><div class="line">                    <span class="comment">/* Insert the error handle code here, for instance as below */</span></div><div class="line">                    CY_ASSERT(0u);</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="comment">/*...*/</span></div><div class="line"></div></div><!-- fragment -->
</div>
</div>
<a id="ga9282e8184026228ec7b8e1cf22829e55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9282e8184026228ec7b8e1cf22829e55">&#9670;&nbsp;</a></span>Cy_CapSense_ReadWidgetCdacParam()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_CapSense_ReadWidgetCdacParam </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>ptrBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>widgetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the CDAC parameters of the widget and writes them into the buffer. </p>
<p>Reads CDAC parameters from CAPSENSE&trade; Data Structure and writes received values into the provided buffer. This function must be called after <a class="el" href="group__group__capsense__high__level.html#gade28f1f915ce6b97f13399074a819c0d" title="Initializes the CAPSENSE™ firmware modules. ">Cy_CapSense_Enable()</a>. In case of run-time usage make sure you have updated all statuses, baselines, history of filtering, etc.</p>
<dl class="section note"><dt>Note</dt><dd>This function is available only for the fifth-generation low power CAPSENSE&trade;.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrBuffer</td><td>Buffer to store the CDAC parameters.</td></tr>
    <tr><td class="paramname">widgetId</td><td>Specifies the ID number of the widget. A macro for the widget ID can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;WIDGET_NAME&gt;_WDGT_ID.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function Usage</dt><dd></dd></dl>
<p>The function is used for one-time calibration. Full example:</p>
<ol type="1">
<li>Add EEPROM configuration: <div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">    #define CY_ASSERT_FAILED                (0u)</span></div><div class="line">    </div><div class="line">    <span class="comment">/* Emulated EEPROM Configuration details. All the sizes mentioned are in bytes.</span></div><div class="line"><span class="comment">    * For details on how to configure these values refer to cy_em_eeprom.h. The</span></div><div class="line"><span class="comment">    * middleware documentation is provided in Emulated EEPROM API Reference Manual.</span></div><div class="line"><span class="comment">    * The user can access it from the Documentation section in the Quick Panel.</span></div><div class="line"><span class="comment">    */</span></div><div class="line"><span class="preprocessor">    #define WD_CDAC_PARMS_SIZE              (1u+ 1u +1u +2u) // Status+CRef+CFine+CComp_div</span></div><div class="line"><span class="preprocessor">    #define TOTAL_WD_CDAC_PARMS_SIZE        (CY_CAPSENSE_TOTAL_WIDGET_COUNT * WD_CDAC_PARMS_SIZE)</span></div><div class="line"><span class="preprocessor">    #define SNS_CDAC_PARMS_SIZE             (CY_CAPSENSE_SENSOR_COUNT * 1u) // CComp</span></div><div class="line"><span class="preprocessor">    #define TOTAL_CDAC_PARMS_SIZE           (TOTAL_WD_CDAC_PARMS_SIZE + SNS_CDAC_PARMS_SIZE)</span></div><div class="line"></div><div class="line">    <span class="comment">/* Logical Size of Emulated EEPROM in bytes */</span></div><div class="line"><span class="preprocessor">    #define LOGICAL_EM_EEPROM_SIZE          TOTAL_CDAC_PARMS_SIZE</span></div><div class="line"><span class="preprocessor">    #define LOGICAL_EM_EEPROM_START         (0u)</span></div><div class="line"></div><div class="line"><span class="preprocessor">    #define EEPROM_VALID                    (1u)</span></div><div class="line"><span class="preprocessor">    #define EEPROM_STATE_OFFSET             (0u)</span></div><div class="line"><span class="preprocessor">    #define EEPROM_DATA_OFFSET              (1u)</span></div><div class="line"></div><div class="line">    cy_stc_eeprom_context_t em_eeprom_context;</div><div class="line">    uint8_t eeprom_data[LOGICAL_EM_EEPROM_SIZE];</div><div class="line"></div><div class="line">    <span class="comment">/*If enabled (1 - enabled, 0 - disabled), a checksum (stored in a row) is calculated on each row of data,</span></div><div class="line"><span class="comment">    * while a redundant copy of Em_EEPROM is stored in another location.</span></div><div class="line"><span class="comment">    * When data is read, first the checksum is checked. If that checksum is bad,</span></div><div class="line"><span class="comment">    and the redundant copy&#39;s checksum is good, the copy is restored.</span></div><div class="line"><span class="comment">    */</span></div><div class="line"><span class="preprocessor">    #define REDUNDANT_COPY              (1u)</span></div><div class="line"></div><div class="line">    <span class="comment">/*If enabled (1 - enabled, 0 - disabled), the blocking writes to nvm are used in the design.</span></div><div class="line"><span class="comment">    * Otherwise, non-blocking nvm writes are used. From the user&#39;s perspective,</span></div><div class="line"><span class="comment">    * the behavior of blocking and non-blocking writes are the same - the difference is that</span></div><div class="line"><span class="comment">    * the non-blocking writes do not block the interrupts.</span></div><div class="line"><span class="comment">    Note</span></div><div class="line"><span class="comment">    Non-blocking nvm write is only supported by PSoC 6.</span></div><div class="line"><span class="comment">    */</span></div><div class="line"><span class="preprocessor">    #define BLOCKING_WRITE              (1u)</span></div><div class="line"></div><div class="line">    <span class="comment">/*The higher the factor is, the more nvm is used, but a higher number of erase/write cycles can be done on Em_EEPROM.</span></div><div class="line"><span class="comment">    * Multiply this number by the datasheet write endurance spec to determine the max of write cycles.</span></div><div class="line"><span class="comment">    * The amount of wear leveling from 1 to 10. 1 means no wear leveling is used.</span></div><div class="line"><span class="comment">    */</span></div><div class="line"><span class="preprocessor">    #define WEAR_LEVELLING_FACTOR       (2u)</span></div><div class="line"></div><div class="line">    <span class="comment">/*Simple mode, when enabled (1 - enabled, 0 - disabled),</span></div><div class="line"><span class="comment">    * means no additional service information is stored by the Em_EEPROM middleware</span></div><div class="line"><span class="comment">    * like checksums, headers, a number of writes, etc.</span></div><div class="line"><span class="comment">    */</span></div><div class="line"><span class="preprocessor">    #define SIMPLE_MODE                 (0u)</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">    #define EM_EEPROM_SIZE   ((TOTAL_CDAC_PARMS_SIZE % CY_EM_EEPROM_FLASH_SIZEOF_ROW) ? ((TOTAL_CDAC_PARMS_SIZE / CY_EM_EEPROM_FLASH_SIZEOF_ROW) + 1) * CY_EM_EEPROM_FLASH_SIZEOF_ROW  : (TOTAL_CDAC_PARMS_SIZE / CY_EM_EEPROM_FLASH_SIZEOF_ROW) *  CY_EM_EEPROM_FLASH_SIZEOF_ROW)</span></div><div class="line"><span class="preprocessor">    #define EM_EEPROM_PHYSICAL_SIZE     (CY_EM_EEPROM_GET_PHYSICAL_SIZE(EM_EEPROM_SIZE, SIMPLE_MODE, WEAR_LEVELLING_FACTOR, REDUNDANT_COPY))</span></div><div class="line"></div><div class="line">    cy_stc_eeprom_context_t em_eeprom_context;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> cy_stc_eeprom_config_t em_eeprom_config = { .eepromSize = EM_EEPROM_SIZE, <span class="comment">/* 256 bytes */</span></div><div class="line">    .blockingWrite = BLOCKING_WRITE, <span class="comment">/* Blocking writes enabled */</span></div><div class="line">    .redundantCopy = REDUNDANT_COPY, <span class="comment">/* Redundant copy enabled */</span></div><div class="line">    .wearLevelingFactor = WEAR_LEVELLING_FACTOR, <span class="comment">/* Wear levelling factor of 2 */</span></div><div class="line">    .simpleMode = SIMPLE_MODE, <span class="comment">/* Simple mode disabled */</span></div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">/* EEPROM storage Emulated EEPROM flash. */</span></div><div class="line">    CY_ALIGN( CY_EM_EEPROM_FLASH_SIZEOF_ROW)</div><div class="line">    <span class="keyword">const</span> uint8_t em_eeprom_storage[EM_EEPROM_PHYSICAL_SIZE] = { 0u };</div><div class="line"></div></div><!-- fragment --></li>
<li>Add EEPROM initialization: <div class="fragment"><div class="line">    cy_en_em_eeprom_status_t em_eeprom_status;</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize the flash start address in Emulated EEPROM configuration structure*/</span></div><div class="line">    em_eeprom_config.userFlashStartAddr = (uint32_t)em_eeprom_storage;</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize Emulated EEPROM */</span></div><div class="line">    em_eeprom_status = Cy_Em_EEPROM_Init(&amp;em_eeprom_config, &amp;em_eeprom_context);</div><div class="line"></div><div class="line">    <span class="comment">/* Emulated EEPROM init failed. Stop program execution */</span></div><div class="line">    <span class="keywordflow">if</span> (em_eeprom_status != CY_EM_EEPROM_SUCCESS)</div><div class="line">    {</div><div class="line">        CY_ASSERT(CY_ASSERT_FAILED);</div><div class="line">    }</div></div><!-- fragment --></li>
<li>Liquid level one-time calibration: <div class="fragment"><div class="line">    uint8_t *ptr_eeprom_data = 0;</div><div class="line">    uint32_t wd_id;</div><div class="line"></div><div class="line">    <a class="code" href="group__group__capsense__high__level.html#ga19b3aa9e14a04b76188f917c0dc004f5">Cy_CapSense_Init</a>(&amp;cy_capsense_context);</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize interrupt */</span></div><div class="line">    Cy_SysInt_Init(&amp;CapSense_ISR_cfg, &amp;CapSense_InterruptHandler);</div><div class="line">    NVIC_ClearPendingIRQ(CapSense_ISR_cfg.intrSrc);</div><div class="line">    NVIC_EnableIRQ(CapSense_ISR_cfg.intrSrc);</div><div class="line"></div><div class="line">    <span class="comment">/* Read the factory calibrated values from EEPROM*/</span></div><div class="line">    Cy_Em_EEPROM_Read(LOGICAL_EM_EEPROM_START, eeprom_data,</div><div class="line">    LOGICAL_EM_EEPROM_SIZE, &amp;em_eeprom_context);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (wd_id = 0u; wd_id &lt; CY_CAPSENSE_WIDGET_COUNT; wd_id++)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Get the EEPROM pointer location of the widget*/</span></div><div class="line">        ptr_eeprom_data = &amp;eeprom_data[get_eeprom_buffer_position(wd_id)];</div><div class="line"></div><div class="line">        <span class="comment">/* Set the status flag to ready state before writing into EEPROM.*/</span></div><div class="line">        <a class="code" href="group__group__capsense__low__level.html#ga2b6d787bf68eea9a889d8c7eec40af78">Cy_CapSense_SetWidgetCalibrationState</a>(wd_id,</div><div class="line">        ptr_eeprom_data[EEPROM_STATE_OFFSET], &amp;cy_capsense_context);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (<a class="code" href="group__group__capsense__low__level.html#ga3b8f58a0d6db406bca0c7caf94379854">Cy_CapSense_IsLlwCalibrationValid</a>(wd_id, &amp;cy_capsense_context) &amp;&amp;</div><div class="line">            (EEPROM_VALID == ptr_eeprom_data[EEPROM_STATE_OFFSET]))</div><div class="line">        {</div><div class="line">            <span class="comment">/* Update CDAC parameters with the factory calibrated values read from EEPROM */</span></div><div class="line">            <a class="code" href="group__group__capsense__low__level.html#ga95c9816b8cb62a2c555ee3398558cf38">Cy_CapSense_WriteWidgetCdacParam</a>(&amp;ptr_eeprom_data[EEPROM_DATA_OFFSET], wd_id,</div><div class="line">                    &amp;cy_capsense_context);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize the CAPSENSE firmware modules. This will skip the calibration of the LLS widget */</span></div><div class="line">    status = <a class="code" href="group__group__capsense__high__level.html#gade28f1f915ce6b97f13399074a819c0d">Cy_CapSense_Enable</a>(&amp;cy_capsense_context);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (wd_id = 0u; wd_id &lt; CY_CAPSENSE_WIDGET_COUNT; wd_id++)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Get the EEPROM pointer location of the widget*/</span></div><div class="line">        ptr_eeprom_data = &amp;eeprom_data[get_eeprom_buffer_position(wd_id)];</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (<a class="code" href="group__group__capsense__low__level.html#ga3b8f58a0d6db406bca0c7caf94379854">Cy_CapSense_IsLlwCalibrationValid</a>(wd_id, &amp;cy_capsense_context) &amp;&amp;</div><div class="line">            (0u == ptr_eeprom_data[EEPROM_STATE_OFFSET]))</div><div class="line">        {</div><div class="line">            <span class="comment">/* Reads the calibrated values from context to eeprom buffer*/</span></div><div class="line">            <a class="code" href="group__group__capsense__low__level.html#ga9282e8184026228ec7b8e1cf22829e55">Cy_CapSense_ReadWidgetCdacParam</a>(&amp;ptr_eeprom_data[EEPROM_DATA_OFFSET], wd_id,</div><div class="line">                    &amp;cy_capsense_context);</div><div class="line"></div><div class="line">            <span class="comment">/* Set the status flag to valid before writing into EEPROM*/</span></div><div class="line">            ptr_eeprom_data[EEPROM_STATE_OFFSET] = EEPROM_VALID; </div><div class="line"></div><div class="line">            <span class="comment">/* Update the local calibration status flag */</span></div><div class="line">            <a class="code" href="group__group__capsense__low__level.html#ga2b6d787bf68eea9a889d8c7eec40af78">Cy_CapSense_SetWidgetCalibrationState</a>(wd_id,</div><div class="line">            ptr_eeprom_data[EEPROM_STATE_OFFSET], &amp;cy_capsense_context);</div><div class="line"></div><div class="line">            <span class="comment">/* Write the factory calibrated values to EEPROM*/</span></div><div class="line">            Cy_Em_EEPROM_Write(LOGICAL_EM_EEPROM_START, eeprom_data,</div><div class="line">            LOGICAL_EM_EEPROM_SIZE, &amp;em_eeprom_context);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div></div><!-- fragment --></li>
<li>Add API to get buffer posiiton in EEPROM: <div class="fragment"><div class="line"><span class="keyword">static</span> uint32_t get_eeprom_buffer_position(uint32_t wd_id)</div><div class="line">{</div><div class="line">    uint32_t wd_index;</div><div class="line">    uint32_t ptr_index = 0;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (wd_index = 0u; wd_index &lt; wd_id; wd_index++)</div><div class="line">    {</div><div class="line">        ptr_index += (WD_CDAC_PARMS_SIZE</div><div class="line">                + cy_capsense_context.ptrWdConfig[wd_index].numSns);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> ptr_index;</div><div class="line">}</div></div><!-- fragment --></li>
</ol>

</div>
</div>
<a id="ga95c9816b8cb62a2c555ee3398558cf38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95c9816b8cb62a2c555ee3398558cf38">&#9670;&nbsp;</a></span>Cy_CapSense_WriteWidgetCdacParam()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_CapSense_WriteWidgetCdacParam </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>ptrBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>widgetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse buffer as CDAC parameters and writes them into a CAPSENSE&trade; Data Structure. </p>
<p>Reads a provided buffer content and writes received values into CAPSENSE&trade; Data Structure. This function must be called before <a class="el" href="group__group__capsense__high__level.html#gade28f1f915ce6b97f13399074a819c0d" title="Initializes the CAPSENSE™ firmware modules. ">Cy_CapSense_Enable()</a> and after <a class="el" href="group__group__capsense__high__level.html#ga19b3aa9e14a04b76188f917c0dc004f5" title="Captures HW blocks (one or more) for CAPSENSE™ operations and configures them to the default state...">Cy_CapSense_Init()</a>. In case of run-time usage make sure you have updated all statuses, baselines, history of filtering, etc.</p>
<dl class="section note"><dt>Note</dt><dd>This function is available only for the fifth-generation low power CAPSENSE&trade;.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrBuffer</td><td>Buffer to store the CDAC parameters.</td></tr>
    <tr><td class="paramname">widgetId</td><td>Specifies the ID number of the widget. A macro for the widget ID can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;WIDGET_NAME&gt;_WDGT_ID.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function Usage</dt><dd></dd></dl>
<p>The function is used for one-time calibration. Full example:</p>
<ol type="1">
<li>Add EEPROM configuration: <div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">    #define CY_ASSERT_FAILED                (0u)</span></div><div class="line">    </div><div class="line">    <span class="comment">/* Emulated EEPROM Configuration details. All the sizes mentioned are in bytes.</span></div><div class="line"><span class="comment">    * For details on how to configure these values refer to cy_em_eeprom.h. The</span></div><div class="line"><span class="comment">    * middleware documentation is provided in Emulated EEPROM API Reference Manual.</span></div><div class="line"><span class="comment">    * The user can access it from the Documentation section in the Quick Panel.</span></div><div class="line"><span class="comment">    */</span></div><div class="line"><span class="preprocessor">    #define WD_CDAC_PARMS_SIZE              (1u+ 1u +1u +2u) // Status+CRef+CFine+CComp_div</span></div><div class="line"><span class="preprocessor">    #define TOTAL_WD_CDAC_PARMS_SIZE        (CY_CAPSENSE_TOTAL_WIDGET_COUNT * WD_CDAC_PARMS_SIZE)</span></div><div class="line"><span class="preprocessor">    #define SNS_CDAC_PARMS_SIZE             (CY_CAPSENSE_SENSOR_COUNT * 1u) // CComp</span></div><div class="line"><span class="preprocessor">    #define TOTAL_CDAC_PARMS_SIZE           (TOTAL_WD_CDAC_PARMS_SIZE + SNS_CDAC_PARMS_SIZE)</span></div><div class="line"></div><div class="line">    <span class="comment">/* Logical Size of Emulated EEPROM in bytes */</span></div><div class="line"><span class="preprocessor">    #define LOGICAL_EM_EEPROM_SIZE          TOTAL_CDAC_PARMS_SIZE</span></div><div class="line"><span class="preprocessor">    #define LOGICAL_EM_EEPROM_START         (0u)</span></div><div class="line"></div><div class="line"><span class="preprocessor">    #define EEPROM_VALID                    (1u)</span></div><div class="line"><span class="preprocessor">    #define EEPROM_STATE_OFFSET             (0u)</span></div><div class="line"><span class="preprocessor">    #define EEPROM_DATA_OFFSET              (1u)</span></div><div class="line"></div><div class="line">    cy_stc_eeprom_context_t em_eeprom_context;</div><div class="line">    uint8_t eeprom_data[LOGICAL_EM_EEPROM_SIZE];</div><div class="line"></div><div class="line">    <span class="comment">/*If enabled (1 - enabled, 0 - disabled), a checksum (stored in a row) is calculated on each row of data,</span></div><div class="line"><span class="comment">    * while a redundant copy of Em_EEPROM is stored in another location.</span></div><div class="line"><span class="comment">    * When data is read, first the checksum is checked. If that checksum is bad,</span></div><div class="line"><span class="comment">    and the redundant copy&#39;s checksum is good, the copy is restored.</span></div><div class="line"><span class="comment">    */</span></div><div class="line"><span class="preprocessor">    #define REDUNDANT_COPY              (1u)</span></div><div class="line"></div><div class="line">    <span class="comment">/*If enabled (1 - enabled, 0 - disabled), the blocking writes to nvm are used in the design.</span></div><div class="line"><span class="comment">    * Otherwise, non-blocking nvm writes are used. From the user&#39;s perspective,</span></div><div class="line"><span class="comment">    * the behavior of blocking and non-blocking writes are the same - the difference is that</span></div><div class="line"><span class="comment">    * the non-blocking writes do not block the interrupts.</span></div><div class="line"><span class="comment">    Note</span></div><div class="line"><span class="comment">    Non-blocking nvm write is only supported by PSoC 6.</span></div><div class="line"><span class="comment">    */</span></div><div class="line"><span class="preprocessor">    #define BLOCKING_WRITE              (1u)</span></div><div class="line"></div><div class="line">    <span class="comment">/*The higher the factor is, the more nvm is used, but a higher number of erase/write cycles can be done on Em_EEPROM.</span></div><div class="line"><span class="comment">    * Multiply this number by the datasheet write endurance spec to determine the max of write cycles.</span></div><div class="line"><span class="comment">    * The amount of wear leveling from 1 to 10. 1 means no wear leveling is used.</span></div><div class="line"><span class="comment">    */</span></div><div class="line"><span class="preprocessor">    #define WEAR_LEVELLING_FACTOR       (2u)</span></div><div class="line"></div><div class="line">    <span class="comment">/*Simple mode, when enabled (1 - enabled, 0 - disabled),</span></div><div class="line"><span class="comment">    * means no additional service information is stored by the Em_EEPROM middleware</span></div><div class="line"><span class="comment">    * like checksums, headers, a number of writes, etc.</span></div><div class="line"><span class="comment">    */</span></div><div class="line"><span class="preprocessor">    #define SIMPLE_MODE                 (0u)</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">    #define EM_EEPROM_SIZE   ((TOTAL_CDAC_PARMS_SIZE % CY_EM_EEPROM_FLASH_SIZEOF_ROW) ? ((TOTAL_CDAC_PARMS_SIZE / CY_EM_EEPROM_FLASH_SIZEOF_ROW) + 1) * CY_EM_EEPROM_FLASH_SIZEOF_ROW  : (TOTAL_CDAC_PARMS_SIZE / CY_EM_EEPROM_FLASH_SIZEOF_ROW) *  CY_EM_EEPROM_FLASH_SIZEOF_ROW)</span></div><div class="line"><span class="preprocessor">    #define EM_EEPROM_PHYSICAL_SIZE     (CY_EM_EEPROM_GET_PHYSICAL_SIZE(EM_EEPROM_SIZE, SIMPLE_MODE, WEAR_LEVELLING_FACTOR, REDUNDANT_COPY))</span></div><div class="line"></div><div class="line">    cy_stc_eeprom_context_t em_eeprom_context;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> cy_stc_eeprom_config_t em_eeprom_config = { .eepromSize = EM_EEPROM_SIZE, <span class="comment">/* 256 bytes */</span></div><div class="line">    .blockingWrite = BLOCKING_WRITE, <span class="comment">/* Blocking writes enabled */</span></div><div class="line">    .redundantCopy = REDUNDANT_COPY, <span class="comment">/* Redundant copy enabled */</span></div><div class="line">    .wearLevelingFactor = WEAR_LEVELLING_FACTOR, <span class="comment">/* Wear levelling factor of 2 */</span></div><div class="line">    .simpleMode = SIMPLE_MODE, <span class="comment">/* Simple mode disabled */</span></div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">/* EEPROM storage Emulated EEPROM flash. */</span></div><div class="line">    CY_ALIGN( CY_EM_EEPROM_FLASH_SIZEOF_ROW)</div><div class="line">    <span class="keyword">const</span> uint8_t em_eeprom_storage[EM_EEPROM_PHYSICAL_SIZE] = { 0u };</div><div class="line"></div></div><!-- fragment --></li>
<li>Add EEPROM initialization: <div class="fragment"><div class="line">    cy_en_em_eeprom_status_t em_eeprom_status;</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize the flash start address in Emulated EEPROM configuration structure*/</span></div><div class="line">    em_eeprom_config.userFlashStartAddr = (uint32_t)em_eeprom_storage;</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize Emulated EEPROM */</span></div><div class="line">    em_eeprom_status = Cy_Em_EEPROM_Init(&amp;em_eeprom_config, &amp;em_eeprom_context);</div><div class="line"></div><div class="line">    <span class="comment">/* Emulated EEPROM init failed. Stop program execution */</span></div><div class="line">    <span class="keywordflow">if</span> (em_eeprom_status != CY_EM_EEPROM_SUCCESS)</div><div class="line">    {</div><div class="line">        CY_ASSERT(CY_ASSERT_FAILED);</div><div class="line">    }</div></div><!-- fragment --></li>
<li>Liquid level one-time calibration: <div class="fragment"><div class="line">    uint8_t *ptr_eeprom_data = 0;</div><div class="line">    uint32_t wd_id;</div><div class="line"></div><div class="line">    <a class="code" href="group__group__capsense__high__level.html#ga19b3aa9e14a04b76188f917c0dc004f5">Cy_CapSense_Init</a>(&amp;cy_capsense_context);</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize interrupt */</span></div><div class="line">    Cy_SysInt_Init(&amp;CapSense_ISR_cfg, &amp;CapSense_InterruptHandler);</div><div class="line">    NVIC_ClearPendingIRQ(CapSense_ISR_cfg.intrSrc);</div><div class="line">    NVIC_EnableIRQ(CapSense_ISR_cfg.intrSrc);</div><div class="line"></div><div class="line">    <span class="comment">/* Read the factory calibrated values from EEPROM*/</span></div><div class="line">    Cy_Em_EEPROM_Read(LOGICAL_EM_EEPROM_START, eeprom_data,</div><div class="line">    LOGICAL_EM_EEPROM_SIZE, &amp;em_eeprom_context);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (wd_id = 0u; wd_id &lt; CY_CAPSENSE_WIDGET_COUNT; wd_id++)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Get the EEPROM pointer location of the widget*/</span></div><div class="line">        ptr_eeprom_data = &amp;eeprom_data[get_eeprom_buffer_position(wd_id)];</div><div class="line"></div><div class="line">        <span class="comment">/* Set the status flag to ready state before writing into EEPROM.*/</span></div><div class="line">        <a class="code" href="group__group__capsense__low__level.html#ga2b6d787bf68eea9a889d8c7eec40af78">Cy_CapSense_SetWidgetCalibrationState</a>(wd_id,</div><div class="line">        ptr_eeprom_data[EEPROM_STATE_OFFSET], &amp;cy_capsense_context);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (<a class="code" href="group__group__capsense__low__level.html#ga3b8f58a0d6db406bca0c7caf94379854">Cy_CapSense_IsLlwCalibrationValid</a>(wd_id, &amp;cy_capsense_context) &amp;&amp;</div><div class="line">            (EEPROM_VALID == ptr_eeprom_data[EEPROM_STATE_OFFSET]))</div><div class="line">        {</div><div class="line">            <span class="comment">/* Update CDAC parameters with the factory calibrated values read from EEPROM */</span></div><div class="line">            <a class="code" href="group__group__capsense__low__level.html#ga95c9816b8cb62a2c555ee3398558cf38">Cy_CapSense_WriteWidgetCdacParam</a>(&amp;ptr_eeprom_data[EEPROM_DATA_OFFSET], wd_id,</div><div class="line">                    &amp;cy_capsense_context);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize the CAPSENSE firmware modules. This will skip the calibration of the LLS widget */</span></div><div class="line">    status = <a class="code" href="group__group__capsense__high__level.html#gade28f1f915ce6b97f13399074a819c0d">Cy_CapSense_Enable</a>(&amp;cy_capsense_context);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (wd_id = 0u; wd_id &lt; CY_CAPSENSE_WIDGET_COUNT; wd_id++)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Get the EEPROM pointer location of the widget*/</span></div><div class="line">        ptr_eeprom_data = &amp;eeprom_data[get_eeprom_buffer_position(wd_id)];</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (<a class="code" href="group__group__capsense__low__level.html#ga3b8f58a0d6db406bca0c7caf94379854">Cy_CapSense_IsLlwCalibrationValid</a>(wd_id, &amp;cy_capsense_context) &amp;&amp;</div><div class="line">            (0u == ptr_eeprom_data[EEPROM_STATE_OFFSET]))</div><div class="line">        {</div><div class="line">            <span class="comment">/* Reads the calibrated values from context to eeprom buffer*/</span></div><div class="line">            <a class="code" href="group__group__capsense__low__level.html#ga9282e8184026228ec7b8e1cf22829e55">Cy_CapSense_ReadWidgetCdacParam</a>(&amp;ptr_eeprom_data[EEPROM_DATA_OFFSET], wd_id,</div><div class="line">                    &amp;cy_capsense_context);</div><div class="line"></div><div class="line">            <span class="comment">/* Set the status flag to valid before writing into EEPROM*/</span></div><div class="line">            ptr_eeprom_data[EEPROM_STATE_OFFSET] = EEPROM_VALID; </div><div class="line"></div><div class="line">            <span class="comment">/* Update the local calibration status flag */</span></div><div class="line">            <a class="code" href="group__group__capsense__low__level.html#ga2b6d787bf68eea9a889d8c7eec40af78">Cy_CapSense_SetWidgetCalibrationState</a>(wd_id,</div><div class="line">            ptr_eeprom_data[EEPROM_STATE_OFFSET], &amp;cy_capsense_context);</div><div class="line"></div><div class="line">            <span class="comment">/* Write the factory calibrated values to EEPROM*/</span></div><div class="line">            Cy_Em_EEPROM_Write(LOGICAL_EM_EEPROM_START, eeprom_data,</div><div class="line">            LOGICAL_EM_EEPROM_SIZE, &amp;em_eeprom_context);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div></div><!-- fragment --></li>
<li>Add API to get buffer posiiton in EEPROM: <div class="fragment"><div class="line"><span class="keyword">static</span> uint32_t get_eeprom_buffer_position(uint32_t wd_id)</div><div class="line">{</div><div class="line">    uint32_t wd_index;</div><div class="line">    uint32_t ptr_index = 0;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (wd_index = 0u; wd_index &lt; wd_id; wd_index++)</div><div class="line">    {</div><div class="line">        ptr_index += (WD_CDAC_PARMS_SIZE</div><div class="line">                + cy_capsense_context.ptrWdConfig[wd_index].numSns);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> ptr_index;</div><div class="line">}</div></div><!-- fragment --></li>
</ol>

</div>
</div>
<a id="ga2b6d787bf68eea9a889d8c7eec40af78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b6d787bf68eea9a889d8c7eec40af78">&#9670;&nbsp;</a></span>Cy_CapSense_SetWidgetCalibrationState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_CapSense_SetWidgetCalibrationState </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>widgetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets widget calibration state. </p>
<dl class="section note"><dt>Note</dt><dd>This function is available only for the fifth-generation low power CAPSENSE&trade;.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">widgetId</td><td>Specifies the ID number of the widget. A macro for the widget ID can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;WIDGET_NAME&gt;_WDGT_ID.</td></tr>
    <tr><td class="paramname">state</td><td>The calibration state to set for the widget.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function Usage</dt><dd></dd></dl>
<p>The function is used for one-time calibration. Full example:</p>
<ol type="1">
<li>Add EEPROM configuration: <div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">    #define CY_ASSERT_FAILED                (0u)</span></div><div class="line">    </div><div class="line">    <span class="comment">/* Emulated EEPROM Configuration details. All the sizes mentioned are in bytes.</span></div><div class="line"><span class="comment">    * For details on how to configure these values refer to cy_em_eeprom.h. The</span></div><div class="line"><span class="comment">    * middleware documentation is provided in Emulated EEPROM API Reference Manual.</span></div><div class="line"><span class="comment">    * The user can access it from the Documentation section in the Quick Panel.</span></div><div class="line"><span class="comment">    */</span></div><div class="line"><span class="preprocessor">    #define WD_CDAC_PARMS_SIZE              (1u+ 1u +1u +2u) // Status+CRef+CFine+CComp_div</span></div><div class="line"><span class="preprocessor">    #define TOTAL_WD_CDAC_PARMS_SIZE        (CY_CAPSENSE_TOTAL_WIDGET_COUNT * WD_CDAC_PARMS_SIZE)</span></div><div class="line"><span class="preprocessor">    #define SNS_CDAC_PARMS_SIZE             (CY_CAPSENSE_SENSOR_COUNT * 1u) // CComp</span></div><div class="line"><span class="preprocessor">    #define TOTAL_CDAC_PARMS_SIZE           (TOTAL_WD_CDAC_PARMS_SIZE + SNS_CDAC_PARMS_SIZE)</span></div><div class="line"></div><div class="line">    <span class="comment">/* Logical Size of Emulated EEPROM in bytes */</span></div><div class="line"><span class="preprocessor">    #define LOGICAL_EM_EEPROM_SIZE          TOTAL_CDAC_PARMS_SIZE</span></div><div class="line"><span class="preprocessor">    #define LOGICAL_EM_EEPROM_START         (0u)</span></div><div class="line"></div><div class="line"><span class="preprocessor">    #define EEPROM_VALID                    (1u)</span></div><div class="line"><span class="preprocessor">    #define EEPROM_STATE_OFFSET             (0u)</span></div><div class="line"><span class="preprocessor">    #define EEPROM_DATA_OFFSET              (1u)</span></div><div class="line"></div><div class="line">    cy_stc_eeprom_context_t em_eeprom_context;</div><div class="line">    uint8_t eeprom_data[LOGICAL_EM_EEPROM_SIZE];</div><div class="line"></div><div class="line">    <span class="comment">/*If enabled (1 - enabled, 0 - disabled), a checksum (stored in a row) is calculated on each row of data,</span></div><div class="line"><span class="comment">    * while a redundant copy of Em_EEPROM is stored in another location.</span></div><div class="line"><span class="comment">    * When data is read, first the checksum is checked. If that checksum is bad,</span></div><div class="line"><span class="comment">    and the redundant copy&#39;s checksum is good, the copy is restored.</span></div><div class="line"><span class="comment">    */</span></div><div class="line"><span class="preprocessor">    #define REDUNDANT_COPY              (1u)</span></div><div class="line"></div><div class="line">    <span class="comment">/*If enabled (1 - enabled, 0 - disabled), the blocking writes to nvm are used in the design.</span></div><div class="line"><span class="comment">    * Otherwise, non-blocking nvm writes are used. From the user&#39;s perspective,</span></div><div class="line"><span class="comment">    * the behavior of blocking and non-blocking writes are the same - the difference is that</span></div><div class="line"><span class="comment">    * the non-blocking writes do not block the interrupts.</span></div><div class="line"><span class="comment">    Note</span></div><div class="line"><span class="comment">    Non-blocking nvm write is only supported by PSoC 6.</span></div><div class="line"><span class="comment">    */</span></div><div class="line"><span class="preprocessor">    #define BLOCKING_WRITE              (1u)</span></div><div class="line"></div><div class="line">    <span class="comment">/*The higher the factor is, the more nvm is used, but a higher number of erase/write cycles can be done on Em_EEPROM.</span></div><div class="line"><span class="comment">    * Multiply this number by the datasheet write endurance spec to determine the max of write cycles.</span></div><div class="line"><span class="comment">    * The amount of wear leveling from 1 to 10. 1 means no wear leveling is used.</span></div><div class="line"><span class="comment">    */</span></div><div class="line"><span class="preprocessor">    #define WEAR_LEVELLING_FACTOR       (2u)</span></div><div class="line"></div><div class="line">    <span class="comment">/*Simple mode, when enabled (1 - enabled, 0 - disabled),</span></div><div class="line"><span class="comment">    * means no additional service information is stored by the Em_EEPROM middleware</span></div><div class="line"><span class="comment">    * like checksums, headers, a number of writes, etc.</span></div><div class="line"><span class="comment">    */</span></div><div class="line"><span class="preprocessor">    #define SIMPLE_MODE                 (0u)</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">    #define EM_EEPROM_SIZE   ((TOTAL_CDAC_PARMS_SIZE % CY_EM_EEPROM_FLASH_SIZEOF_ROW) ? ((TOTAL_CDAC_PARMS_SIZE / CY_EM_EEPROM_FLASH_SIZEOF_ROW) + 1) * CY_EM_EEPROM_FLASH_SIZEOF_ROW  : (TOTAL_CDAC_PARMS_SIZE / CY_EM_EEPROM_FLASH_SIZEOF_ROW) *  CY_EM_EEPROM_FLASH_SIZEOF_ROW)</span></div><div class="line"><span class="preprocessor">    #define EM_EEPROM_PHYSICAL_SIZE     (CY_EM_EEPROM_GET_PHYSICAL_SIZE(EM_EEPROM_SIZE, SIMPLE_MODE, WEAR_LEVELLING_FACTOR, REDUNDANT_COPY))</span></div><div class="line"></div><div class="line">    cy_stc_eeprom_context_t em_eeprom_context;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> cy_stc_eeprom_config_t em_eeprom_config = { .eepromSize = EM_EEPROM_SIZE, <span class="comment">/* 256 bytes */</span></div><div class="line">    .blockingWrite = BLOCKING_WRITE, <span class="comment">/* Blocking writes enabled */</span></div><div class="line">    .redundantCopy = REDUNDANT_COPY, <span class="comment">/* Redundant copy enabled */</span></div><div class="line">    .wearLevelingFactor = WEAR_LEVELLING_FACTOR, <span class="comment">/* Wear levelling factor of 2 */</span></div><div class="line">    .simpleMode = SIMPLE_MODE, <span class="comment">/* Simple mode disabled */</span></div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">/* EEPROM storage Emulated EEPROM flash. */</span></div><div class="line">    CY_ALIGN( CY_EM_EEPROM_FLASH_SIZEOF_ROW)</div><div class="line">    <span class="keyword">const</span> uint8_t em_eeprom_storage[EM_EEPROM_PHYSICAL_SIZE] = { 0u };</div><div class="line"></div></div><!-- fragment --></li>
<li>Add EEPROM initialization: <div class="fragment"><div class="line">    cy_en_em_eeprom_status_t em_eeprom_status;</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize the flash start address in Emulated EEPROM configuration structure*/</span></div><div class="line">    em_eeprom_config.userFlashStartAddr = (uint32_t)em_eeprom_storage;</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize Emulated EEPROM */</span></div><div class="line">    em_eeprom_status = Cy_Em_EEPROM_Init(&amp;em_eeprom_config, &amp;em_eeprom_context);</div><div class="line"></div><div class="line">    <span class="comment">/* Emulated EEPROM init failed. Stop program execution */</span></div><div class="line">    <span class="keywordflow">if</span> (em_eeprom_status != CY_EM_EEPROM_SUCCESS)</div><div class="line">    {</div><div class="line">        CY_ASSERT(CY_ASSERT_FAILED);</div><div class="line">    }</div></div><!-- fragment --></li>
<li>Liquid level one-time calibration: <div class="fragment"><div class="line">    uint8_t *ptr_eeprom_data = 0;</div><div class="line">    uint32_t wd_id;</div><div class="line"></div><div class="line">    <a class="code" href="group__group__capsense__high__level.html#ga19b3aa9e14a04b76188f917c0dc004f5">Cy_CapSense_Init</a>(&amp;cy_capsense_context);</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize interrupt */</span></div><div class="line">    Cy_SysInt_Init(&amp;CapSense_ISR_cfg, &amp;CapSense_InterruptHandler);</div><div class="line">    NVIC_ClearPendingIRQ(CapSense_ISR_cfg.intrSrc);</div><div class="line">    NVIC_EnableIRQ(CapSense_ISR_cfg.intrSrc);</div><div class="line"></div><div class="line">    <span class="comment">/* Read the factory calibrated values from EEPROM*/</span></div><div class="line">    Cy_Em_EEPROM_Read(LOGICAL_EM_EEPROM_START, eeprom_data,</div><div class="line">    LOGICAL_EM_EEPROM_SIZE, &amp;em_eeprom_context);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (wd_id = 0u; wd_id &lt; CY_CAPSENSE_WIDGET_COUNT; wd_id++)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Get the EEPROM pointer location of the widget*/</span></div><div class="line">        ptr_eeprom_data = &amp;eeprom_data[get_eeprom_buffer_position(wd_id)];</div><div class="line"></div><div class="line">        <span class="comment">/* Set the status flag to ready state before writing into EEPROM.*/</span></div><div class="line">        <a class="code" href="group__group__capsense__low__level.html#ga2b6d787bf68eea9a889d8c7eec40af78">Cy_CapSense_SetWidgetCalibrationState</a>(wd_id,</div><div class="line">        ptr_eeprom_data[EEPROM_STATE_OFFSET], &amp;cy_capsense_context);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (<a class="code" href="group__group__capsense__low__level.html#ga3b8f58a0d6db406bca0c7caf94379854">Cy_CapSense_IsLlwCalibrationValid</a>(wd_id, &amp;cy_capsense_context) &amp;&amp;</div><div class="line">            (EEPROM_VALID == ptr_eeprom_data[EEPROM_STATE_OFFSET]))</div><div class="line">        {</div><div class="line">            <span class="comment">/* Update CDAC parameters with the factory calibrated values read from EEPROM */</span></div><div class="line">            <a class="code" href="group__group__capsense__low__level.html#ga95c9816b8cb62a2c555ee3398558cf38">Cy_CapSense_WriteWidgetCdacParam</a>(&amp;ptr_eeprom_data[EEPROM_DATA_OFFSET], wd_id,</div><div class="line">                    &amp;cy_capsense_context);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize the CAPSENSE firmware modules. This will skip the calibration of the LLS widget */</span></div><div class="line">    status = <a class="code" href="group__group__capsense__high__level.html#gade28f1f915ce6b97f13399074a819c0d">Cy_CapSense_Enable</a>(&amp;cy_capsense_context);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (wd_id = 0u; wd_id &lt; CY_CAPSENSE_WIDGET_COUNT; wd_id++)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Get the EEPROM pointer location of the widget*/</span></div><div class="line">        ptr_eeprom_data = &amp;eeprom_data[get_eeprom_buffer_position(wd_id)];</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (<a class="code" href="group__group__capsense__low__level.html#ga3b8f58a0d6db406bca0c7caf94379854">Cy_CapSense_IsLlwCalibrationValid</a>(wd_id, &amp;cy_capsense_context) &amp;&amp;</div><div class="line">            (0u == ptr_eeprom_data[EEPROM_STATE_OFFSET]))</div><div class="line">        {</div><div class="line">            <span class="comment">/* Reads the calibrated values from context to eeprom buffer*/</span></div><div class="line">            <a class="code" href="group__group__capsense__low__level.html#ga9282e8184026228ec7b8e1cf22829e55">Cy_CapSense_ReadWidgetCdacParam</a>(&amp;ptr_eeprom_data[EEPROM_DATA_OFFSET], wd_id,</div><div class="line">                    &amp;cy_capsense_context);</div><div class="line"></div><div class="line">            <span class="comment">/* Set the status flag to valid before writing into EEPROM*/</span></div><div class="line">            ptr_eeprom_data[EEPROM_STATE_OFFSET] = EEPROM_VALID; </div><div class="line"></div><div class="line">            <span class="comment">/* Update the local calibration status flag */</span></div><div class="line">            <a class="code" href="group__group__capsense__low__level.html#ga2b6d787bf68eea9a889d8c7eec40af78">Cy_CapSense_SetWidgetCalibrationState</a>(wd_id,</div><div class="line">            ptr_eeprom_data[EEPROM_STATE_OFFSET], &amp;cy_capsense_context);</div><div class="line"></div><div class="line">            <span class="comment">/* Write the factory calibrated values to EEPROM*/</span></div><div class="line">            Cy_Em_EEPROM_Write(LOGICAL_EM_EEPROM_START, eeprom_data,</div><div class="line">            LOGICAL_EM_EEPROM_SIZE, &amp;em_eeprom_context);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div></div><!-- fragment --></li>
<li>Add API to get buffer posiiton in EEPROM: <div class="fragment"><div class="line"><span class="keyword">static</span> uint32_t get_eeprom_buffer_position(uint32_t wd_id)</div><div class="line">{</div><div class="line">    uint32_t wd_index;</div><div class="line">    uint32_t ptr_index = 0;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (wd_index = 0u; wd_index &lt; wd_id; wd_index++)</div><div class="line">    {</div><div class="line">        ptr_index += (WD_CDAC_PARMS_SIZE</div><div class="line">                + cy_capsense_context.ptrWdConfig[wd_index].numSns);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> ptr_index;</div><div class="line">}</div></div><!-- fragment --></li>
</ol>

</div>
</div>
<a id="ga3b8f58a0d6db406bca0c7caf94379854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b8f58a0d6db406bca0c7caf94379854">&#9670;&nbsp;</a></span>Cy_CapSense_IsLlwCalibrationValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Cy_CapSense_IsLlwCalibrationValid </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>widgetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the status of the liquid level calibration the widget, by validating the one-time calibration and the liquid level calibration states. </p>
<dl class="section note"><dt>Note</dt><dd>This function is available only for the fifth-generation low power CAPSENSE&trade;.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">widgetId</td><td>Specifies the ID number of the widget. A macro for the widget ID can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;WIDGET_NAME&gt;_WDGT_ID.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the calibration.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd></dd></dl>
<p>The function is used for one-time calibration. Full example:</p>
<ol type="1">
<li>Add EEPROM configuration: <div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">    #define CY_ASSERT_FAILED                (0u)</span></div><div class="line">    </div><div class="line">    <span class="comment">/* Emulated EEPROM Configuration details. All the sizes mentioned are in bytes.</span></div><div class="line"><span class="comment">    * For details on how to configure these values refer to cy_em_eeprom.h. The</span></div><div class="line"><span class="comment">    * middleware documentation is provided in Emulated EEPROM API Reference Manual.</span></div><div class="line"><span class="comment">    * The user can access it from the Documentation section in the Quick Panel.</span></div><div class="line"><span class="comment">    */</span></div><div class="line"><span class="preprocessor">    #define WD_CDAC_PARMS_SIZE              (1u+ 1u +1u +2u) // Status+CRef+CFine+CComp_div</span></div><div class="line"><span class="preprocessor">    #define TOTAL_WD_CDAC_PARMS_SIZE        (CY_CAPSENSE_TOTAL_WIDGET_COUNT * WD_CDAC_PARMS_SIZE)</span></div><div class="line"><span class="preprocessor">    #define SNS_CDAC_PARMS_SIZE             (CY_CAPSENSE_SENSOR_COUNT * 1u) // CComp</span></div><div class="line"><span class="preprocessor">    #define TOTAL_CDAC_PARMS_SIZE           (TOTAL_WD_CDAC_PARMS_SIZE + SNS_CDAC_PARMS_SIZE)</span></div><div class="line"></div><div class="line">    <span class="comment">/* Logical Size of Emulated EEPROM in bytes */</span></div><div class="line"><span class="preprocessor">    #define LOGICAL_EM_EEPROM_SIZE          TOTAL_CDAC_PARMS_SIZE</span></div><div class="line"><span class="preprocessor">    #define LOGICAL_EM_EEPROM_START         (0u)</span></div><div class="line"></div><div class="line"><span class="preprocessor">    #define EEPROM_VALID                    (1u)</span></div><div class="line"><span class="preprocessor">    #define EEPROM_STATE_OFFSET             (0u)</span></div><div class="line"><span class="preprocessor">    #define EEPROM_DATA_OFFSET              (1u)</span></div><div class="line"></div><div class="line">    cy_stc_eeprom_context_t em_eeprom_context;</div><div class="line">    uint8_t eeprom_data[LOGICAL_EM_EEPROM_SIZE];</div><div class="line"></div><div class="line">    <span class="comment">/*If enabled (1 - enabled, 0 - disabled), a checksum (stored in a row) is calculated on each row of data,</span></div><div class="line"><span class="comment">    * while a redundant copy of Em_EEPROM is stored in another location.</span></div><div class="line"><span class="comment">    * When data is read, first the checksum is checked. If that checksum is bad,</span></div><div class="line"><span class="comment">    and the redundant copy&#39;s checksum is good, the copy is restored.</span></div><div class="line"><span class="comment">    */</span></div><div class="line"><span class="preprocessor">    #define REDUNDANT_COPY              (1u)</span></div><div class="line"></div><div class="line">    <span class="comment">/*If enabled (1 - enabled, 0 - disabled), the blocking writes to nvm are used in the design.</span></div><div class="line"><span class="comment">    * Otherwise, non-blocking nvm writes are used. From the user&#39;s perspective,</span></div><div class="line"><span class="comment">    * the behavior of blocking and non-blocking writes are the same - the difference is that</span></div><div class="line"><span class="comment">    * the non-blocking writes do not block the interrupts.</span></div><div class="line"><span class="comment">    Note</span></div><div class="line"><span class="comment">    Non-blocking nvm write is only supported by PSoC 6.</span></div><div class="line"><span class="comment">    */</span></div><div class="line"><span class="preprocessor">    #define BLOCKING_WRITE              (1u)</span></div><div class="line"></div><div class="line">    <span class="comment">/*The higher the factor is, the more nvm is used, but a higher number of erase/write cycles can be done on Em_EEPROM.</span></div><div class="line"><span class="comment">    * Multiply this number by the datasheet write endurance spec to determine the max of write cycles.</span></div><div class="line"><span class="comment">    * The amount of wear leveling from 1 to 10. 1 means no wear leveling is used.</span></div><div class="line"><span class="comment">    */</span></div><div class="line"><span class="preprocessor">    #define WEAR_LEVELLING_FACTOR       (2u)</span></div><div class="line"></div><div class="line">    <span class="comment">/*Simple mode, when enabled (1 - enabled, 0 - disabled),</span></div><div class="line"><span class="comment">    * means no additional service information is stored by the Em_EEPROM middleware</span></div><div class="line"><span class="comment">    * like checksums, headers, a number of writes, etc.</span></div><div class="line"><span class="comment">    */</span></div><div class="line"><span class="preprocessor">    #define SIMPLE_MODE                 (0u)</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">    #define EM_EEPROM_SIZE   ((TOTAL_CDAC_PARMS_SIZE % CY_EM_EEPROM_FLASH_SIZEOF_ROW) ? ((TOTAL_CDAC_PARMS_SIZE / CY_EM_EEPROM_FLASH_SIZEOF_ROW) + 1) * CY_EM_EEPROM_FLASH_SIZEOF_ROW  : (TOTAL_CDAC_PARMS_SIZE / CY_EM_EEPROM_FLASH_SIZEOF_ROW) *  CY_EM_EEPROM_FLASH_SIZEOF_ROW)</span></div><div class="line"><span class="preprocessor">    #define EM_EEPROM_PHYSICAL_SIZE     (CY_EM_EEPROM_GET_PHYSICAL_SIZE(EM_EEPROM_SIZE, SIMPLE_MODE, WEAR_LEVELLING_FACTOR, REDUNDANT_COPY))</span></div><div class="line"></div><div class="line">    cy_stc_eeprom_context_t em_eeprom_context;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> cy_stc_eeprom_config_t em_eeprom_config = { .eepromSize = EM_EEPROM_SIZE, <span class="comment">/* 256 bytes */</span></div><div class="line">    .blockingWrite = BLOCKING_WRITE, <span class="comment">/* Blocking writes enabled */</span></div><div class="line">    .redundantCopy = REDUNDANT_COPY, <span class="comment">/* Redundant copy enabled */</span></div><div class="line">    .wearLevelingFactor = WEAR_LEVELLING_FACTOR, <span class="comment">/* Wear levelling factor of 2 */</span></div><div class="line">    .simpleMode = SIMPLE_MODE, <span class="comment">/* Simple mode disabled */</span></div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">/* EEPROM storage Emulated EEPROM flash. */</span></div><div class="line">    CY_ALIGN( CY_EM_EEPROM_FLASH_SIZEOF_ROW)</div><div class="line">    <span class="keyword">const</span> uint8_t em_eeprom_storage[EM_EEPROM_PHYSICAL_SIZE] = { 0u };</div><div class="line"></div></div><!-- fragment --></li>
<li>Add EEPROM initialization: <div class="fragment"><div class="line">    cy_en_em_eeprom_status_t em_eeprom_status;</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize the flash start address in Emulated EEPROM configuration structure*/</span></div><div class="line">    em_eeprom_config.userFlashStartAddr = (uint32_t)em_eeprom_storage;</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize Emulated EEPROM */</span></div><div class="line">    em_eeprom_status = Cy_Em_EEPROM_Init(&amp;em_eeprom_config, &amp;em_eeprom_context);</div><div class="line"></div><div class="line">    <span class="comment">/* Emulated EEPROM init failed. Stop program execution */</span></div><div class="line">    <span class="keywordflow">if</span> (em_eeprom_status != CY_EM_EEPROM_SUCCESS)</div><div class="line">    {</div><div class="line">        CY_ASSERT(CY_ASSERT_FAILED);</div><div class="line">    }</div></div><!-- fragment --></li>
<li>Liquid level one-time calibration: <div class="fragment"><div class="line">    uint8_t *ptr_eeprom_data = 0;</div><div class="line">    uint32_t wd_id;</div><div class="line"></div><div class="line">    <a class="code" href="group__group__capsense__high__level.html#ga19b3aa9e14a04b76188f917c0dc004f5">Cy_CapSense_Init</a>(&amp;cy_capsense_context);</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize interrupt */</span></div><div class="line">    Cy_SysInt_Init(&amp;CapSense_ISR_cfg, &amp;CapSense_InterruptHandler);</div><div class="line">    NVIC_ClearPendingIRQ(CapSense_ISR_cfg.intrSrc);</div><div class="line">    NVIC_EnableIRQ(CapSense_ISR_cfg.intrSrc);</div><div class="line"></div><div class="line">    <span class="comment">/* Read the factory calibrated values from EEPROM*/</span></div><div class="line">    Cy_Em_EEPROM_Read(LOGICAL_EM_EEPROM_START, eeprom_data,</div><div class="line">    LOGICAL_EM_EEPROM_SIZE, &amp;em_eeprom_context);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (wd_id = 0u; wd_id &lt; CY_CAPSENSE_WIDGET_COUNT; wd_id++)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Get the EEPROM pointer location of the widget*/</span></div><div class="line">        ptr_eeprom_data = &amp;eeprom_data[get_eeprom_buffer_position(wd_id)];</div><div class="line"></div><div class="line">        <span class="comment">/* Set the status flag to ready state before writing into EEPROM.*/</span></div><div class="line">        <a class="code" href="group__group__capsense__low__level.html#ga2b6d787bf68eea9a889d8c7eec40af78">Cy_CapSense_SetWidgetCalibrationState</a>(wd_id,</div><div class="line">        ptr_eeprom_data[EEPROM_STATE_OFFSET], &amp;cy_capsense_context);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (<a class="code" href="group__group__capsense__low__level.html#ga3b8f58a0d6db406bca0c7caf94379854">Cy_CapSense_IsLlwCalibrationValid</a>(wd_id, &amp;cy_capsense_context) &amp;&amp;</div><div class="line">            (EEPROM_VALID == ptr_eeprom_data[EEPROM_STATE_OFFSET]))</div><div class="line">        {</div><div class="line">            <span class="comment">/* Update CDAC parameters with the factory calibrated values read from EEPROM */</span></div><div class="line">            <a class="code" href="group__group__capsense__low__level.html#ga95c9816b8cb62a2c555ee3398558cf38">Cy_CapSense_WriteWidgetCdacParam</a>(&amp;ptr_eeprom_data[EEPROM_DATA_OFFSET], wd_id,</div><div class="line">                    &amp;cy_capsense_context);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize the CAPSENSE firmware modules. This will skip the calibration of the LLS widget */</span></div><div class="line">    status = <a class="code" href="group__group__capsense__high__level.html#gade28f1f915ce6b97f13399074a819c0d">Cy_CapSense_Enable</a>(&amp;cy_capsense_context);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (wd_id = 0u; wd_id &lt; CY_CAPSENSE_WIDGET_COUNT; wd_id++)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Get the EEPROM pointer location of the widget*/</span></div><div class="line">        ptr_eeprom_data = &amp;eeprom_data[get_eeprom_buffer_position(wd_id)];</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (<a class="code" href="group__group__capsense__low__level.html#ga3b8f58a0d6db406bca0c7caf94379854">Cy_CapSense_IsLlwCalibrationValid</a>(wd_id, &amp;cy_capsense_context) &amp;&amp;</div><div class="line">            (0u == ptr_eeprom_data[EEPROM_STATE_OFFSET]))</div><div class="line">        {</div><div class="line">            <span class="comment">/* Reads the calibrated values from context to eeprom buffer*/</span></div><div class="line">            <a class="code" href="group__group__capsense__low__level.html#ga9282e8184026228ec7b8e1cf22829e55">Cy_CapSense_ReadWidgetCdacParam</a>(&amp;ptr_eeprom_data[EEPROM_DATA_OFFSET], wd_id,</div><div class="line">                    &amp;cy_capsense_context);</div><div class="line"></div><div class="line">            <span class="comment">/* Set the status flag to valid before writing into EEPROM*/</span></div><div class="line">            ptr_eeprom_data[EEPROM_STATE_OFFSET] = EEPROM_VALID; </div><div class="line"></div><div class="line">            <span class="comment">/* Update the local calibration status flag */</span></div><div class="line">            <a class="code" href="group__group__capsense__low__level.html#ga2b6d787bf68eea9a889d8c7eec40af78">Cy_CapSense_SetWidgetCalibrationState</a>(wd_id,</div><div class="line">            ptr_eeprom_data[EEPROM_STATE_OFFSET], &amp;cy_capsense_context);</div><div class="line"></div><div class="line">            <span class="comment">/* Write the factory calibrated values to EEPROM*/</span></div><div class="line">            Cy_Em_EEPROM_Write(LOGICAL_EM_EEPROM_START, eeprom_data,</div><div class="line">            LOGICAL_EM_EEPROM_SIZE, &amp;em_eeprom_context);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div></div><!-- fragment --></li>
<li>Add API to get buffer posiiton in EEPROM: <div class="fragment"><div class="line"><span class="keyword">static</span> uint32_t get_eeprom_buffer_position(uint32_t wd_id)</div><div class="line">{</div><div class="line">    uint32_t wd_index;</div><div class="line">    uint32_t ptr_index = 0;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (wd_index = 0u; wd_index &lt; wd_id; wd_index++)</div><div class="line">    {</div><div class="line">        ptr_index += (WD_CDAC_PARMS_SIZE</div><div class="line">                + cy_capsense_context.ptrWdConfig[wd_index].numSns);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> ptr_index;</div><div class="line">}</div></div><!-- fragment --></li>
</ol>

</div>
</div>
<a id="gaa35b107fb94a8c8ff6d53463c62d0481"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa35b107fb94a8c8ff6d53463c62d0481">&#9670;&nbsp;</a></span>Cy_CapSense_InitializeAllBaselines()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_InitializeAllBaselines </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the baselines of all the sensors of all active widgets. </p>
<p>This function initializes baselines for all sensors and widgets in the project skipping low power widgets since their baselines are managed on HW level. It can also be used to re-initialize baselines at any time, however, note that all sensor data history information and sensor status shall be reset along with re-initialization of baseline.</p>
<p>Following functions to initialize sensor and widgets and filter history should be called after initializing baseline for proper operation of the CAPSENSE&trade; middleware:</p><ul>
<li><a class="el" href="group__group__capsense__low__level.html#ga91d3ccdc21ed235f4e3b61a0a583c7a1" title="Performs initialization of all statuses and related modules including debounce counters and touch pos...">Cy_CapSense_InitializeAllStatuses()</a></li>
<li><a class="el" href="group__group__capsense__low__level.html#ga1fcb002d0216bb96ab818276954606e7" title="Initializes (or re-initializes) all the firmware filter history, except the baseline. ">Cy_CapSense_InitializeAllFilters()</a></li>
</ul>
<p>These functions are called by the CapSense_Enable() function, hence it is not required to use this function if above function is used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the operation:<ul>
<li>CY_CAPSENSE_STATUS_SUCCESS - The operation is performed successfully.</li>
<li>CY_CAPSENSE_STATUS_BAD_PARAM - The input parameter is invalid. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga6dd0e7c6db3f269948623d2e0fa0c2d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6dd0e7c6db3f269948623d2e0fa0c2d7">&#9670;&nbsp;</a></span>Cy_CapSense_InitializeWidgetBaseline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_InitializeWidgetBaseline </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>widgetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the baselines of all the sensors in a specific widget. </p>
<p>This function initializes baselines for all sensors in a specific widget in the project. It can also be used to re-initialize baselines at any time, however, note that all sensor data history information and sensor status should be reset along with re-initialization of baseline.</p>
<p>The following functions to initialize sensor and widgets and filter history should be called after initializing baselines for proper operation of middleware.</p><ul>
<li><a class="el" href="group__group__capsense__low__level.html#ga0cd8087cced318d7a2ddd0aabe5d0b65" title="Performs initialization of all statuses, debounce counters, and touch positions of the specified widg...">Cy_CapSense_InitializeWidgetStatus()</a></li>
<li><a class="el" href="group__group__capsense__low__level.html#ga101174469c4b6a2df8d44bddb0e33fcf" title="Initializes (or re-initializes) the raw count filter history of all the sensors in a widget specified...">Cy_CapSense_InitializeWidgetFilter()</a></li>
</ul>
<p>These functions are called by CapSense_Enable() function, hence it is not required to use this function is above function is used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">widgetId</td><td>Specifies the ID number of the widget. A macro for the widget ID can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;WIDGET_NAME&gt;_WDGT_ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>For the fifth-generation low power CAPSENSE&trade; widgets of the <a class="el" href="group__group__capsense__enums.html#gga855d894b24929f0d7d2774dfc4266d60aef4c95b7c358505b7e5b110dfc26a97e">CY_CAPSENSE_WD_LOW_POWER_E</a> type are not processed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the operation:<ul>
<li>CY_CAPSENSE_STATUS_SUCCESS - The operation is performed successfully.</li>
<li>CY_CAPSENSE_STATUS_BAD_PARAM - The input parameter is invalid. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga723aa8ba790fcc07ca42611aba99fb88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga723aa8ba790fcc07ca42611aba99fb88">&#9670;&nbsp;</a></span>Cy_CapSense_InitializeSensorBaseline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_InitializeSensorBaseline </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>widgetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sensorId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the baseline of a sensor in a widget specified by the input parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">widgetId</td><td>Specifies the ID number of the widget. A macro for the widget ID can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;WIDGET_NAME&gt;_WDGT_ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>For the fifth-generation low power CAPSENSE&trade; it is forbidden to call this function for widgets of the <a class="el" href="group__group__capsense__enums.html#gga855d894b24929f0d7d2774dfc4266d60aef4c95b7c358505b7e5b110dfc26a97e">CY_CAPSENSE_WD_LOW_POWER_E</a> type since behavior is unpredictable.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sensorId</td><td>Specifies the ID number of the sensor within the widget. A macro for the sensor ID within a specified widget can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;WIDGET_NAME&gt;_SNS&lt;SENSOR_NUMBER&gt;_ID.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the operation:<ul>
<li>CY_CAPSENSE_STATUS_SUCCESS - The operation is performed successfully.</li>
<li>CY_CAPSENSE_STATUS_BAD_PARAM - The input parameter is invalid. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga1fcb002d0216bb96ab818276954606e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1fcb002d0216bb96ab818276954606e7">&#9670;&nbsp;</a></span>Cy_CapSense_InitializeAllFilters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_CapSense_InitializeAllFilters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes (or re-initializes) all the firmware filter history, except the baseline. </p>
<p>Calling this function is accompanied by</p><ul>
<li><a class="el" href="group__group__capsense__low__level.html#ga91d3ccdc21ed235f4e3b61a0a583c7a1" title="Performs initialization of all statuses and related modules including debounce counters and touch pos...">Cy_CapSense_InitializeAllStatuses()</a></li>
<li><a class="el" href="group__group__capsense__low__level.html#gaa35b107fb94a8c8ff6d53463c62d0481" title="Initializes the baselines of all the sensors of all active widgets. ">Cy_CapSense_InitializeAllBaselines()</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga101174469c4b6a2df8d44bddb0e33fcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga101174469c4b6a2df8d44bddb0e33fcf">&#9670;&nbsp;</a></span>Cy_CapSense_InitializeWidgetFilter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_CapSense_InitializeWidgetFilter </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>widgetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes (or re-initializes) the raw count filter history of all the sensors in a widget specified by the input parameter. </p>
<p>Calling this function is accompanied by</p><ul>
<li><a class="el" href="group__group__capsense__low__level.html#ga0cd8087cced318d7a2ddd0aabe5d0b65" title="Performs initialization of all statuses, debounce counters, and touch positions of the specified widg...">Cy_CapSense_InitializeWidgetStatus()</a>.</li>
<li><a class="el" href="group__group__capsense__low__level.html#ga6dd0e7c6db3f269948623d2e0fa0c2d7" title="Initializes the baselines of all the sensors in a specific widget. ">Cy_CapSense_InitializeWidgetBaseline()</a>.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">widgetId</td><td>Specifies the ID number of the widget. A macro for the widget ID can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;WIDGET_NAME&gt;_WDGT_ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>For the fifth-generation low power CAPSENSE&trade; widgets of the <a class="el" href="group__group__capsense__enums.html#gga855d894b24929f0d7d2774dfc4266d60aef4c95b7c358505b7e5b110dfc26a97e">CY_CAPSENSE_WD_LOW_POWER_E</a> type are not processed since their filters are managed by HW.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga76d2e232d2e5247954a15a45de62d235"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76d2e232d2e5247954a15a45de62d235">&#9670;&nbsp;</a></span>Cy_CapSense_UpdateAllBaselines()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_UpdateAllBaselines </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the baseline for all the sensors in all the active widgets (skipping low power widgets). </p>
<p>Baselines must be updated after sensor scan to ignore low frequency changes in the sensor data caused by environment changes such as temperature from sensor status decision.</p>
<p>This function ignores the widget enable bit in the widget status register. Calling this function multiple times without a new sensor scan leads to unexpected behavior and should be avoided.</p>
<p>This function is called by <a class="el" href="group__group__capsense__high__level.html#ga2a185db228d5cae975fbc92bd3bc6367" title="Performs full data processing of all enabled widgets. ">Cy_CapSense_ProcessAllWidgets()</a> and <a class="el" href="group__group__capsense__high__level.html#ga52874ea98333723ec92aef1bb4791a7d" title="Performs full data processing of the specified widget if it is enabled. ">Cy_CapSense_ProcessWidget()</a>, hence the application program need not use this function if any of the above functions is already used. This function can be used for custom application implementation.</p>
<dl class="section note"><dt>Note</dt><dd>For the fifth-generation low power CAPSENSE&trade; widgets of the <a class="el" href="group__group__capsense__enums.html#gga855d894b24929f0d7d2774dfc4266d60aef4c95b7c358505b7e5b110dfc26a97e">CY_CAPSENSE_WD_LOW_POWER_E</a> type are not processed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the update baseline operation of all the widgets:<ul>
<li>CY_CAPSENSE_STATUS_SUCCESS - The operation is successfully completed.</li>
<li>CY_CAPSENSE_STATUS_BAD_DATA - The baseline processing failed. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga53420b198a6de128b82b3edb31f250c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53420b198a6de128b82b3edb31f250c6">&#9670;&nbsp;</a></span>Cy_CapSense_UpdateWidgetBaseline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_UpdateWidgetBaseline </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>widgetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the baselines for all the sensors in a widget specified by the input parameter. </p>
<p>This function performs exactly the same tasks as <a class="el" href="group__group__capsense__low__level.html#ga76d2e232d2e5247954a15a45de62d235" title="Updates the baseline for all the sensors in all the active widgets (skipping low power widgets)...">Cy_CapSense_UpdateAllBaselines()</a> but only for a specified widget.</p>
<p>Calling this function multiple times without a new sensor scan leads to unexpected behavior and should be avoided. The application program need not use this function if the <a class="el" href="group__group__capsense__low__level.html#ga76d2e232d2e5247954a15a45de62d235" title="Updates the baseline for all the sensors in all the active widgets (skipping low power widgets)...">Cy_CapSense_UpdateAllBaselines()</a>, <a class="el" href="group__group__capsense__high__level.html#ga2a185db228d5cae975fbc92bd3bc6367" title="Performs full data processing of all enabled widgets. ">Cy_CapSense_ProcessAllWidgets()</a> or <a class="el" href="group__group__capsense__high__level.html#ga52874ea98333723ec92aef1bb4791a7d" title="Performs full data processing of the specified widget if it is enabled. ">Cy_CapSense_ProcessWidget()</a> functions are already used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">widgetId</td><td>Specifies the ID number of the widget. A macro for the widget ID can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;WIDGET_NAME&gt;_WDGT_ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>For the fifth-generation low power CAPSENSE&trade; widgets of the <a class="el" href="group__group__capsense__enums.html#gga855d894b24929f0d7d2774dfc4266d60aef4c95b7c358505b7e5b110dfc26a97e">CY_CAPSENSE_WD_LOW_POWER_E</a> type are not processed and <a class="el" href="group__group__capsense__macros__status.html#ga8497b8b090398be7d1550d31946c6013">CY_CAPSENSE_STATUS_BAD_PARAM</a> is returned if a widget of this type is passed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the specified widget update baseline operation:<ul>
<li>CY_CAPSENSE_STATUS_SUCCESS - The operation is successfully completed.</li>
<li>CY_CAPSENSE_STATUS_BAD_PARAM - The input parameter is invalid.</li>
<li>CY_CAPSENSE_STATUS_BAD_DATA - The baseline processing failed. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga4d2ceb23fa0e3731878ad777f39474d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d2ceb23fa0e3731878ad777f39474d2">&#9670;&nbsp;</a></span>Cy_CapSense_UpdateSensorBaseline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_UpdateSensorBaseline </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>widgetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sensorId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the baseline for a sensor in a widget specified by the input parameters. </p>
<p>This function performs exactly the same tasks as <a class="el" href="group__group__capsense__low__level.html#ga76d2e232d2e5247954a15a45de62d235" title="Updates the baseline for all the sensors in all the active widgets (skipping low power widgets)...">Cy_CapSense_UpdateAllBaselines()</a> and <a class="el" href="group__group__capsense__low__level.html#ga53420b198a6de128b82b3edb31f250c6" title="Updates the baselines for all the sensors in a widget specified by the input parameter. ">Cy_CapSense_UpdateWidgetBaseline()</a> but only for a specified sensor.</p>
<p>Calling this function multiple times without a new sensor scan leads to unexpected behavior and should be avoided. The application need not use this function if the Cy_CapSense_UpdateWidgetBaseline (), Cy_CapSense_UpdateAllBaselines (), <a class="el" href="group__group__capsense__high__level.html#ga2a185db228d5cae975fbc92bd3bc6367" title="Performs full data processing of all enabled widgets. ">Cy_CapSense_ProcessAllWidgets()</a>, or <a class="el" href="group__group__capsense__high__level.html#ga52874ea98333723ec92aef1bb4791a7d" title="Performs full data processing of the specified widget if it is enabled. ">Cy_CapSense_ProcessWidget()</a> functions are already used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">widgetId</td><td>Specifies the ID number of the widget. A macro for the widget ID can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;WIDGET_NAME&gt;_WDGT_ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>For the fifth-generation low power CAPSENSE&trade; it is not recommended to call this function for widgets of the <a class="el" href="group__group__capsense__enums.html#gga855d894b24929f0d7d2774dfc4266d60aef4c95b7c358505b7e5b110dfc26a97e">CY_CAPSENSE_WD_LOW_POWER_E</a> type.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sensorId</td><td>Specifies the ID number of the sensor within the widget. A macro for the sensor ID within a specified widget can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;WIDGET_NAME&gt;_SNS&lt;SENSOR_NUMBER&gt;_ID.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the specified sensor update baseline operation:<ul>
<li>CY_CAPSENSE_STATUS_SUCCESS - The operation is successfully completed.</li>
<li>CY_CAPSENSE_STATUS_BAD_PARAM - The input parameter is invalid.</li>
<li>CY_CAPSENSE_STATUS_BAD_DATA - The baseline processing failed. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga1a42bc8b8c045d4c4fa3ea9b4411c247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a42bc8b8c045d4c4fa3ea9b4411c247">&#9670;&nbsp;</a></span>Cy_CapSense_InitializeWidgetGestures()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_CapSense_InitializeWidgetGestures </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>widgetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs initialization of all gestures for the specified widget. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">widgetId</td><td>Specifies the ID number of the widget. A macro for the widget ID can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;WIDGET_NAME&gt;_WDGT_ID.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga91d3ccdc21ed235f4e3b61a0a583c7a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91d3ccdc21ed235f4e3b61a0a583c7a1">&#9670;&nbsp;</a></span>Cy_CapSense_InitializeAllStatuses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_CapSense_InitializeAllStatuses </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs initialization of all statuses and related modules including debounce counters and touch positions of all the widgets. </p>
<p>The initialization includes the following tasks:</p><ul>
<li>Reset the debounce counters of all the widgets.</li>
<li>Reset the number of touches.</li>
<li>Reset the position filter history for slider and touchpad widgets.</li>
<li>Clear all status of widgets and sensors.</li>
<li>Enable all the widgets.</li>
</ul>
<p>Calling this function is accompanied by</p><ul>
<li><a class="el" href="group__group__capsense__low__level.html#gaa35b107fb94a8c8ff6d53463c62d0481" title="Initializes the baselines of all the sensors of all active widgets. ">Cy_CapSense_InitializeAllBaselines()</a>.</li>
<li><a class="el" href="group__group__capsense__low__level.html#ga1fcb002d0216bb96ab818276954606e7" title="Initializes (or re-initializes) all the firmware filter history, except the baseline. ">Cy_CapSense_InitializeAllFilters()</a>.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0cd8087cced318d7a2ddd0aabe5d0b65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0cd8087cced318d7a2ddd0aabe5d0b65">&#9670;&nbsp;</a></span>Cy_CapSense_InitializeWidgetStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_CapSense_InitializeWidgetStatus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>widgetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs initialization of all statuses, debounce counters, and touch positions of the specified widget. </p>
<p>The initialization includes:</p><ul>
<li>Resets the debounce counter of the widget.</li>
<li>Resets the number of touches.</li>
<li>Resets the position filter history for slider and touchpad widgets.</li>
<li>Clears widget and sensor statuses.</li>
<li>Enables the widget.</li>
</ul>
<p>The Button and Matrix Button widgets have individual debounce counters per sensor for the CSD widgets and per node for the CSX and ISX widgets.</p>
<p>The Slider and Touchpad widgets have a single debounce counter per widget.</p>
<p>The Proximity widget has two debounce counters per sensor. One is for the proximity event and the second is for the touch event.</p>
<p>All debounce counters during initialization are set to the value of the onDebounce widget parameter.</p>
<p>Calling this function is accompanied by</p><ul>
<li><a class="el" href="group__group__capsense__low__level.html#ga6dd0e7c6db3f269948623d2e0fa0c2d7" title="Initializes the baselines of all the sensors in a specific widget. ">Cy_CapSense_InitializeWidgetBaseline()</a>.</li>
<li><a class="el" href="group__group__capsense__low__level.html#ga101174469c4b6a2df8d44bddb0e33fcf" title="Initializes (or re-initializes) the raw count filter history of all the sensors in a widget specified...">Cy_CapSense_InitializeWidgetFilter()</a>.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">widgetId</td><td>Specifies the ID number of the widget. A macro for the widget ID can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;WIDGET_NAME&gt;_WDGT_ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>For the fifth-generation low power CAPSENSE&trade; widgets of the <a class="el" href="group__group__capsense__enums.html#gga855d894b24929f0d7d2774dfc4266d60aef4c95b7c358505b7e5b110dfc26a97e">CY_CAPSENSE_WD_LOW_POWER_E</a> type are not processed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1460eefc048d987a811dbb7deba56e0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1460eefc048d987a811dbb7deba56e0f">&#9670;&nbsp;</a></span>Cy_CapSense_ProcessWidgetMpDeconvolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_ProcessWidgetMpDeconvolution </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>widgetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs raw count deconvolution for the specified widget: </p>
<ul>
<li>CSD - when multi-phase Self is enabled</li>
<li>CSX - when multi-phase Tx is enabled</li>
</ul>
<p>This function decodes raw counts received after scanning into normal view by performing deconvolution algorithm. If the function is called for a widget with disabled multi-phase, the function returns CY_CAPSENSE_STATUS_BAD_DATA.</p>
<p>No need to call this function from application layer since the <a class="el" href="group__group__capsense__high__level.html#ga2a185db228d5cae975fbc92bd3bc6367" title="Performs full data processing of all enabled widgets. ">Cy_CapSense_ProcessAllWidgets()</a> and <a class="el" href="group__group__capsense__high__level.html#ga52874ea98333723ec92aef1bb4791a7d" title="Performs full data processing of the specified widget if it is enabled. ">Cy_CapSense_ProcessWidget()</a> functions calls deconvolution automatically.</p>
<p>DAC auto-calibration when enabled performs sensor auto-calibration without performing deconvolution. For the CSX widgets, the deconvolution algorithm for even number of TX electrodes decreases raw count level twice (keeping the signal on the same level).</p>
<p>If specific processing is implemented using the <a class="el" href="group__group__capsense__low__level.html#gafbfe743a98bd2c24a623a2c734c03f0e" title="Performs customized data processing on the selected widget. ">Cy_CapSense_ProcessWidgetExt()</a> and <a class="el" href="group__group__capsense__low__level.html#ga05d3f6e7d7fbef845ab4eb575e653dec" title="Performs customized data processing on the selected sensor. ">Cy_CapSense_ProcessSensorExt()</a> function then a call of this function is required prior doing the specific processing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">widgetId</td><td>Specifies the ID number of the widget.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the processing operation. </dd></dl>

</div>
</div>
<a id="gaf58d5ee3d30799c52819dccecad6730b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf58d5ee3d30799c52819dccecad6730b">&#9670;&nbsp;</a></span>Cy_CapSense_PreProcessSensor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_CapSense_PreProcessSensor </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>widgetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sensorId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the pre-processing of scan raw data for specified sensor. </p>
<p>This function is called prior any other processing function for the fifth CAPSENSE&trade; and fifth low power HW generation. The pre-processing routine implements the following operations:</p><ul>
<li>Limits raw count to maximum value.</li>
<li>Executes the raw data inversion for the CSX and ISX sensors.</li>
</ul>
<p>No need to call this function from application layer since the <a class="el" href="group__group__capsense__high__level.html#ga2a185db228d5cae975fbc92bd3bc6367" title="Performs full data processing of all enabled widgets. ">Cy_CapSense_ProcessAllWidgets()</a> and <a class="el" href="group__group__capsense__high__level.html#ga52874ea98333723ec92aef1bb4791a7d" title="Performs full data processing of the specified widget if it is enabled. ">Cy_CapSense_ProcessWidget()</a> functions calls it automatically.</p>
<p>If specific processing is implemented using the <a class="el" href="group__group__capsense__low__level.html#gafbfe743a98bd2c24a623a2c734c03f0e" title="Performs customized data processing on the selected widget. ">Cy_CapSense_ProcessWidgetExt()</a> and <a class="el" href="group__group__capsense__low__level.html#ga05d3f6e7d7fbef845ab4eb575e653dec" title="Performs customized data processing on the selected sensor. ">Cy_CapSense_ProcessSensorExt()</a> function then a call of this function is required prior doing the specific processing. If Multi-phase is enabled then deconvolution should be executed after pre-processing of all sensors of the specified widget using the <a class="el" href="group__group__capsense__low__level.html#ga1460eefc048d987a811dbb7deba56e0f" title="Performs raw count deconvolution for the specified widget: ">Cy_CapSense_ProcessWidgetMpDeconvolution()</a> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">widgetId</td><td>The widget ID, for which the pre-processing should be executed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>For the fifth-generation low power CAPSENSE&trade; widgets of the <a class="el" href="group__group__capsense__enums.html#gga855d894b24929f0d7d2774dfc4266d60aef4c95b7c358505b7e5b110dfc26a97e">CY_CAPSENSE_WD_LOW_POWER_E</a> type are not processed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sensorId</td><td>The sensor ID, for which the pre-processing should be executed.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad0772250c35cb3f630a8522b0b156692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0772250c35cb3f630a8522b0b156692">&#9670;&nbsp;</a></span>Cy_CapSense_PreProcessWidget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_CapSense_PreProcessWidget </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>widgetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the pre-processing of scan raw data for specified widgets. </p>
<p>This function is called prior any other processing function for the fifth CAPSENSE&trade; and fifth low power CAPSENSE&trade; HW generation. The pre-processing routine implements the following operations:</p><ul>
<li>Limits raw count to maximum value.</li>
<li>Executes the raw data inversion for the CSX ans ISX sensors.</li>
</ul>
<p>No need to call this function from application layer since the <a class="el" href="group__group__capsense__high__level.html#ga2a185db228d5cae975fbc92bd3bc6367" title="Performs full data processing of all enabled widgets. ">Cy_CapSense_ProcessAllWidgets()</a> and <a class="el" href="group__group__capsense__high__level.html#ga52874ea98333723ec92aef1bb4791a7d" title="Performs full data processing of the specified widget if it is enabled. ">Cy_CapSense_ProcessWidget()</a> functions calls it automatically.</p>
<p>If specific processing is implemented using the <a class="el" href="group__group__capsense__low__level.html#gafbfe743a98bd2c24a623a2c734c03f0e" title="Performs customized data processing on the selected widget. ">Cy_CapSense_ProcessWidgetExt()</a> and <a class="el" href="group__group__capsense__low__level.html#ga05d3f6e7d7fbef845ab4eb575e653dec" title="Performs customized data processing on the selected sensor. ">Cy_CapSense_ProcessSensorExt()</a> function then a call of this function is required prior doing the specific processing. If Multi-phase is enabled then deconvolution should be executed after call of this function using the <a class="el" href="group__group__capsense__low__level.html#ga1460eefc048d987a811dbb7deba56e0f" title="Performs raw count deconvolution for the specified widget: ">Cy_CapSense_ProcessWidgetMpDeconvolution()</a> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">widgetId</td><td>The widget ID, for which the pre-processing should be executed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>For the fifth-generation low power CAPSENSE&trade; widgets of the <a class="el" href="group__group__capsense__enums.html#gga855d894b24929f0d7d2774dfc4266d60aef4c95b7c358505b7e5b110dfc26a97e">CY_CAPSENSE_WD_LOW_POWER_E</a> type are not processed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0226119d718185acba8bfb8098682ec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0226119d718185acba8bfb8098682ec7">&#9670;&nbsp;</a></span>Cy_CapSense_RunMfsMedian()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_RunMfsMedian </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>widgetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies the median filter to the specified multi-frequency widget and updates the specified widget diff counts. </p>
<p>This function is a low-level function and is called automatically by high-level processing functions like <a class="el" href="group__group__capsense__high__level.html#ga52874ea98333723ec92aef1bb4791a7d" title="Performs full data processing of the specified widget if it is enabled. ">Cy_CapSense_ProcessWidget()</a> and <a class="el" href="group__group__capsense__high__level.html#ga2a185db228d5cae975fbc92bd3bc6367" title="Performs full data processing of all enabled widgets. ">Cy_CapSense_ProcessAllWidgets()</a>.</p>
<p>It is not recommended to use this function directly on application level.</p>
<p>The function applies the median filter to diff count of each sensor of the specified widget (with enabled multi-frequency feature) and update the diff count of the specified main widget.</p>
<p>This function is needed to implement customer-specific use cases.</p>
<dl class="section note"><dt>Note</dt><dd>This function is available for the fifth-generation CAPSENSE&trade; and fifth-generation low power CAPSENSE&trade;.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">widgetId</td><td>Specifies the ID number of the widget. A macro for the widget ID can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;WIDGET_NAME&gt;_WDGT_ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>For the fifth-generation low power CAPSENSE&trade; widgets of the <a class="el" href="group__group__capsense__enums.html#gga855d894b24929f0d7d2774dfc4266d60aef4c95b7c358505b7e5b110dfc26a97e">CY_CAPSENSE_WD_LOW_POWER_E</a> type are not processed and <a class="el" href="group__group__capsense__macros__status.html#ga8497b8b090398be7d1550d31946c6013">CY_CAPSENSE_STATUS_BAD_PARAM</a> is returned if a widget of this type is passed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the widget processing:<ul>
<li>CY_CAPSENSE_STATUS_SUCCESS - The operation is successfully completed</li>
<li>CY_CAPSENSE_STATUS_BAD_PARAM - The input parameter is invalid either widgetId is not valid or multi-frequency is not enabled for this widget or the specified widgetId is derivative of the main widget. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga8266fcf05ad962580844a2c9c01f2fb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8266fcf05ad962580844a2c9c01f2fb8">&#9670;&nbsp;</a></span>Cy_CapSense_CheckCRCWidget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__enums.html#gafbe67572b1e6a637676b0a6e1040857c">cy_en_capsense_bist_status_t</a> Cy_CapSense_CheckCRCWidget </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>widgetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the stored CRC of the <a class="el" href="structcy__stc__capsense__widget__context__t.html">cy_stc_capsense_widget_context_t</a> data structure of the specified widget. </p>
<p>This function validates the data integrity of the <a class="el" href="structcy__stc__capsense__widget__context__t.html">cy_stc_capsense_widget_context_t</a> data structure of the specified widget by calculating the CRC and comparing it with the stored CRC value of the specified widget.</p>
<p>Initially, after the device power up, the <a class="el" href="group__group__capsense__high__level.html#gade28f1f915ce6b97f13399074a819c0d" title="Initializes the CAPSENSE™ firmware modules. ">Cy_CapSense_Enable()</a> function calculates CRC for each widget and stores them in the .ptrWdgtCrc[] array of the <a class="el" href="structcy__stc__capsense__bist__context__t.html">cy_stc_capsense_bist_context_t</a> structure. The test execution compares this stored CRC value with the newly calculated and if the stored and calculated CRC values differ:</p><ol type="1">
<li>The calculated CRC is stored to the .wdgtCrcCalc field of the <a class="el" href="structcy__stc__capsense__bist__context__t.html">cy_stc_capsense_bist_context_t</a> data structure.</li>
<li>The widget ID is stored to the .crcWdgtId field.</li>
<li>The CY_CAPSENSE_BIST_CRC_WDGT_MASK bit is set in the .testResultMask field.</li>
</ol>
<p>The function never clears the CY_CAPSENSE_BIST_CRC_WDGT_MASK bit. If the CY_CAPSENSE_BIST_CRC_WDGT_MASK bit is set, the wdgtCrcCalc and .crcWdgtId fields are not updated.</p>
<p>It is recommended to use the <a class="el" href="group__group__capsense__low__level.html#ga6049654627a08e866ebe5e93ac414177" title="Sets a new value for the specified parameter in cy_capsense_tuner structure. ">Cy_CapSense_SetParam()</a> function to change the value of the <a class="el" href="structcy__stc__capsense__widget__context__t.html">cy_stc_capsense_widget_context_t</a> data structure elements as the CRC is updated by <a class="el" href="group__group__capsense__low__level.html#ga6049654627a08e866ebe5e93ac414177" title="Sets a new value for the specified parameter in cy_capsense_tuner structure. ">Cy_CapSense_SetParam()</a> function.</p>
<p>You can initiate this test by the <a class="el" href="group__group__capsense__high__level.html#gab1f1514db0566e14ba20fd8647ecb3ad" title="Runs built-in self-tests specified by the test enable mask. ">Cy_CapSense_RunSelfTest()</a> function with the CY_CAPSENSE_BIST_CRC_WDGT_MASK mask as an input.</p>
<p>The function clears the CY_CAPSENSE_WD_WORKING_MASK bit of the .status field in <a class="el" href="structcy__stc__capsense__widget__context__t.html">cy_stc_capsense_widget_context_t</a> structure if the calculated CRC value differs to the stored CRC value. Those non-working widgets are skipped by the high-level scanning and processing functions. Restoring a widget to its working state should be done by the application level.</p>
<p>For details of the used CRC algorithm, refer to the <a class="el" href="group__group__capsense__low__level.html#ga2de812825cd421ee05fec733206e157a" title="Calculates CRC for the specified buffer and length. ">Cy_CapSense_GetCRC()</a> function.</p>
<dl class="section note"><dt>Note</dt><dd>This function is available when self-test library is enabled.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">widgetId</td><td>Specifies the ID number of the widget. A macro for the widget ID can be found in the CAPSENSE&trade; Configuration header file (cycfg_capsense.h) defined as CY_CAPSENSE_&lt;WidgetName&gt;_WDGT_ID.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a status of the test execution:<ul>
<li>CY_CAPSENSE_BIST_SUCCESS_E - The stored CRC matches the calculated CRC.</li>
<li>CY_CAPSENSE_BIST_FAIL_E - The widget CRC differs to the stored CRC.</li>
<li>CY_CAPSENSE_BIST_BAD_PARAM_E - The input parameters are invalid. The test was not executed. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga617c2c407a13538ca6662314402e3f61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga617c2c407a13538ca6662314402e3f61">&#9670;&nbsp;</a></span>Cy_CapSense_CheckIntegritySensorRawcount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__enums.html#gafbe67572b1e6a637676b0a6e1040857c">cy_en_capsense_bist_status_t</a> Cy_CapSense_CheckIntegritySensorRawcount </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>widgetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sensorId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>rawcountHighLimit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>rawcountLowLimit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the raw count of the specified widget/sensor is within the specified range. </p>
<p>The raw count is within a specific range (based on the calibration target) for good units. The function checks whether or not the raw count is within the user-defined limits in the ranges function arguments. If the raw count is out of limits, this function sets the CY_CAPSENSE_BIST_RAW_INTEGRITY_MASK bit in the .testResultMask field of the <a class="el" href="structcy__stc__capsense__bist__context__t.html">cy_stc_capsense_bist_context_t</a> structure.</p>
<p>This function does not update the CY_CAPSENSE_WD_WORKING_MASK bit of the .status field in <a class="el" href="structcy__stc__capsense__widget__context__t.html">cy_stc_capsense_widget_context_t</a> structure and is not available in the <a class="el" href="group__group__capsense__high__level.html#gab1f1514db0566e14ba20fd8647ecb3ad" title="Runs built-in self-tests specified by the test enable mask. ">Cy_CapSense_RunSelfTest()</a> function.</p>
<p>Use this function to verify the uniformity of sensors, for example, at mass-production or during an operation phase together with the <a class="el" href="group__group__capsense__low__level.html#gab5574b4c085f9cf891457cbf835e6ca1" title="Checks if the baseline of the specified sensor is not corrupted by comparing it with its inverse copy...">Cy_CapSense_CheckIntegritySensorBaseline()</a> function.</p>
<p>The function should be called after sensors scanning and processing. Do not call the function before processing since processing changes sensor raw counts.</p>
<dl class="section note"><dt>Note</dt><dd>This function is available when self-test library is enabled.</dd>
<dd>
This function does not support Liquid Level widget.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">widgetId</td><td>Specifies the ID number of the widget. A macro for the widget ID can be found in the CAPSENSE&trade; Configuration header file (cycfg_capsense.h) defined as CY_CAPSENSE_&lt;WidgetName&gt;_WDGT_ID.</td></tr>
    <tr><td class="paramname">sensorId</td><td>Specifies the ID number of the sensor within the widget. A macro for the sensor ID within the specified widget can be found in the CAPSENSE&trade; Configuration header file (cycfg_capsense.h) defined as CY_CAPSENSE_&lt;WidgetName&gt;_SNS&lt;SensorNumber&gt;_ID.</td></tr>
    <tr><td class="paramname">rawcountHighLimit</td><td>Specifies the upper limit for the widget/sensor raw count.</td></tr>
    <tr><td class="paramname">rawcountLowLimit</td><td>Specifies the lower limit for the widget/sensor raw count.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a status of the test execution:<ul>
<li>CY_CAPSENSE_BIST_SUCCESS_E - The raw count is within the specified range.</li>
<li>CY_CAPSENSE_BIST_FAIL_E - The test failed and raw count is out of the specified limits.</li>
<li>CY_CAPSENSE_BIST_BAD_PARAM_E - The input parameter is invalid. The test was not executed.</li>
<li>CY_CAPSENSE_BIST_FEATURE_DISABLED_E - The selected widget is not supported. The test was not executed. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gab5574b4c085f9cf891457cbf835e6ca1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5574b4c085f9cf891457cbf835e6ca1">&#9670;&nbsp;</a></span>Cy_CapSense_CheckIntegritySensorBaseline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__enums.html#gafbe67572b1e6a637676b0a6e1040857c">cy_en_capsense_bist_status_t</a> Cy_CapSense_CheckIntegritySensorBaseline </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>widgetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sensorId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>baselineHighLimit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>baselineLowLimit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the baseline of the specified sensor is not corrupted by comparing it with its inverse copy and checks if the baseline is within the specified range. </p>
<p>The function checks whether or not the baseline binary inverted to its inverse copy is saved to the self-test baseline-inverse structure and is within the user-defined limits. If the baseline does not match its inverse copy or if the baseline is out of the user-defined limits, the function sets the CY_CAPSENSE_BIST_BSLN_INTEGRITY_MASK bit in the .testResultMask field of the <a class="el" href="structcy__stc__capsense__bist__context__t.html">cy_stc_capsense_bist_context_t</a> structure.</p>
<p>The test is integrated into the CAPSENSE&trade; Middleware. All CAPSENSE&trade; processing functions like <a class="el" href="group__group__capsense__high__level.html#ga2a185db228d5cae975fbc92bd3bc6367" title="Performs full data processing of all enabled widgets. ">Cy_CapSense_ProcessAllWidgets()</a> or <a class="el" href="group__group__capsense__low__level.html#ga4d2ceb23fa0e3731878ad777f39474d2" title="Updates the baseline for a sensor in a widget specified by the input parameters. ">Cy_CapSense_UpdateSensorBaseline()</a> automatically verify the baseline value before using it and update its inverse copy after processing. If a baseline update fails, a CY_CAPSENSE_STATUS_BAD_DATA result is returned. The baseline initialization functions do not verify the baseline and update the baseline inverse copy.</p>
<p>This function does not update the CY_CAPSENSE_WD_WORKING_MASK bit of the .status field in <a class="el" href="structcy__stc__capsense__widget__context__t.html">cy_stc_capsense_widget_context_t</a> structure and is not available in the <a class="el" href="group__group__capsense__high__level.html#gab1f1514db0566e14ba20fd8647ecb3ad" title="Runs built-in self-tests specified by the test enable mask. ">Cy_CapSense_RunSelfTest()</a> function.</p>
<p>Use this function to verify the uniformity of sensors, for example, at mass-production or during an operation phase together with the <a class="el" href="group__group__capsense__low__level.html#ga617c2c407a13538ca6662314402e3f61" title="Checks the raw count of the specified widget/sensor is within the specified range. ">Cy_CapSense_CheckIntegritySensorRawcount()</a> function.</p>
<p>The function should be called after sensors scanning and processing. Do not call the function before processing since processing changes sensor baselines.</p>
<dl class="section note"><dt>Note</dt><dd>This function is available when self-test library is enabled.</dd>
<dd>
This function does not support Liquid Level widget.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">widgetId</td><td>Specifies the ID number of the widget. A macro for the widget ID can be found in the CAPSENSE&trade; Configuration header file (cycfg_capsense.h) defined as CY_CAPSENSE_&lt;WidgetName&gt;_WDGT_ID.</td></tr>
    <tr><td class="paramname">sensorId</td><td>Specifies the ID number of the sensor within the widget. A macro for the sensor ID within the specified widget can be found in the CAPSENSE&trade; Configuration header file (cycfg_capsense.h) defined as CY_CAPSENSE_&lt;WidgetName&gt;_SNS&lt;SensorNumber&gt;_ID.</td></tr>
    <tr><td class="paramname">baselineHighLimit</td><td>Specifies the upper limit for a baseline.</td></tr>
    <tr><td class="paramname">baselineLowLimit</td><td>Specifies the lower limit for a baseline.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a status of the test execution:<ul>
<li>CY_CAPSENSE_BIST_SUCCESS_E - The baseline is within the specified range.</li>
<li>CY_CAPSENSE_BIST_FAIL_E - The test failed and the baseline is not binary inverted to its inverse copy or is out of the specified limits.</li>
<li>CY_CAPSENSE_BIST_BAD_PARAM_E - The input parameter is invalid. The test was not executed.</li>
<li>CY_CAPSENSE_BIST_FEATURE_DISABLED_E - The selected widget is not supported. The test was not executed. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gadcc9fa570b4c5aa91c66570f5c6f57d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadcc9fa570b4c5aa91c66570f5c6f57d4">&#9670;&nbsp;</a></span>Cy_CapSense_CheckIntegritySensorPins()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__enums.html#gafbe67572b1e6a637676b0a6e1040857c">cy_en_capsense_bist_status_t</a> Cy_CapSense_CheckIntegritySensorPins </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>widgetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sensorId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the specified widget/sensor for shorts to GND, VDD or other sensors. </p>
<p>This function performs several sub-tests to verify the specified sensor is not electrically shorted and is in a good condition to reliably detect user interactions.</p>
<p>This function performs tests to check if the specified sensor is shorted to:</p><ul>
<li>GND</li>
<li>VDD</li>
<li>Other GPIOs used by CAPSENSE&trade; (such as sensors, Tx, Rx, shield electrodes, and external capacitors)</li>
<li>Other non-CAPSENSE&trade; GPIOs (only if they are configured in a strong high or low state during the test execution).</li>
</ul>
<p>The absolute resistance of an electrical short must be less than 1500 Ohm including all series resistors on a sensor for a short to be detected to GND, VDD or GPIOs. For example, if a series resistor on a sensor is 560 Ohm (as recommended) and the sensor is shorted with another sensor, the function can detect a short with a short resistance up to 380 Ohm as there are two 560 ohm resistors between the shorted sensor GPIOs.</p>
<p>The function executes the following flow to detect a short:</p><ul>
<li>Configures all CAPSENSE&trade; controlled GPIOs to strong-drive-high, and the specified sensor GPIO to resistive pull down mode.</li>
<li>Waits for a delay (defined by .snsIntgShortSettlingTime field of the <a class="el" href="structcy__stc__capsense__bist__context__t.html">cy_stc_capsense_bist_context_t</a> structure) to get established all transient processes.</li>
<li>Checks the status of the specified sensor for the expected state (logic low).</li>
<li>Configures all CAPSENSE&trade; controlled GPIOs to strong-drive-low, and the specified sensor GPIO to resistive pull up mode.</li>
<li>Waits for the above mentioned delay.</li>
<li>Checks the status of the specified sensor for the expected state (logic high).</li>
<li>Stores the test result in the CAPSENSE&trade; Data Structure. A short is reported only when the sensor status check returns an unexpected state.</li>
</ul>
<p>Due to the sensor parasitic capacitance and internal pull-up/down resistance, logic high-to-low (and vice versa) transitions require a settling time before checking the sensor status. A 2us delay is used as a settling time and can be changed using the .snsIntgShortSettlingTime field of the <a class="el" href="structcy__stc__capsense__bist__context__t.html" title="Declares BIST Context Data Structure. ">cy_stc_capsense_bist_context_t</a> structure.</p>
<p>If a short is detected this function updates the following statuses:</p><ul>
<li>The widget ID is stored to the .shortedWdId field of the <a class="el" href="structcy__stc__capsense__bist__context__t.html">cy_stc_capsense_bist_context_t</a> structure.</li>
<li>The sensor ID is stored to the .shortedSnsId field of the <a class="el" href="structcy__stc__capsense__bist__context__t.html">cy_stc_capsense_bist_context_t</a> structure.</li>
<li>The CY_CAPSENSE_BIST_SNS_INTEGRITY_MASK bit is set in the .testResultMask field of the <a class="el" href="structcy__stc__capsense__bist__context__t.html">cy_stc_capsense_bist_context_t</a> structure.</li>
<li>If CY_CAPSENSE_BIST_SNS_INTEGRITY_MASK is already set due to a previously detected fault on any of the sensor, this function does not update the .shortedWdId and .shortedSnsId fields. For this reason, clear the CY_CAPSENSE_BIST_SNS_INTEGRITY_MASK bit prior calling this function.</li>
<li>The widget is disabled by clearing the CY_CAPSENSE_WD_WORKING_MASK bit in the .status field of the <a class="el" href="structcy__stc__capsense__widget__context__t.html">cy_stc_capsense_widget_context_t</a> structure of the specified widget. The disabled widget is ignored by high-level functions of scanning / data processing. To restore the widget operation the application layer should manually set the CY_CAPSENSE_WD_WORKING_MASK bit.</li>
</ul>
<p>To check all the project sensors at once, use the <a class="el" href="group__group__capsense__high__level.html#gab1f1514db0566e14ba20fd8647ecb3ad" title="Runs built-in self-tests specified by the test enable mask. ">Cy_CapSense_RunSelfTest()</a> function with the CY_CAPSENSE_BIST_SNS_INTEGRITY_MASK mask.</p>
<p>To detect an electrical short or fault condition with resistance higher than 1500 ohm, the <a class="el" href="group__group__capsense__low__level.html#ga3bf9894c313d4ffce1be841141d6b8e5" title="Measures the specified CSD sensor / CSX electrode capacitance in femtofarads. ">Cy_CapSense_MeasureCapacitanceSensor()</a> (4th Generation) or <a class="el" href="group__group__capsense__low__level.html#ga23f23f4e684b25788f999851f20aa58c" title="Measures the specified CSD sensor / CSX electrode capacitance in femtofarads. ">Cy_CapSense_MeasureCapacitanceSensorElectrode()</a> (5th Generation) function can be used as the fault condition affects the measured sensor capacitance.</p>
<p>This test can be executed only if the CAPSENSE&trade; Middleware is in the IDLE state. This function must not be called while CAPSENSE&trade; Middleware is busy.</p>
<dl class="section note"><dt>Note</dt><dd>Rx/Lx electrodes for ISX widgets are excluded from the test as they are electrically shorted to GND and the CY_CAPSENSE_BIST_BAD_PARAM_E result for such widgets is returned.</dd>
<dd>
This function is available when self-test library is enabled.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">widgetId</td><td>Specifies the ID number of the widget. A macro for the widget ID can be found in the CAPSENSE&trade; Configuration header file (cycfg_capsense.h) defined as CY_CAPSENSE_&lt;WidgetName&gt;_WDGT_ID.</td></tr>
    <tr><td class="paramname">sensorId</td><td>Specifies the ID of the sensor (electrode for CSX widgets) within the widget to be tested.</td></tr>
  </table>
  </dd>
</dl>
<p>For the CSD widgets, a macro for the sensor ID within the specified widget can be found in the CAPSENSE&trade; Configuration header file (cycfg_capsense.h) defined as CY_CAPSENSE_&lt;WidgetName&gt;_SNS&lt;SensorNumber&gt;_ID.</p>
<p>For the CSX widgets, sensorId is an electrode ID and is defined as Rx ID or Tx ID. The first Rx in a widget corresponds to electrodeId = 0, the second Rx in a widget corresponds to electrodeId = 1, and so on. The last Tx in a widget corresponds to electrodeId = (RxNum + TxNum - 1). Macros for Rx and Tx IDs can be found in the CAPSENSE&trade; Configuration header file (cycfg_capsense.h) defined as:</p><ul>
<li>CapSense_&lt;WidgetName&gt;_RX&lt;RXNumber&gt;_ID</li>
<li>CapSense_&lt;WidgetName&gt;_TX&lt;TXNumber&gt;_ID.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a status of the test execution:<ul>
<li>CY_CAPSENSE_BIST_SUCCESS_E - The sensor pin(s) are valid for CAPSENSE&trade; operations.</li>
<li>CY_CAPSENSE_BIST_FAIL_E - A short is detected on the specified sensor.</li>
<li>CY_CAPSENSE_BIST_BAD_PARAM_E - The input parameter is invalid. The test was not executed.</li>
<li>CY_CAPSENSE_BIST_HW_BUSY_E - The CAPSENSE&trade; HW block is busy with a previous operation. The function was not executed. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga80ad1c421ea794bd493bb37e76c48a2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80ad1c421ea794bd493bb37e76c48a2b">&#9670;&nbsp;</a></span>Cy_CapSense_MeasureCapacitanceCap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__enums.html#gafbe67572b1e6a637676b0a6e1040857c">cy_en_capsense_bist_status_t</a> Cy_CapSense_MeasureCapacitanceCap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__capsense__enums.html#ga07f6f8cbe8fa1cebb08e2bd44e9de29b">cy_en_capsense_bist_external_cap_id_t</a>&#160;</td>
          <td class="paramname"><em>integrationCapId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>ptrValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>maxCapacitance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Measures the capacitance in picofarads of the specified CAPSENSE&trade; integration (external) capacitor. </p>
<p>The function measures the capacitance of the specified external capacitor such as Cmod and returns the result through ptrValue, alternatively the measurement result is stored in the corresponding field of the <a class="el" href="structcy__stc__capsense__bist__context__t.html">cy_stc_capsense_bist_context_t</a> structure (either .cModCap, .cIntACap, .cIntBCap, or .cShieldCap for the fourth-generation, and .cMod01Cap or .cMod02Cap the fifth-generation low power CAPSENSE&trade; HW blocks).</p>
<p>The maximum measurement capacitance is 25nF. The measurement accuracy is up to 15% for the fourth-generation and up to 30% for the fifth-generation low power CAPSENSE&trade; HW blocks. The measurement resolution is 10 bit which corresponds to the maximum capacitance specified by the maxCapacitance parameter. The bigger specified maximum capacitance is, the bigger capacitance value is for one measured count. It is recommended to specify the maximum capacitance twice bigger as the nominal capacitor capacitance. For example, if the nominal Cmod value is 2.2nF, the maxCapacitance parameter is set to 4nF-5nF.</p>
<p>The function configures all CAPSENSE&trade; pins to Strong-drive-low mode that allows detecting a short of the measured capacitor to other pins.</p>
<p>To measure all the available capacitors, the <a class="el" href="group__group__capsense__high__level.html#gab1f1514db0566e14ba20fd8647ecb3ad" title="Runs built-in self-tests specified by the test enable mask. ">Cy_CapSense_RunSelfTest()</a> function can be used with the CY_CAPSENSE_BIST_EXTERNAL_CAP_MASK mask. The measured results are stored in the corresponding field of the <a class="el" href="structcy__stc__capsense__bist__context__t.html">cy_stc_capsense_bist_context_t</a> structure.</p>
<p>Measurement can be done only if the CAPSENSE&trade; Middleware is in the IDLE state. This function must not be called while the CAPSENSE&trade; Middleware is busy. The function is blocking, i.e. waits for the measurement to be completed prior to returning to the caller.</p>
<dl class="section note"><dt>Note</dt><dd>This function is available for the fourth-generation and fifth-generation low power CAPSENSE&trade;.</dd>
<dd>
This function is available when self-test library is enabled.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">integrationCapId</td><td>Indexes of external capacitors to measure their capacitance. There are the enumeration list /ref cy_en_capsense_bist_external_cap_id_t for each of them. Their values could be for the fourth-generation CAPSENSE&trade; HW blocks:<ul>
<li>CY_CAPSENSE_BIST_CMOD_ID for the CSD method Cmod capacitor</li>
<li>CY_CAPSENSE_BIST_CINTA_ID for the CSX method CintA capacitor</li>
<li>CY_CAPSENSE_BIST_CINTB_ID for the CSX method CintB capacitor</li>
<li>CY_CAPSENSE_BIST_CSH_ID for the CSD method Csh capacitor and for the fifth-generation low power CAPSENSE&trade; HW blocks:</li>
<li>CY_CAPSENSE_BIST_CMOD01_ID_E for the Cmod1 capacitor</li>
<li>CY_CAPSENSE_BIST_CMOD02_ID_E for the Cmod2 capacitor</li>
</ul>
</td></tr>
    <tr><td class="paramname">ptrValue</td><td>The pointer to the result of the measurement. The result is calculated as a specified capacitor capacitance value in picofarads. The user declares a variable of the uint32_t type and passes the pointer to this variable as the function parameter. If the ptrValue parameter is NULL then the capacitance value is not returned through the parameter but stored to the corresponding field of the <a class="el" href="structcy__stc__capsense__bist__context__t.html">cy_stc_capsense_bist_context_t</a> structure.</td></tr>
    <tr><td class="paramname">maxCapacitance</td><td>An expected by the user maximum value of the measured capacitance in nanofarads in the range from 1 to 25 nF.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a status of the test execution:<ul>
<li>CY_CAPSENSE_BIST_SUCCESS_E - The measurement completes successfully, the result is valid.</li>
<li>CY_CAPSENSE_BIST_BAD_PARAM_E - The input parameter is invalid. The measurement was not executed.</li>
<li>CY_CAPSENSE_BIST_HW_BUSY_E - The CAPSENSE&trade; HW block is busy with a previous operation. The measurement was not executed.</li>
<li>CY_CAPSENSE_BIST_LOW_LIMIT_E - The measurement was performed but the scanning result is below the minimum possible value. The measurement result could be invalid. The capacitor might be shorted to VDD or a PCB track is broken (open capacitor) The return could occur only the fourth-generation CAPSENSE&trade;.</li>
<li>CY_CAPSENSE_BIST_HIGH_LIMIT_E - The measurement was performed but the scanning result is above the maximum possible value. The measurement result could be invalid. The capacitor might be shorted to GND. The result could occur only for the fourth-generation CAPSENSE&trade;.</li>
<li>CY_CAPSENSE_BIST_ERROR_E - An unexpected fault occurred during the measurement. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga0214428f5737ef46a2f755620c4e7316"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0214428f5737ef46a2f755620c4e7316">&#9670;&nbsp;</a></span>Cy_CapSense_MeasureVdda()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__enums.html#gafbe67572b1e6a637676b0a6e1040857c">cy_en_capsense_bist_status_t</a> Cy_CapSense_MeasureVdda </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>ptrValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Measures a VDDA voltage, returns the measured voltage in millivolts through the ptrValue argument and stores it to the .vddaVoltage field of the <a class="el" href="structcy__stc__capsense__bist__context__t.html">cy_stc_capsense_bist_context_t</a> structure. </p>
<p>This function measures the device analog supply voltage (VDDA) without need of explicitly connecting VDDA to any additional GPIO input. This capability can be used in variate cases, for example to monitor the battery voltage.</p>
<p>A measurement can be done only if the CAPSENSE&trade; middleware is in the IDLE state. This function must not be called while the CAPSENSE&trade; middleware is busy. The function is blocking, i.e. waits for the conversion to be completed prior to returning to the caller.</p>
<dl class="section note"><dt>Note</dt><dd>This function is available only for the fourth-generation and fifth generation low power CAPSENSE&trade;.</dd>
<dd>
This function is available when self-test library is enabled.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrValue</td><td>The pointer to the uint32_t to store measured VDDA voltage value. If the ptrValue parameter is NULL then VDDA voltage value is not returned through the parameter and is stored in the .vddaVoltage field of the <a class="el" href="structcy__stc__capsense__bist__context__t.html">cy_stc_capsense_bist_context_t</a> structure.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a status of the test execution:<ul>
<li>CY_CAPSENSE_BIST_SUCCESS_E - The measurement executed successfully.</li>
<li>CY_CAPSENSE_BIST_BAD_PARAM_E - The input parameter is invalid. The measurement was not executed.</li>
<li>CY_CAPSENSE_BIST_ERROR_E - An unexpected fault occurred during the measurement. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga23f23f4e684b25788f999851f20aa58c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga23f23f4e684b25788f999851f20aa58c">&#9670;&nbsp;</a></span>Cy_CapSense_MeasureCapacitanceSensorElectrode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__enums.html#gafbe67572b1e6a637676b0a6e1040857c">cy_en_capsense_bist_status_t</a> Cy_CapSense_MeasureCapacitanceSensorElectrode </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>widgetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>eltdId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Measures the specified CSD sensor / CSX electrode capacitance in femtofarads. </p>
<p>This function measures the sensor capacitance for CSD widgets or the electrode capacitance for CSX widgets and returns the measurement status. For a CSX sensor, the measurement is done on either Rx or Tx electrode. For a CSD sensor, measurement is done on a sensor (refer to the eltdId parameter description). If the specified sensor (electrode) is a ganged sensor, the capacitance is measured for all the pins ganged together that belong to this sensor (electrode).</p>
<p>The measured capacitance is stored in the .eltdCap[] array. The .ptrEltdCapacitance field of the <a class="el" href="structcy__stc__capsense__widget__config__t.html">cy_stc_capsense_widget_config_t</a> structure contains a pointer to the first widget sensor (electrode) element within the .eltdCap[] array.</p>
<p>In addition to the measuring sensor (electrode) capacitance, this function is used to identify various fault conditions with sensors such as electrically-opened or -shorted sensors. For example, the PCB track is broken or shorted to other nodes in the system - in all of these conditions, this function returns changed capacitance which can be compared against predetermined capacitance for the sensor to detect a fault condition.</p>
<p>The sensor capacitance is measured independently of the sensor scan configuration. For the capacitance measurement, the CSD sensing method is used. The default scanning parameters are the following:</p><ul>
<li>SnsClk divider (256) is the divider for the sensor clock frequency.</li>
<li>NumConv (100) is the number of sub-conversions.</li>
<li>The reference CDAC capacitance (887 fF) is equivalent to CDAC Code of 100u.</li>
<li>The compensation CDAC is disabled.</li>
<li>The CIC2 filter is disabled.</li>
<li>The dithering is disabled.</li>
<li>The chopping is disabled.</li>
</ul>
<p>The raw count is converted into capacitance using the following equation:</p>
<p>Cs = Rawcount * RefCDAC capacitance / NumConv</p>
<p>where:</p><ul>
<li>Cs is the sensor capacitance.</li>
<li>Rawcount is the measured raw count value.</li>
</ul>
<p>The minimum measurable input by this function is 1pF and the maximum is either 200pF or limited by the RC time constant (Cs &lt; 1 / (2*5*SnsClk*R) (275pF or limited by the RC time constant (Cs &lt; 1 / (4*5*SnsClk*R) for fifth-generation low power CAPSENSE&trade;), where R is the total sensor series resistance that includes on-chip GPIO resistance ~500 Ohm and external series resistance). The measurement accuracy is about 30% and is defined by the RefCDAC tolerance.</p>
<p>By default, all CAPSENSE&trade; sensors (electrodes) inherit regular scanning configuration. For example if the Inactive sensor connection parameter of the CSD sensing method is set to GND, sensors that are not being measured are set to the GND state. The inactive state can be changed in run-time by using the <a class="el" href="group__group__capsense__low__level.html#ga760c8b9c8e17b5c9689bf9305a34e393" title="Sets a desired state for all inactive CAPSENSE™-related electrodes for CSD, CSX, ISX scans...">Cy_CapSense_SetInactiveElectrodeState()</a> function.</p>
<p>By default, the both Cmod1 and Cmod2 capacitors are used for the measurement.</p>
<p>The sensor measurement can be done on all the electrodes using the <a class="el" href="group__group__capsense__high__level.html#gab1f1514db0566e14ba20fd8647ecb3ad" title="Runs built-in self-tests specified by the test enable mask. ">Cy_CapSense_RunSelfTest()</a> function along with the CY_CAPSENSE_BIST_ELTD_CAP_MASK mask.</p>
<p>This function must not be called while the CAPSENSE&trade; MW is busy by another scan.</p>
<dl class="section note"><dt>Note</dt><dd>This function is available for the fifth-generation and fifth-generation low power CAPSENSE&trade;. Rx/Lx electrodes for ISX widgets are excluded from the test as they are electrically shorted to GND and the CY_CAPSENSE_BIST_BAD_PARAM_E result for such widgets is returned.</dd>
<dd>
This function is available when self-test library is enabled.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">widgetId</td><td>Specifies the ID number of the widget. A macro for the widget ID can be found in the CAPSENSE&trade; Configuration header file (cycfg_capsense.h) defined as CY_CAPSENSE_&lt;WidgetName&gt;_WDGT_ID.</td></tr>
    <tr><td class="paramname">eltdId</td><td>Specifies the ID of the electrode within the widget (sensorID for CSD widgets and Rx or Tx electrode ID for CSX widgets).</td></tr>
  </table>
  </dd>
</dl>
<p>For the CSD widgets, a macro for the sensor ID within the specified widget can be found in the CAPSENSE&trade; Configuration header file (cycfg_capsense.h) defined as CY_CAPSENSE_&lt;WidgetName&gt;_SNS&lt;SensorNumber&gt;_ID.</p>
<p>For the CSX widgets, eltdId is an electrode ID and is defined as Rx ID or Tx ID. The first Rx in a widget corresponds to eltdId = 0, the second Rx in a widget corresponds to eltdId = 1, and so on. The last Tx in a widget corresponds to eltdId = (RxNum + TxNum - 1). Macros for Rx and Tx IDs can be found in the CAPSENSE&trade; Configuration header file (cycfg_capsense.h) defined as:</p><ul>
<li>CapSense_&lt;WidgetName&gt;_RX&lt;RXNumber&gt;_ID</li>
<li>CapSense_&lt;WidgetName&gt;_TX&lt;TXNumber&gt;_ID.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a status of the test execution:<ul>
<li>CY_CAPSENSE_BIST_SUCCESS_E - The measurement completes successfully, the result is valid.</li>
<li>CY_CAPSENSE_BIST_BAD_PARAM_E - The input parameter is invalid. The measurement was not executed.</li>
<li>CY_CAPSENSE_BIST_HW_BUSY_E - The CAPSENSE&trade; HW block is busy with a previous operation. The measurement was not executed. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gadb467c284dc3fea4c7347a25c5ff57df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb467c284dc3fea4c7347a25c5ff57df">&#9670;&nbsp;</a></span>Cy_CapSense_MeasureCapacitanceSlotSensors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__enums.html#gafbe67572b1e6a637676b0a6e1040857c">cy_en_capsense_bist_status_t</a> Cy_CapSense_MeasureCapacitanceSlotSensors </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>slotId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>skipChMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Measures the specified slot sensor capacitance in femtofarads. </p>
<p>The function measures the Cp capacitance for CSD widgets and the Cm capacitance for CSX widgets.</p>
<p>This function performs BIST slot scan with predefined parameters, back-calculates the slot sensor capacitances (Cp for CSD and Cm for CSX) by using the raw-count equation, stores the calculated capacitances to the sensor context structure, and returns the measurement status. If the specified slot has a ganged sensor, the capacitance is measured for all the pins ganged together that belong to this sensor.</p>
<p>Besides the sensor capacitance measuring, this function could be used to identify various fault conditions with sensors such as electrically-opened or -shorted sensors. For example, the PCB track is broken or shorted to other nodes in the system - in all of these conditions, the function returns changed capacitance which can be compared against predetermined capacitance for the sensor to detect a fault condition.</p>
<p>The sensor capacitance is measured independently of the sensor regular scan configuration. For the capacitance measurement, the BIST specific scan parameters are used. They can be found in the Electrode capacitance measurement macros group. The CDAC code for the CSD sensors is 100u and that provides about 0.887 pF of the CDAC value and for CSX sensors the CDAC code is 50u (0.443 pF). Compensation CDAC is disabled during the BIST scan. Another default scanning parameters are the following:</p><ul>
<li>NumConv (100) is the number of sub-conversions.</li>
<li>SnsClk divider (256) is the divider for the sensor clock frequency.</li>
</ul>
<p>The raw count is converted into capacitance using the following equation:</p>
<p>Cs = Rawcount * CDAC / 2 / NumConv / 2</p>
<p>where:</p><ul>
<li>Cs is the sensor capacitance.</li>
<li>Rawcount is the measured raw count value.</li>
<li>The first divider of 2 is determined by the divided ref_clk frequency usage.</li>
<li>The second divider of 2 is used only for CSX sensors.</li>
</ul>
<p>The minimum measurable input by this function is 1pF and the maximum is either 200pF or limited by the RC time constant (Cs &lt; 1 / (2*5*SnsClk*R) (275pF or limited by the RC time constant (Cs &lt; 1 / (4*5*SnsClk*R) for fifth-generation low power CAPSENSE&trade;), where R is the total sensor series resistance that includes on-chip pin resistance ~500 Ohm and external series resistance). The measurement accuracy is about 30%.</p>
<p>By default, all CAPSENSE&trade; sensors (electrodes) inherit regular scanning configuration. For example if the Inactive sensor connection parameter of the CSD sensing method is set to GND, sensors that are not being measured are set to the GND state. The inactive state can be changed in run-time by using the <a class="el" href="group__group__capsense__low__level.html#ga760c8b9c8e17b5c9689bf9305a34e393" title="Sets a desired state for all inactive CAPSENSE™-related electrodes for CSD, CSX, ISX scans...">Cy_CapSense_SetInactiveElectrodeState()</a> function.</p>
<p>By default, the both Cmod1 and Cmod2 capacitors are used for the measurement.</p>
<p>Measured capacitance values (Cp for CSD widgets and Cm for CSX widgets) are stored in the ptrSnsCapacitance sensor capacitance array field and in the ptrEltdCapacitance electrode capacitance array of the <a class="el" href="structcy__stc__capsense__widget__config__t.html">cy_stc_capsense_widget_config_t</a> structure.</p>
<p>The all sensor measurement can be done on all the sensors using the <a class="el" href="group__group__capsense__high__level.html#gab1f1514db0566e14ba20fd8647ecb3ad" title="Runs built-in self-tests specified by the test enable mask. ">Cy_CapSense_RunSelfTest()</a> function along with the CY_CAPSENSE_BIST_SNS_CAP_MASK mask.</p>
<p>This function must not be called while the CAPSENSE&trade; MW is busy by another scan.</p>
<dl class="section note"><dt>Note</dt><dd>This function is available for the fifth-generation and fifth-generation low power CAPSENSE&trade;. Rx/Lx electrodes for ISX widgets are excluded from the test as they are electrically shorted to GND and the CY_CAPSENSE_BIST_BAD_PARAM_E result for such widgets is returned.</dd>
<dd>
This function is available when self-test library is enabled.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slotId</td><td>Specifies the ID number of the slot to measure sensor capacitance. The slot ID should be in the admissible range.</td></tr>
    <tr><td class="paramname">skipChMask</td><td>Specifies the mask to skip some channels during the slot sensor capacitance measurement. If the bit N in the skipChMask is set to 1, the channel N will be excluded from measuring and all its pins will be set to the inactive sensor connection state (see the .eltdCapCsdISC field of the <a class="el" href="structcy__stc__capsense__bist__context__t.html">cy_stc_capsense_bist_context_t</a> structure for CSD widgets and the .eltdCapCsxISC field respectively for CSX widgets). For fifth-generation low power CAPSENSE&trade; this argument is kept for uniformity and backward compatibility and is not used. The function can be called with value 0u.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a status of the test execution:<ul>
<li>CY_CAPSENSE_BIST_SUCCESS_E - The measurement completes successfully, the result is valid.</li>
<li>CY_CAPSENSE_BIST_BAD_PARAM_E - The input parameter is invalid. The measurement was not executed.</li>
<li>CY_CAPSENSE_BIST_HW_BUSY_E - The CAPSENSE&trade; HW block is busy with a previous operation. The measurement was not executed.</li>
<li>CY_CAPSENSE_BIST_ERROR_E - An unexpected fault occurred during the measurement. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaff014dbf80fc7824a7e6e3e377d2942f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff014dbf80fc7824a7e6e3e377d2942f">&#9670;&nbsp;</a></span>Cy_CapSense_MeasureCapacitanceShieldElectrode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__enums.html#gafbe67572b1e6a637676b0a6e1040857c">cy_en_capsense_bist_status_t</a> Cy_CapSense_MeasureCapacitanceShieldElectrode </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>skipChMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Measures shield electrode capacitances in femtofarads. </p>
<p>This function measures the capacitances of all shield electrodes for all enabled MSCv3 channels and returns a status of this measurement. The function checks if there is any CSD widget in the project and if the shield is enabled. The measurement results in femtofarads are stored in the chShieldCap[CY_MSC_ENABLED_CH_NUMBER] array. The pointer to the array is in the .ptrChShieldCap field of the <a class="el" href="structcy__stc__capsense__bist__context__t.html">cy_stc_capsense_bist_context_t</a> structure, the CY_MSC_ENABLED_CH_NUMBER define is in the cycfg_peripherals.h file. If the any channel shield consists of several electrodes, the total capacitance of all the shield electrodes is measured.</p>
<p>This function uses an algorithm identical to the electrode capacitance measurement. Refer to the <a class="el" href="group__group__capsense__low__level.html#ga23f23f4e684b25788f999851f20aa58c" title="Measures the specified CSD sensor / CSX electrode capacitance in femtofarads. ">Cy_CapSense_MeasureCapacitanceSensorElectrode()</a> function for more details.</p>
<p>In addition to measuring shield capacitance, this function is used to identify various fault conditions with shield electrodes such as an electrically-open or -short shield electrodes, e.g. the PCB track is broken or shorted to other nodes in the system - in all of these conditions, this function returns changed capacitance that can be compared against pre-determined capacitance for the shield electrode to detect a hardware fault.</p>
<p>By default, all CAPSENSE&trade; sensors (electrodes) inherit regular scanning configuration. For example if the Inactive sensor connection parameter of the CSD sensing method is set to GND, sensors that are not being measured are set to the GND state. The inactive state can be changed in run-time by using the <a class="el" href="group__group__capsense__low__level.html#ga760c8b9c8e17b5c9689bf9305a34e393" title="Sets a desired state for all inactive CAPSENSE™-related electrodes for CSD, CSX, ISX scans...">Cy_CapSense_SetInactiveElectrodeState()</a> function. When the inactive sensor (electrode) connection is set to the CY_CAPSENSE_SNS_CONNECTION_SHIELD state, all the CAPSENSE&trade; electrodes are connected to the shield and the total capacitance are measured.</p>
<p>By default, the both Cmod1 and Cmod2 capacitors are used for the measurement.</p>
<p>This test can be executed using the CapSense_RunSelfTest() function with the CY_CAPSENSE_BIST_SHIELD_CAP_MASK mask.</p>
<dl class="section note"><dt>Note</dt><dd>This function is available for the fifth-generation and fifth-generation low power CAPSENSE&trade;.</dd>
<dd>
This function is available when self-test library is enabled.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">skipChMask</td><td>Specifies the mask to skip some channels during the shield electrode capacitance measurement. If the bit N in the skipChMask is set to 1, the channel N will be excluded from measuring and all its shield pins will be set to the shield inactive sensor connection state (see the .shieldCapISC field of the <a class="el" href="structcy__stc__capsense__bist__context__t.html">cy_stc_capsense_bist_context_t</a> structure). For fifth-generation low power CAPSENSE&trade; this argument is kept for uniformity and backward compatibility and is not used. The function can be called with value 0u.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a status of the test execution:<ul>
<li>CY_CAPSENSE_BIST_SUCCESS_E - The measurement completes successfully, the result is valid.</li>
<li>CY_CAPSENSE_BIST_BAD_PARAM_E - The input parameter is invalid. The measurement was not executed.</li>
<li>CY_CAPSENSE_BIST_HW_BUSY_E - The CAPSENSE&trade; HW block is busy with a previous operation. The measurement was not executed.</li>
<li>CY_CAPSENSE_BIST_BAD_CONFIG_E - The shield is disabled. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga667ff2892eb5a53d09f2207d5d178686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga667ff2892eb5a53d09f2207d5d178686">&#9670;&nbsp;</a></span>Cy_CapSense_MeasureCapacitanceLpSlotSensors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__enums.html#gafbe67572b1e6a637676b0a6e1040857c">cy_en_capsense_bist_status_t</a> Cy_CapSense_MeasureCapacitanceLpSlotSensors </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>slotId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Measures the specified low power slot sensor capacitance in femtofarads. </p>
<p>The function measures the Cp capacitance for CSD widgets and the Cm capacitance for CSX widgets.</p>
<p>This function performs BIST slot scan with predefined parameters, back-calculates the slot sensor capacitances (Cp for CSD and Cm for CSX) by using the raw-count equation, stores the calculated capacitances to the sensor context structure, and returns the measurement status. If the specified slot has a ganged sensor, the capacitance is measured for all the pins ganged together that belong to this sensor.</p>
<p>Besides the sensor capacitance measuring, this function could be used to identify various fault conditions with sensors such as electrically-opened or -shorted sensors. For example, the PCB track is broken or shorted to other nodes in the system - in all of these conditions, the function returns changed capacitance which can be compared against predetermined capacitance for the sensor to detect a fault condition.</p>
<p>The sensor capacitance is measured independently of the sensor regular scan configuration. For the capacitance measurement, the BIST specific scan parameters are used. They can be found in the Electrode capacitance measurement macros group. The CDAC code for the CSD sensors is 100u and that provides about 0.887 pF of the CDAC value and for CSX sensors the CDAC code is 50u (0.443 pF). Compensation CDAC is disabled during the BIST scan. Another default scanning parameters are the following:</p><ul>
<li>NumConv (100) is the number of sub-conversions.</li>
<li>SnsClk divider (256) is the divider for the sensor clock frequency.</li>
</ul>
<p>The raw count is converted into capacitance using the following equation:</p>
<p>Cs = Rawcount * CDAC / 2 / NumConv / 2</p>
<p>where:</p><ul>
<li>Cs is the sensor capacitance.</li>
<li>Rawcount is the measured raw count value.</li>
<li>The first divider of 2 is determined by the divided ref_clk frequency usage.</li>
<li>The second divider of 2 is used only for CSX sensors.</li>
</ul>
<p>The minimum measurable input by this function is 0.5 pF and the maximum is either 200pF or limited by the RC time constant (Cs &lt; 1 / (2*10*SnsClk*R), where R is the total sensor series resistance that includes on-chip pin resistance ~500 Ohm and external series resistance). The measurement accuracy is about 30%.</p>
<p>By default, all CAPSENSE&trade; sensors (electrodes) inherit regular scanning configuration. For example if the Inactive sensor connection parameter of the CSD sensing method is set to GND, sensors that are not being measured are set to the GND state. The inactive state can be changed in run-time by using the <a class="el" href="group__group__capsense__low__level.html#ga760c8b9c8e17b5c9689bf9305a34e393" title="Sets a desired state for all inactive CAPSENSE™-related electrodes for CSD, CSX, ISX scans...">Cy_CapSense_SetInactiveElectrodeState()</a> function.</p>
<p>By default, the both Cmod1 and Cmod2 capacitors are used for the measurement.</p>
<p>Measured capacitance values (Cp for CSD widgets and Cm for CSX widgets) are stored in the ptrSnsCapacitance sensor capacitance array field and in the ptrEltdCapacitance electrode capacitance array of the <a class="el" href="structcy__stc__capsense__widget__config__t.html">cy_stc_capsense_widget_config_t</a> structure.</p>
<p>The all sensor measurement can be done on all the sensors using the <a class="el" href="group__group__capsense__high__level.html#gab1f1514db0566e14ba20fd8647ecb3ad" title="Runs built-in self-tests specified by the test enable mask. ">Cy_CapSense_RunSelfTest()</a> function along with the CY_CAPSENSE_BIST_SNS_CAP_MASK mask.</p>
<p>This function must not be called while the CAPSENSE&trade; MW is busy by another scan.</p>
<dl class="section note"><dt>Note</dt><dd>This function is available only for the fifth-generation low power CAPSENSE&trade;.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slotId</td><td>Specifies the ID number of the slot to measure sensor capacitance. The slot ID should be in the admissible range.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a status of the test execution:<ul>
<li>CY_CAPSENSE_BIST_SUCCESS_E - The measurement completes successfully, the result is valid.</li>
<li>CY_CAPSENSE_BIST_BAD_PARAM_E - The input parameter is invalid. The measurement was not executed.</li>
<li>CY_CAPSENSE_BIST_HW_BUSY_E - The CAPSENSE&trade; HW block is busy with a previous operation. The measurement was not executed.</li>
<li>CY_CAPSENSE_BIST_ERROR_E - An unexpected fault occurred during the measurement. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga3bf9894c313d4ffce1be841141d6b8e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3bf9894c313d4ffce1be841141d6b8e5">&#9670;&nbsp;</a></span>Cy_CapSense_MeasureCapacitanceSensor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__enums.html#gafbe67572b1e6a637676b0a6e1040857c">cy_en_capsense_bist_status_t</a> Cy_CapSense_MeasureCapacitanceSensor </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>widgetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sensorId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>ptrValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Measures the specified CSD sensor / CSX electrode capacitance in femtofarads. </p>
<p>This function measures the capacitance of the sensor (electrode for CSX widgets) and returns the measurement status. For a CSX sensor, the measurement is done on either Rx or Tx electrode. For a CSD sensor, measurement is done on a sensor (refer to the sensorId parameter description). If the specified sensor (electrode) is a ganged sensor, the capacitance is measured for all the pins ganged together that belong to this sensor (electrode).</p>
<p>The measured capacitance is stored in the .eltdCap[] array. The .ptrEltdCapacitance field of the <a class="el" href="structcy__stc__capsense__widget__config__t.html">cy_stc_capsense_widget_config_t</a> structure contains a pointer to the first widget sensor (electrode) element within the .eltdCap[] array.</p>
<p>In addition to the measuring sensor (electrode) capacitance, this function is used to identify various fault conditions with sensors such as electrically-opened or -shorted sensors. For example, the PCB track is broken or shorted to other nodes in the system - in all of these conditions, this function returns changed capacitance which can be compared against predetermined capacitance for the sensor to detect a fault condition.</p>
<p>The sensor capacitance is measured independently of the sensor scan configuration. For the capacitance measurement, the CSD sensing method is used. The measurements consists of up to four scans with different IDAC current. The IDAC current of the first measurement is 6 uA and each next measurement the IDAC current increase by four times. The default scanning parameters are the following:</p><ul>
<li>I (6 uA) is the current equal to IDAC Gain * IDAC Code (Compensation IDAC is disabled).</li>
<li>Res (12 bits) is the scanning resolution.</li>
<li>Vref (1.2 V) is the reference voltage.</li>
<li>SnsClk (375 kHz) is the sensor clock frequency.</li>
</ul>
<p>If the scanning raw count is within 7.5% to 45% range of a maximum raw count the raw count is converted into capacitance using the following equation:</p>
<p>Cs = Rawcount * I / ((2^Res - 1) * Vref * SnsClk)</p>
<p>where:</p><ul>
<li>Cs is the sensor capacitance.</li>
<li>Rawcount is the measured raw count value.</li>
</ul>
<p>If the raw count is less than 7.5% of the maximum limit (2^Res - 1), the function stops scanning the sequence and returns the CY_CAPSENSE_BIST_LOW_LIMIT_E status.</p>
<p>If the raw count is between 7.5% and 45% of the maximum, the function calculates the sensor capacitance, updates the register map and returns CY_CAPSENSE_BIST_SUCCESS_E status.</p>
<p>If the raw count is above 45% of the maximum, the function repeats scanning with a 4x increased IDAC current (up to four scans in total).</p>
<p>The minimum measurable input by this function is 1pF and the maximum is either 384pF or limited by the RC time constant (Cs &lt; 1 / (2*5*SnsClk*R), where R is the total sensor series resistance that includes on-chip GPIO resistance ~500 Ohm and external series resistance). The measurement accuracy is about 15%.</p>
<p>By default, all CAPSENSE&trade; sensors (electrodes) inherit regular scanning configuration. For example if the Inactive sensor connection parameter of the CSD sensing method is set to GND, sensors that are not being measured are set to the GND state. The inactive state can be changed in run-time by using the <a class="el" href="group__group__capsense__low__level.html#ga760c8b9c8e17b5c9689bf9305a34e393" title="Sets a desired state for all inactive CAPSENSE™-related electrodes for CSD, CSX, ISX scans...">Cy_CapSense_SetInactiveElectrodeState()</a> function.</p>
<p>By default, the Cmod capacitor is used for the measurement. If a dedicated Cmod is not available (e.g. the design has CSX widgets only), CintA and CintB capacitors are combined together by the firmware to form a single integration capacitor for the measurement.</p>
<p>The sensor measurement can be done on all the sensors using the <a class="el" href="group__group__capsense__high__level.html#gab1f1514db0566e14ba20fd8647ecb3ad" title="Runs built-in self-tests specified by the test enable mask. ">Cy_CapSense_RunSelfTest()</a> function along with the CY_CAPSENSE_BIST_SNS_CAP_MASK mask.</p>
<p>This function must not be called while the CSD HW block is busy by another state.</p>
<dl class="section note"><dt>Note</dt><dd>This function is available only for the fourth-generation CAPSENSE&trade;.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">widgetId</td><td>Specifies the ID number of the widget. A macro for the widget ID can be found in the CAPSENSE&trade; Configuration header file (cycfg_capsense.h) defined as CY_CAPSENSE_&lt;WidgetName&gt;_WDGT_ID.</td></tr>
    <tr><td class="paramname">sensorId</td><td>Specifies the ID of the sensor (electrode for CSX widgets) within the widget to be measured.</td></tr>
  </table>
  </dd>
</dl>
<p>For the CSD widgets, a macro for the sensor ID within the specified widget can be found in the CAPSENSE&trade; Configuration header file (cycfg_capsense.h) defined as CY_CAPSENSE_&lt;WidgetName&gt;_SNS&lt;SensorNumber&gt;_ID.</p>
<p>For the CSX widgets, sensorId is an electrode ID and is defined as Rx ID or Tx ID. The first Rx in a widget corresponds to electrodeId = 0, the second Rx in a widget corresponds to electrodeId = 1, and so on. The last Tx in a widget corresponds to electrodeId = (RxNum + TxNum - 1). Macros for Rx and Tx IDs can be found in the CAPSENSE&trade; Configuration header file (cycfg_capsense.h) defined as:</p><ul>
<li>CapSense_&lt;WidgetName&gt;_RX&lt;RXNumber&gt;_ID</li>
<li>CapSense_&lt;WidgetName&gt;_TX&lt;TXNumber&gt;_ID.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrValue</td><td>The pointer to the measured capacitance in femtofarads. The user declares a variable of the uint32_t type and passes the variable pointer as the function parameter. If the ptrValue parameter is NULL, the capacitance value is not returned through the parameter but still stored in the corresponding field of the data structure.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a status of the test execution:<ul>
<li>CY_CAPSENSE_BIST_SUCCESS_E - The measurement completes successfully, the result is valid.</li>
<li>CY_CAPSENSE_BIST_BAD_PARAM_E - The input parameter is invalid. The measurement was not executed.</li>
<li>CY_CAPSENSE_BIST_HW_BUSY_E - The CSD HW block is busy with a previous operation. The measurement was not executed.</li>
<li>CY_CAPSENSE_BIST_LOW_LIMIT_E - The measurement was executed and the scanning result is below the minimum possible value. The measurement result could be invalid. The sensor might be shorted to VDD or a sensor PCB track was broken (open sensor).</li>
<li>CY_CAPSENSE_BIST_HIGH_LIMIT_E - The measurement was executed and the scanning result is above the maximum possible value. The measurement result could be invalid. The sensor might be shorted to GND.</li>
<li>CY_CAPSENSE_BIST_ERROR_E - An unexpected fault occurred during the measurement. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gacc9c800180cd40a8ca3e53321d6a249b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc9c800180cd40a8ca3e53321d6a249b">&#9670;&nbsp;</a></span>Cy_CapSense_MeasureCapacitanceShield()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__enums.html#gafbe67572b1e6a637676b0a6e1040857c">cy_en_capsense_bist_status_t</a> Cy_CapSense_MeasureCapacitanceShield </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>ptrValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Measures shield electrode capacitance in femtofarads. </p>
<p>This function measures the capacitance of the shield electrode and returns a status of this measurement. The measurement result in femtofarads is stored in the .shieldCap field of the <a class="el" href="structcy__stc__capsense__bist__context__t.html">cy_stc_capsense_bist_context_t</a> structure. If the shield consists of several electrodes, the total capacitance of all shield electrodes is reported.</p>
<p>This function uses an algorithm identical to the sensor capacitance measurement. Refer to the <a class="el" href="group__group__capsense__low__level.html#ga3bf9894c313d4ffce1be841141d6b8e5" title="Measures the specified CSD sensor / CSX electrode capacitance in femtofarads. ">Cy_CapSense_MeasureCapacitanceSensor()</a> function for more details.</p>
<p>In addition to measuring shield capacitance, this function is used to identify various fault conditions with a shield electrode such as an electrically-open or -short shield electrode, e.g. the PCB track is broken or shorted to other nodes in the system - in all of these conditions, this function returns changed capacitance that can be compared against pre-determined capacitance for the shield electrode to detect a fault condition.</p>
<p>By default, all CAPSENSE&trade; sensors (electrodes) inherit regular scanning configuration. For example if the Inactive sensor connection parameter of the CSD sensing method is set to GND, sensors that are not being measured are set to the GND state. The inactive state can be changed in run-time by using the <a class="el" href="group__group__capsense__low__level.html#ga760c8b9c8e17b5c9689bf9305a34e393" title="Sets a desired state for all inactive CAPSENSE™-related electrodes for CSD, CSX, ISX scans...">Cy_CapSense_SetInactiveElectrodeState()</a> function. When the inactive sensor (electrode) connection is set to the CY_CAPSENSE_SNS_CONNECTION_SHIELD state, all the CAPSENSE&trade; electrodes are connected to the shield and the total capacitance are measured.</p>
<p>By default, the Cmod capacitor is used for the measurement. If a dedicated Cmod is not available (e.g. the design has CSX widgets only), CintA and CintB capacitors are combined together by the firmware to form a single integration capacitor which is used for measurement.</p>
<p>This test can be executed using the CapSense_RunSelfTest() function with the CY_CAPSENSE_BIST_SHIELD_CAP_MASK mask.</p>
<dl class="section note"><dt>Note</dt><dd>This function is available only for the fourth-generation CAPSENSE&trade;.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrValue</td><td>The pointer to the variable the measured capacitance is stored. The user should declare a variable of uint32_t type and pass the variable pointer as the function parameter. If the ptrValue parameter is NULL then the shield capacitance value is not returned through the parameter but is still stored in the .shieldCap field of the <a class="el" href="structcy__stc__capsense__bist__context__t.html">cy_stc_capsense_bist_context_t</a> structure.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a status of the test execution:<ul>
<li>CY_CAPSENSE_BIST_SUCCESS_E - The measurement completes successfully, the result is valid.</li>
<li>CY_CAPSENSE_BIST_BAD_PARAM_E - The input parameter is invalid. The measurement was not executed.</li>
<li>CY_CAPSENSE_BIST_HW_BUSY_E - The CSD HW block is busy with a previous operation. The measurement was not executed.</li>
<li>CY_CAPSENSE_BIST_LOW_LIMIT_E - The measurement was executed but the measured raw count is below the minimum possible value. The measurement result could be invalid. The shield might be shorted to VDD or a shield PCB track is broken (the open shield electrode).</li>
<li>CY_CAPSENSE_BIST_HIGH_LIMIT_E - The measurement was executed but the measured raw count is above the maximum possible value. The measurement result is invalid. The sensor might be shorted to GND.</li>
<li>CY_CAPSENSE_BIST_ERROR_E - An unexpected fault occurred during the measurement. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga3a30f2e4cdef59eab57f589b0091d937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a30f2e4cdef59eab57f589b0091d937">&#9670;&nbsp;</a></span>Cy_CapSense_CalibrateAllWidgets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_CalibrateAllWidgets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes CapDAC/IDAC auto-calibration for all the sensors in all widgets of some sensing groups (CSD, CSX, or ISX) if calibration is enabled for such group of widgets. </p>
<p>The auto-calibration finds CapDAC/IDAC values to have raw counts close to configured target values. Use sensing and processing functions after auto-calibration to update all baselines and configured filters.</p>
<p>Having enabled the CDAC auto-calibration algorithm is the most common use case. It helps to tune your system considering board-to-board variation, temperature drift, etc. CDAC auto-calibration is enabled by default.</p>
<p>The default auto-calibration target values are defined as:</p><ul>
<li>85% of the maximum raw count for CSD widgets</li>
<li>40% of the maximum raw count for CSX widgets.</li>
<li>40% of the maximum raw count for ISX widgets.</li>
</ul>
<p>Use the <a class="el" href="group__group__capsense__low__level.html#ga2f9c2fe584e7038a923d28bf445205ee" title="Sets the CapDAC auto-calibration raw count target for CSD, CSX or ISX widgets. ">Cy_CapSense_SetCalibrationTarget()</a> function to change calibration targets .</p>
<p>For fifth-generation low power CAPSENSE&trade; the function calibrates only Active widgets. For Low Power widgets use the <a class="el" href="group__group__capsense__low__level.html#ga5977d1af9e19f447f861bb9919afb30a" title="Executes CapDAC auto-calibration for all relevant low power widgets if enabled. ">Cy_CapSense_CalibrateAllLpWidgets()</a> function.</p>
<p>This function detects the sensing method used by each widget and performs a successive approximation search algorithm to find the appropriate Reference and Compensation CapDAC (if enabled) values for all sensors for the fifth-generation CAPSENSE&trade; and for all Active sensors for the fifth-generation low power CAPSENSE&trade;. For the fifth-generation low power CAPSENSE&trade; if during the calibration process it is reached the Reference CapDAC value lower than /ref CY_CAPSENSE_CAL_REF_CDAC_MIN_CODE and Fine CapDAC usage is enabled in CAPSENSE&trade; Configurator then the FineCDAC calibration is performed with the reference CDAC value set to 0.</p>
<p>For the the forth-generation CAPSENSE&trade; the function finds appropriate modulator and compensation IDAC (if enabled) values for all sensors in CSD widgets and/or IDAC values for all sensors in CSX widgets to make sensor raw count to the default value level.</p>
<p>This function could be used only if Enable auto-calibration parameter is enabled for CSD and/or CSX (and/or ISX for fifth-generation low power CAPSENSE&trade;) widgets.</p>
<dl class="section note"><dt>Note</dt><dd>For the fifth-generation CAPSENSE&trade; this function is available in single-channel solution. It is recommended to use the <a class="el" href="group__group__capsense__low__level.html#ga1130ee418f843fce4e68832efa37e28f" title="Executes CapDAC/IDAC auto-calibration for all the sensors in all widgets of some sensing groups (CSD...">Cy_CapSense_CalibrateAllSlots()</a> function instead for compatibility with further CAPSENSE&trade; middleware versions.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the operation <a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>. </dd></dl>

</div>
</div>
<a id="ga1130ee418f843fce4e68832efa37e28f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1130ee418f843fce4e68832efa37e28f">&#9670;&nbsp;</a></span>Cy_CapSense_CalibrateAllSlots()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_CalibrateAllSlots </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes CapDAC/IDAC auto-calibration for all the sensors in all widgets of some sensing groups (CSD, CSX, or ISX) if calibration is enabled for such group of widgets. </p>
<p>The auto-calibration finds CapDAC/IDAC values to have raw counts close to configured target values. Use sensing and processing functions after auto-calibration to update all baselines and configured filters.</p>
<p>Having enabled the CDAC auto-calibration algorithm is the most common use case. It helps to tune your system considering board-to-board variation, temperature drift, etc. CDAC auto-calibration is enabled by default.</p>
<p>For fifth-generation low power CAPSENSE&trade; the function calibrates only Active widgets. For Low Power widgets use the <a class="el" href="group__group__capsense__low__level.html#ga5977d1af9e19f447f861bb9919afb30a" title="Executes CapDAC auto-calibration for all relevant low power widgets if enabled. ">Cy_CapSense_CalibrateAllLpWidgets()</a> function.</p>
<p>The function performs searching of Reference CDAC code, Compensation CDAC code Compensation Divider (whichever is enabled) by using a successive approximation method to make the sensor's raw count closest to the defined targets. The auto-calibration target values are defined (by default) as:</p><ul>
<li>85% of the maximum raw count for CSD widgets</li>
<li>40% of the maximum raw count for CSX widgets.</li>
<li>40% of the maximum raw count for ISX widgets.</li>
</ul>
<p>Use the <a class="el" href="group__group__capsense__low__level.html#ga2f9c2fe584e7038a923d28bf445205ee" title="Sets the CapDAC auto-calibration raw count target for CSD, CSX or ISX widgets. ">Cy_CapSense_SetCalibrationTarget()</a> function to change calibration targets .</p>
<p>For the fifth-generation low power CAPSENSE&trade; if during the calibration process it is reached the Reference CapDAC value lower than /ref CY_CAPSENSE_CAL_REF_CDAC_MIN_CODE and Fine CapDAC usage is enabled in CAPSENSE&trade; Configurator then the FineCDAC calibration is performed with the reference CDAC value set to 0.</p>
<dl class="section note"><dt>Note</dt><dd>This function is available for the fifth-generation CAPSENSE&trade; and fifth-generation low power CAPSENSE&trade;.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the operation:<ul>
<li>CY_CAPSENSE_STATUS_SUCCESS - The operation is performed successfully.</li>
<li>CY_CAPSENSE_STATUS_BAD_PARAM - The input parameter is invalid.</li>
<li>CY_CAPSENSE_STATUS_CALIBRATION_FAIL - The calibration is failed due to the issues with scanning (either watchdog timer, interrupt breaking, etc.).</li>
<li>CY_CAPSENSE_STATUS_CALIBRATION_REF_CHECK_FAIL - The reference/fine CapDAC calibration stage is failed as the raw count minimum across widget is out of range.</li>
<li>CY_CAPSENSE_STATUS_CALIBRATION_CHECK_FAIL - The resulting rawcounts across all sensors in widget are out of defined range. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga2f9c2fe584e7038a923d28bf445205ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f9c2fe584e7038a923d28bf445205ee">&#9670;&nbsp;</a></span>Cy_CapSense_SetCalibrationTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_SetCalibrationTarget </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>calibrTarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>snsMethod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the CapDAC auto-calibration raw count target for CSD, CSX or ISX widgets. </p>
<p>The function only updates the target value, use <a class="el" href="group__group__capsense__low__level.html#ga889e60b9ca2470b37b37c772558f44ad" title="Executes the CapDAC/IDAC calibration for all the sensors in the specified widget to the default targe...">Cy_CapSense_CalibrateWidget()</a> / <a class="el" href="group__group__capsense__low__level.html#ga3a30f2e4cdef59eab57f589b0091d937" title="Executes CapDAC/IDAC auto-calibration for all the sensors in all widgets of some sensing groups (CSD...">Cy_CapSense_CalibrateAllWidgets()</a> / <a class="el" href="group__group__capsense__low__level.html#ga5977d1af9e19f447f861bb9919afb30a" title="Executes CapDAC auto-calibration for all relevant low power widgets if enabled. ">Cy_CapSense_CalibrateAllLpWidgets()</a> / <a class="el" href="group__group__capsense__low__level.html#ga1130ee418f843fce4e68832efa37e28f" title="Executes CapDAC/IDAC auto-calibration for all the sensors in all widgets of some sensing groups (CSD...">Cy_CapSense_CalibrateAllSlots()</a> to change raw counts according to the updated target.</p>
<p>The function sets the specified raw count targets if CSD, CSX and/or ISX widgets are in the project and the auto-calibration is enabled for them. These targets will be used instead the configured ones by <a class="el" href="group__group__capsense__low__level.html#ga1130ee418f843fce4e68832efa37e28f" title="Executes CapDAC/IDAC auto-calibration for all the sensors in all widgets of some sensing groups (CSD...">Cy_CapSense_CalibrateAllSlots()</a>, <a class="el" href="group__group__capsense__low__level.html#ga3a30f2e4cdef59eab57f589b0091d937" title="Executes CapDAC/IDAC auto-calibration for all the sensors in all widgets of some sensing groups (CSD...">Cy_CapSense_CalibrateAllWidgets()</a> and <a class="el" href="group__group__capsense__low__level.html#ga889e60b9ca2470b37b37c772558f44ad" title="Executes the CapDAC/IDAC calibration for all the sensors in the specified widget to the default targe...">Cy_CapSense_CalibrateWidget()</a> functions.</p>
<dl class="section note"><dt>Note</dt><dd>This function is available only for the fifth-generation CAPSENSE&trade; and fifth-generation low power CAPSENSE&trade;.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">calibrTarget</td><td>The raw counts target in percentage for the specified sensing method. It should be in range [1..99]. If the specified target is outside the range, then it will not be updated and the CY_CAPSENSE_STATUS_BAD_PARAM status will be returned.</td></tr>
    <tr><td class="paramname">snsMethod</td><td>Desired sensing method the calibration target should be updated for:<ul>
<li>CY_CAPSENSE_CSD_GROUP - CSD sensing method</li>
<li>CY_CAPSENSE_CSX_GROUP - CSX sensing method</li>
<li>CY_CAPSENSE_ISX_GROUP - ISX sensing method</li>
</ul>
</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the operation:<ul>
<li>CY_CAPSENSE_STATUS_SUCCESS - The operation is performed successfully.</li>
<li>CY_CAPSENSE_STATUS_BAD_PARAM - At least one of the input parameter is invalid. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga889e60b9ca2470b37b37c772558f44ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga889e60b9ca2470b37b37c772558f44ad">&#9670;&nbsp;</a></span>Cy_CapSense_CalibrateWidget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_CalibrateWidget </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>widgetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the CapDAC/IDAC calibration for all the sensors in the specified widget to the default target value. </p>
<p>This function performs exactly the same tasks as <a class="el" href="group__group__capsense__low__level.html#ga3a30f2e4cdef59eab57f589b0091d937" title="Executes CapDAC/IDAC auto-calibration for all the sensors in all widgets of some sensing groups (CSD...">Cy_CapSense_CalibrateAllWidgets()</a>, but only for a specified widget. Use sensing and processing functions after auto-calibration to update all baselines and configured filters.</p>
<dl class="section note"><dt>Note</dt><dd>For the fifth-generation CAPSENSE&trade; this function is available in single-channel solution. It is recommended to use the <a class="el" href="group__group__capsense__low__level.html#ga1130ee418f843fce4e68832efa37e28f" title="Executes CapDAC/IDAC auto-calibration for all the sensors in all widgets of some sensing groups (CSD...">Cy_CapSense_CalibrateAllSlots()</a> function instead for compatibility with further CAPSENSE&trade; middleware versions.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">widgetId</td><td>Specifies the ID number of the widget. A macro for the widget ID can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;WIDGET_NAME&gt;_WDGT_ID.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the operation <a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>. </dd></dl>

</div>
</div>
<a id="gae3f80b48c2596c149ca0b392a9a3da62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3f80b48c2596c149ca0b392a9a3da62">&#9670;&nbsp;</a></span>Cy_CapSense_ScanSensor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_ScanSensor </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>widgetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sensorId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiates the scanning of the selected sensor in the widget. </p>
<p>If the middleware is busy, do not initiate a new scan or set up widgets. Use the <a class="el" href="group__group__capsense__high__level.html#ga7f8739755bba6b51c274f45b569b9ba0" title="This function returns a status whether MW executes HW scanning at a particular moment. ">Cy_CapSense_IsBusy()</a> function to check HW busyness at a particular moment. Use the <a class="el" href="group__group__capsense__high__level.html#ga1530a032b2c5239f7efde29fa23d1793" title="Returns a detailed state of the CAPSENSE™ middleware and MSC and MSCLP HW blocks in Single- or Multi...">Cy_CapSense_MwState()</a> function to verify if MW executes any firmware tasks related to initialization, scanning, and processing at a particular moment.</p>
<dl class="section note"><dt>Note</dt><dd>For the fifth-generation CAPSENSE&trade; this function is available in single-channel solution. It is recommended to use the <a class="el" href="group__group__capsense__high__level.html#gaf10ce0cc817442374d2df04c9d241f9b" title="Initiates the non-blocking scan of a specified regular slots set named &quot;frame&quot; and then exits...">Cy_CapSense_ScanSlots()</a> function instead for compatibility with further CAPSENSE&trade; middleware versions.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">widgetId</td><td>Specifies the ID number of the widget. A macro for the widget ID can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;WIDGET_NAME&gt;_WDGT_ID.</td></tr>
    <tr><td class="paramname">sensorId</td><td>Specifies the ID number of the sensor within the widget. A macro for the sensor ID within a specified widget can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;WIDGET_NAME&gt;_SNS&lt;SENSOR_NUMBER&gt;_ID.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the operation <a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>. </dd></dl>

</div>
</div>
<a id="gaf51fd91df09631045f83396237395777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf51fd91df09631045f83396237395777">&#9670;&nbsp;</a></span>Cy_CapSense_SetPinState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_SetPinState </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>widgetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sensorElement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the state (drive mode and HSIOM state) of the GPIO used by a sensor. </p>
<p>The possible states are GND, Shield, High-Z, Tx, Negative Tx, Rx, and Sensor. If the sensor specified in the input parameter is a ganged sensor, then the state of all GPIOs associated with the ganged sensor is updated.</p>
<p>To access a sensor of CSD of button or slider widgets, use the sensor ID. To access a sensor of CSD matrix button or touchpad widgets, use either row ID or column ID as appropriate. To access sensor CSX widgets, use either Rx ID or Tx ID as appropriate.</p>
<p>This function accepts the CY_CAPSENSE_SHIELD and CY_CAPSENSE_SENSOR states as an input only if there is at least one CSD widget in the project. Similarly, this function accepts the CY_CAPSENSE_TX_PIN and CY_CAPSENSE_RX_PIN states as an input only if there is at least one CSX widget in the project.</p>
<p>This function must not be called while the middleware is in the busy state. Calling this function directly from the application program is not recommended. This function is used to implement only the custom-specific use cases.</p>
<p>Functions that perform a setup and scan of a sensor/widget automatically set the required pin states for a sensor as required and overwrite changes made by this function to a sensor that are going to be scanned. Therefore the <a class="el" href="group__group__capsense__low__level.html#gaf51fd91df09631045f83396237395777" title="Sets the state (drive mode and HSIOM state) of the GPIO used by a sensor. ">Cy_CapSense_SetPinState()</a> function should be called in StartSample callback (see the <a class="el" href="group__group__capsense__callbacks.html">Callbacks</a> section for details) or with low-level functions that perform a single-sensor scanning.</p>
<dl class="section note"><dt>Note</dt><dd>The function is available for the fourth-generation and fifth-generation (only for CY_CAPSENSE_AMUX_SENSOR_CONNECTION_METHOD) CAPSENSE&trade;. For fifth-generation CAPSENSE&amp;trade with CY_CAPSENSE_CTRLMUX_SENSOR_CONNECTION_METHOD and for fifth- generation low power CAPSENSE&amp;trade use <a class="el" href="group__group__capsense__low__level.html#ga5d8f778457e13ccfa3f34239aef25f47" title="Configures the specified electrode to the desired state in the specified slot (Active slot for fifth-...">Cy_CapSense_SlotPinState()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">widgetId</td><td>Specifies the ID number of the widget. A macro for the widget ID can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;WIDGET_NAME&gt;_WDGT_ID.</td></tr>
    <tr><td class="paramname">sensorElement</td><td>Specifies the ID of the sensor element within the widget to change its pin state.<ul>
<li>For the CSD widgets use the sensor ID. A macro for the sensor ID within a specified widget can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;WIDGET_NAME&gt;_SNS&lt;SENSOR_NUMBER&gt;_ID.</li>
<li>For the CSX widgets use either Rx ID or Tx ID. The first Rx in a widget corresponds to sensorElement = 0; the second Rx in a widget corresponds to sensorElement = 1, and so on. The last Tx in a widget corresponds to sensorElement = (RxNum + TxNum - 1). A macro for the Rx ID or Tx ID can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;WIDGET_NAME&gt;_&lt;TX/RX&gt;&lt;TX/RX_NUMBER&gt;_ID.</li>
</ul>
</td></tr>
    <tr><td class="paramname">state</td><td>Specifies the state of the sensor to be set:<ol type="1">
<li>CY_CAPSENSE_GROUND - The pin is connected to the ground.</li>
<li>CY_CAPSENSE_HIGHZ - The drive mode of the pin is set to High-Z Analog.</li>
<li>CY_CAPSENSE_SHIELD - The shield signal is routed to the pin (available only if CSD sensing method with shield electrode is enabled).</li>
<li>CY_CAPSENSE_SENSOR - The pin is connected to the scanning bus (available only if CSD sensing method is enabled).</li>
<li>CY_CAPSENSE_TX_PIN - The Tx signal is routed to the sensor (available only if CSX sensing method is enabled).</li>
<li>CY_CAPSENSE_RX_PIN - The pin is connected to the scanning bus (available only if CSX sensing method is enabled).</li>
<li>CY_CAPSENSE_NEGATIVE_TX_PIN - The Negative Tx signal is routed to the sensor (available only if CSD sensing method is enabled).</li>
</ol>
</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status Returns the operation status:<ul>
<li>CY_CAPSENSE_STATUS_SUCCESS - Indicates the successful electrode setting.</li>
<li>CY_CAPSENSE_STATUS_BAD_PARAM - 1) widgetID, sensorElement or state are not valid; 2) the CSD sensing method is disabled for desired CY_CAPSENSE_SHIELD or CY_CAPSENSE_SENSOR states; 3) the CSX sensing method is disabled for desired CY_CAPSENSE_TX_PIN, CY_CAPSENSE_NEGATIVE_TX_PIN or CY_CAPSENSE_RX_PIN states.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd>An example of using the <a class="el" href="group__group__capsense__low__level.html#gaf51fd91df09631045f83396237395777" title="Sets the state (drive mode and HSIOM state) of the GPIO used by a sensor. ">Cy_CapSense_SetPinState()</a> function to perform sensor state re-configuration: <div class="fragment"><div class="line"></div><div class="line">        <span class="comment">/*...*/</span></div><div class="line"><span class="preprocessor">        #if (CY_CAPSENSE_PLATFORM_BLOCK_FOURTH_GEN)</span></div><div class="line">            <a class="code" href="group__group__capsense__low__level.html#gaf43c0cf61a95f11a5981f82f5b0d4e86">Cy_CapSense_SetupWidgetExt</a>(CY_CAPSENSE_TOUCHPAD0_WDGT_ID, 0u, &amp;cy_capsense_context);</div><div class="line"><span class="preprocessor">        #endif</span></div><div class="line"></div><div class="line">        <span class="comment">/* This call changes the touchpad 0u sensor 1u electrode state to HIGH-Z */</span></div><div class="line">        <a class="code" href="group__group__capsense__low__level.html#gaf51fd91df09631045f83396237395777">Cy_CapSense_SetPinState</a>(CY_CAPSENSE_TOUCHPAD0_WDGT_ID, 1u, <a class="code" href="group__group__capsense__macros__pin.html#gaead707fb888468852d35412af119f66e">CY_CAPSENSE_HIGHZ</a>, &amp;cy_capsense_context);</div><div class="line"></div><div class="line">        <span class="comment">/* This call starts the touchpad 0u sensor 0u scan with the state of the sensor 1u set to HIGH-Z */</span></div><div class="line">        <a class="code" href="group__group__capsense__low__level.html#gae3f80b48c2596c149ca0b392a9a3da62">Cy_CapSense_ScanSensor</a>(CY_CAPSENSE_TOUCHPAD0_WDGT_ID, 0u, &amp;cy_capsense_context);</div><div class="line">        <span class="keywordflow">while</span> (<a class="code" href="group__group__capsense__macros__mw__state.html#ga1bd45eed2be393b7f53c20f1bae2814e">CY_CAPSENSE_NOT_BUSY</a> != <a class="code" href="group__group__capsense__high__level.html#ga7f8739755bba6b51c274f45b569b9ba0">Cy_CapSense_IsBusy</a>(&amp;cy_capsense_context)){}</div><div class="line"></div><div class="line">        <span class="comment">/* This call restores the sensor 1u state to GROUND */</span></div><div class="line">        <a class="code" href="group__group__capsense__low__level.html#gaf51fd91df09631045f83396237395777">Cy_CapSense_SetPinState</a>(CY_CAPSENSE_TOUCHPAD0_WDGT_ID, 1u, <a class="code" href="group__group__capsense__macros__pin.html#gad966154287c77eb6cc738db7f4d1da08">CY_CAPSENSE_GROUND</a>, &amp;cy_capsense_context);</div><div class="line">        <span class="comment">/*...*/</span></div><div class="line"></div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga5d8f778457e13ccfa3f34239aef25f47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d8f778457e13ccfa3f34239aef25f47">&#9670;&nbsp;</a></span>Cy_CapSense_SlotPinState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_SlotPinState </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>slotId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__stc__capsense__electrode__config__t.html">cy_stc_capsense_electrode_config_t</a> *&#160;</td>
          <td class="paramname"><em>ptrEltdCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pinState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures the specified electrode to the desired state in the specified slot (Active slot for fifth-generation low power CAPSENSE&trade;) by updating the CAPSENSE&trade; configuration. </p>
<p>This function changes / overwrites configuration of an electrode (several pins in case the electrode is ganged to more pins) with a state specified by the pinState parameter. The function does this only for the specified slot ID (Active slotID for fifth-generation low power CAPSENSE&trade;). If the electrode should have the desired state during scans in another slots, the function should be called multiple times for each desired slot (Active slot for fifth-generation low power CAPSENSE&trade;).</p>
<p>The function call changes the pin states permanently and all further scans of the slot will have the electrode state as specified by the pinState parameter. Call the function again to change the electrode state to a new desired one or reinitialize CAPSENSE&trade; middleware by using the <a class="el" href="group__group__capsense__high__level.html#gade28f1f915ce6b97f13399074a819c0d" title="Initializes the CAPSENSE™ firmware modules. ">Cy_CapSense_Enable()</a> function.</p>
<p>The re-configuration is available only when parameter Sensor connection method = CTRLMUX. If parameter Sensor connection method = AMUXBUS, then the <a class="el" href="group__group__capsense__low__level.html#gaf51fd91df09631045f83396237395777" title="Sets the state (drive mode and HSIOM state) of the GPIO used by a sensor. ">Cy_CapSense_SetPinState()</a> function should be used.</p>
<p>The function changes the configuration of an electrode without storing the previous state. A user is responsible to keep the previous state to revert to the default settings if needed. Also, the default settings can be configured again by calling <a class="el" href="group__group__capsense__high__level.html#gade28f1f915ce6b97f13399074a819c0d" title="Initializes the CAPSENSE™ firmware modules. ">Cy_CapSense_Enable()</a> function that leads to repeating CAPSENSE&trade; Data Structure initialization, DAC auto-calibration, and baseline initialization.</p>
<p>Using the function is recommended only for advanced users for specific use cases. For instance, to change the CAPSENSE&trade; default electrode configuration, the function could be called by using a CAPSENSE&trade; Data Structure Initialization callback ptrEODsInitCallback. For details of how to register the callback see the <a class="el" href="group__group__capsense__callbacks.html">Callbacks</a> section. That avoids repeating of DAC auto-calibration and baseline initialization since the callback is called after CAPSENSE&trade; Data Structure initialization but before the first initialization scan.</p>
<p>You can also use this function to change the shield electrode state - call the function and pass the pointer to the shield electrode configuration as an input parameter.</p>
<dl class="section note"><dt>Note</dt><dd>This function is available for the fifth-generation (only for CY_CAPSENSE_CTRLMUX_SENSOR_CONNECTION_METHOD) and fifth-generation low power CAPSENSE&trade;. For fourth-generation CAPSENSE&amp;trade and fifth-generation CAPSENSE&amp;trade with for CY_CAPSENSE_AMUX_SENSOR_CONNECTION_METHOD use <a class="el" href="group__group__capsense__low__level.html#gaf51fd91df09631045f83396237395777" title="Sets the state (drive mode and HSIOM state) of the GPIO used by a sensor. ">Cy_CapSense_SetPinState()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slotId</td><td>The desired slot ID (Active slot ID for fifth-generation low power CAPSENSE&trade;).</td></tr>
    <tr><td class="paramname">ptrEltdCfg</td><td>The pointer to an electrode the all pins states of which will be configured as pinState parameter.</td></tr>
    <tr><td class="paramname">pinState</td><td>The desired pins state for CSX widget electrodes could be:<ul>
<li>CY_CAPSENSE_RX_PIN - Rx electrode</li>
<li>CY_CAPSENSE_TX_PIN - Tx electrode</li>
<li>CY_CAPSENSE_GROUND - Grounded</li>
<li>CY_CAPSENSE_NEGATIVE_TX_PIN - Negative Tx electrode (for multi-phase TX method)</li>
<li>CY_CAPSENSE_HIGHZ - Unconnected (High-Z)</li>
<li>CY_CAPSENSE_VDDA2 - Connected to VDDA/2.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>The desired pins state for CSD widget electrodes could be:</p><ul>
<li>CY_CAPSENSE_SENSOR - Self-cap sensor</li>
<li>CY_CAPSENSE_HIGHZ - Unconnected (High-Z)</li>
<li>CY_CAPSENSE_GROUND - Grounded</li>
<li>CY_CAPSENSE_SHIELD - Shield is routed to the pin.</li>
</ul>
<p>The desired pins state for ISX widget electrodes could be:</p><ul>
<li>CY_CAPSENSE_ISX_RX_PIN - ISX Rx electrode</li>
<li>CY_CAPSENSE_ISX_LX_PIN - ISX Lx electrode</li>
<li>CY_CAPSENSE_HIGHZ - Unconnected (High-Z).</li>
<li>CY_CAPSENSE_GROUND - Grounded</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the operation:<ul>
<li>CY_CAPSENSE_STATUS_SUCCESS - Indicates the successful electrode setting.</li>
<li>CY_CAPSENSE_STATUS_BAD_CONFIG - The function does not suppose to be called with the current CAPSENSE&trade; configuration.</li>
<li>CY_CAPSENSE_STATUS_BAD_PARAM - 1) widgetID, sensorElement or state are not valid; 2) the CSD sensing method is disabled for desired CY_CAPSENSE_SHIELD or CY_CAPSENSE_SENSOR states; 3) the CSX sensing method is disabled for desired CY_CAPSENSE_TX_PIN, CY_CAPSENSE_NEGATIVE_TX_PIN or CY_CAPSENSE_RX_PIN states. 4) the ISX sensing method is disabled for desired CY_CAPSENSE_ISX_RX_PIN or CY_CAPSENSE_ISX_LX_PIN states (Only for fifth-generation low power CAPSENSE&trade;).</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Scenario: There is a need to set the pin state of the electrodeId of the widgetId for the first slot scan to</span></div><div class="line"><span class="comment">     * CY_CAPSENSE_GROUND</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    </div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__capsense__macros__status.html#ga83824bf450f79f26a70da2b619cd07c7">CY_CAPSENSE_STATUS_SUCCESS</a> != <a class="code" href="group__group__capsense__low__level.html#ga5d8f778457e13ccfa3f34239aef25f47">Cy_CapSense_SlotPinState</a>(0u,</div><div class="line">                                      &amp;cy_capsense_context.ptrWdConfig[widgetId].ptrEltdConfig[electrodeId],</div><div class="line">                                      <a class="code" href="group__group__capsense__macros__pin.html#gad966154287c77eb6cc738db7f4d1da08">CY_CAPSENSE_GROUND</a>,</div><div class="line">                                      &amp;cy_capsense_context))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Insert the error handle code here, for instance as below */</span></div><div class="line">        CY_ASSERT(0u);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * This call starts scanning and the first slot is scanned with the electrodeId of the widgetId state set to GROUND while the rest</span></div><div class="line"><span class="comment">     * slots are scanned with electrodes are set to the initially configured inactive state</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__capsense__macros__status.html#ga83824bf450f79f26a70da2b619cd07c7">CY_CAPSENSE_STATUS_SUCCESS</a> != <a class="code" href="group__group__capsense__high__level.html#ga045f3f46ff4e43c4f4dbe087c0156f56">Cy_CapSense_ScanAllSlots</a>(&amp;cy_capsense_context))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Insert the error handle code here, for instance as below */</span></div><div class="line">        CY_ASSERT(0u);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">while</span> (<a class="code" href="group__group__capsense__macros__mw__state.html#ga1bd45eed2be393b7f53c20f1bae2814e">CY_CAPSENSE_NOT_BUSY</a> != <a class="code" href="group__group__capsense__high__level.html#ga7f8739755bba6b51c274f45b569b9ba0">Cy_CapSense_IsBusy</a>(&amp;cy_capsense_context)){}</div><div class="line"></div><div class="line">    <span class="comment">/*...*/</span></div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga760c8b9c8e17b5c9689bf9305a34e393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga760c8b9c8e17b5c9689bf9305a34e393">&#9670;&nbsp;</a></span>Cy_CapSense_SetInactiveElectrodeState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_SetInactiveElectrodeState </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>inactiveState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sensingGroup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a desired state for all inactive CAPSENSE&trade;-related electrodes for CSD, CSX, ISX scans, or BIST measurement scans. </p>
<p>Use the function to set/change the desired state of all CAPSENSE&trade;-related electrodes which are not scanned during regular scans or BIST capacitance measurements. There are separate states for the CSD sensing method group, the CSX sensing method group, the ISX sensing method group, the BIST CSD sensor (electrode) capacitance measurement, the BIST CSX sensor (electrode) capacitance measurement, and the BIST shield electrode capacitance measurement. For instance, it can be configured the GND state for all inactive sensors for CSX scanning and the High-Z state for CSD scanning and the Shield state for BIST CSD sensor (electrode) capacitance measurement. The function updates some corresponding parameters in the CAPSENSE&trade; Data Structure to provide the desired state and not changes pin state immediately. The desired state will be applied to all inactive electrodes during the CSD, CSX, ISX scans or BIST capacitance measurements. It is not recommended to update the Data Structure registers directly. Additionally (only for fifth-generation CAPSENSE&trade;), the function recalculates sensor frames in a case of the CTRLMUX sensor connection method. For fifth-generation low power CAPSENSE&trade;, the function always recalculates all sensor frames including low-power sensors.</p>
<dl class="section note"><dt>Note</dt><dd>ISX sensing method is only available for fifth-generation low power CAPSENSE&trade;.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inactiveState</td><td>Specifies the inactive CAPSENSE&trade; electrode state:<ul>
<li>CY_CAPSENSE_SNS_CONNECTION_HIGHZ</li>
<li>CY_CAPSENSE_SNS_CONNECTION_SHIELD (only for CSD scan)</li>
<li>CY_CAPSENSE_SNS_CONNECTION_GROUND</li>
<li>CY_CAPSENSE_SNS_CONNECTION_VDDA_BY_2 (only for CSX scan)</li>
</ul>
</td></tr>
    <tr><td class="paramname">sensingGroup</td><td>Specifies the sensing group:<ul>
<li>CY_CAPSENSE_CSD_GROUP</li>
<li>CY_CAPSENSE_CSX_GROUP</li>
<li>CY_CAPSENSE_ISX_GROUP</li>
<li>CY_CAPSENSE_WBX_GROUP</li>
<li>CY_CAPSENSE_BIST_CSD_GROUP</li>
<li>CY_CAPSENSE_BIST_CSX_GROUP</li>
<li>CY_CAPSENSE_BIST_SHIELD_GROUP</li>
</ul>
</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the operation <a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>. </dd></dl>

</div>
</div>
<a id="ga264c6bafda78c56a0d620a7c88363269"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga264c6bafda78c56a0d620a7c88363269">&#9670;&nbsp;</a></span>Cy_CapSense_ScanAbort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_ScanAbort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the sequencer to the idle state by resetting the hardware, it can be used to abort current scan. </p>
<dl class="section note"><dt>Note</dt><dd>This function is available for the fifth-generation CAPSENSE&trade; and fifth-generation low power CAPSENSE&trade;.</dd>
<dd>
If this function is called from ISR during initialization or auto-calibration the operation of these functions will be corrupted.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the operation <a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>. </dd></dl>

</div>
</div>
<a id="ga182defda982b92d1f098b5b74184ef55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga182defda982b92d1f098b5b74184ef55">&#9670;&nbsp;</a></span>Cy_CapSense_LpSlotPinState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_LpSlotPinState </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lpSlotId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__stc__capsense__electrode__config__t.html">cy_stc_capsense_electrode_config_t</a> *&#160;</td>
          <td class="paramname"><em>ptrEltdCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pinState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures the specified electrode to the desired state in the specified Low Power slot by updating the CAPSENSE&trade; configuration. </p>
<p>This function changes / overwrites configuration of an electrode (several pins in case the electrode is ganged to more pins) with a state specified by the pinState parameter. The function does this only for the specified Low Power slot ID. If the electrode should have the desired state during scans in another Low Power slots, the function should be called multiple times for each desired Low Power slot.</p>
<p>The function call changes the pin states permanently and all further scans of the slot will have the electrode state as specified by the pinState parameter. Call the function again to change the electrode state to a new desired one or reinitialize CAPSENSE&trade; middleware by using the <a class="el" href="group__group__capsense__high__level.html#gade28f1f915ce6b97f13399074a819c0d" title="Initializes the CAPSENSE™ firmware modules. ">Cy_CapSense_Enable()</a> function.</p>
<p>The function changes the configuration of an electrode without storing the previous state. A user is responsible to keep the previous state to revert to the default settings if needed. Also, the default settings can be configured again by calling <a class="el" href="group__group__capsense__high__level.html#gade28f1f915ce6b97f13399074a819c0d" title="Initializes the CAPSENSE™ firmware modules. ">Cy_CapSense_Enable()</a> function that leads to repeating CAPSENSE&trade; Data Structure initialization, DAC auto-calibration, and baseline initialization.</p>
<p>Using the function is recommended only for advanced users for specific use cases. For instance, to change the CAPSENSE&trade; default electrode configuration, the function could be called by using a CAPSENSE&trade; Data Structure Initialization callback ptrEODsInitCallback. For details of how to register the callback see the <a class="el" href="group__group__capsense__callbacks.html">Callbacks</a> section. That avoids repeating of DAC auto-calibration and baseline initialization since the callback is called after CAPSENSE&trade; Data Structure initialization but before the first initialization scan.</p>
<p>The function is a low-level function and does not perform an input parameter verification (like Low Power slot ID, pointers, etc.). For example, the CY_CAPSENSE_CTRLMUX_PIN_STATE_SHIELD pin state is not available if a shield is not configured in the project, but the function will set the pin state and the HW block behavior is unpredictable.</p>
<dl class="section note"><dt>Note</dt><dd>This function is available only for the fifth-generation low power CAPSENSE&trade;. For the fifth-generation (only for CY_CAPSENSE_CTRLMUX_SENSOR_CONNECTION_METHOD) and fifth-generation low power CAPSENSE&trade; Active slots use <a class="el" href="group__group__capsense__low__level.html#ga5d8f778457e13ccfa3f34239aef25f47" title="Configures the specified electrode to the desired state in the specified slot (Active slot for fifth-...">Cy_CapSense_SlotPinState()</a>. For fourth-generation CAPSENSE&amp;trade and fifth-generation CAPSENSE&amp;trade with CY_CAPSENSE_AMUX_SENSOR_CONNECTION_METHOD use <a class="el" href="group__group__capsense__low__level.html#gaf51fd91df09631045f83396237395777" title="Sets the state (drive mode and HSIOM state) of the GPIO used by a sensor. ">Cy_CapSense_SetPinState()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lpSlotId</td><td>The desired Low Power slot ID.</td></tr>
    <tr><td class="paramname">ptrEltdCfg</td><td>The pointer to an electrode the all pins states of which will be configured as pinState parameter.</td></tr>
    <tr><td class="paramname">pinState</td><td>The desired pins state for CSX widget electrodes could be:<ul>
<li>CY_CAPSENSE_RX_PIN - Rx electrode</li>
<li>CY_CAPSENSE_TX_PIN - Tx electrode</li>
<li>CY_CAPSENSE_GROUND - Grounded</li>
<li>CY_CAPSENSE_NEGATIVE_TX_PIN - Negative Tx electrode (for multi-phase TX method)</li>
<li>CY_CAPSENSE_HIGHZ - Unconnected (High-Z)</li>
<li>CY_CAPSENSE_VDDA2 - Connected to VDDA/2.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>The desired pins state for CSD widget electrodes could be:</p><ul>
<li>CY_CAPSENSE_SENSOR - Self-cap sensor</li>
<li>CY_CAPSENSE_HIGHZ - Unconnected (High-Z)</li>
<li>CY_CAPSENSE_GROUND - Grounded</li>
<li>CY_CAPSENSE_SHIELD - Shield is routed to the pin.</li>
</ul>
<p>The desired pins state for ISX widget electrodes could be:</p><ul>
<li>CY_CAPSENSE_ISX_RX_PIN - ISX Rx electrode</li>
<li>CY_CAPSENSE_ISX_LX_PIN - ISX Lx electrode</li>
<li>CY_CAPSENSE_HIGHZ - Unconnected (High-Z).</li>
</ul>
<p>The desired pins state for WBX widget electrodes:</p><ul>
<li>CY_CAPSENSE_PIN_STATE_WBX_NODE_A - Node A electrode.</li>
<li>CY_CAPSENSE_PIN_STATE_WBX_NODE_B - Node B electrode.</li>
<li>CY_CAPSENSE_PIN_STATE_IDX_HIGH_Z - Unconnected (high-z).</li>
<li>CY_CAPSENSE_PIN_STATE_IDX_GND - Grounded.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the operation:<ul>
<li>CY_CAPSENSE_STATUS_SUCCESS - The operation is performed successfully.</li>
<li>CY_CAPSENSE_STATUS_BAD_CONFIG - The function does not suppose to be called with the current CAPSENSE&trade; configuration.</li>
<li>CY_CAPSENSE_STATUS_BAD_PARAM - 1) lpSlotId, sensorElement or pinState are not valid; 2) the CSD sensing method is disabled for desired CY_CAPSENSE_SHIELD or CY_CAPSENSE_SENSOR states; 3) the CSX sensing method is disabled for desired CY_CAPSENSE_TX_PIN, CY_CAPSENSE_NEGATIVE_TX_PIN or CY_CAPSENSE_RX_PIN states. 4) the ISX sensing method is disabled for desired CY_CAPSENSE_ISX_RX_PIN or CY_CAPSENSE_ISX_LX_PIN states. 5) the WBX sensing method is disabled for desired CY_CAPSENSE_PIN_STATE_WBX_NODE_A or CY_CAPSENSE_PIN_STATE_WBX_NODE_B states.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: There is a need to set the pin state of the second slot</span></div><div class="line"><span class="comment">    of the cy_stc_capsense_context_t.ptrSensorFrameLpContext</span></div><div class="line"><span class="comment">    to CY_CAPSENSE_CTRLMUX_PIN_STATE_GND. */</span></div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__capsense__macros__status.html#ga83824bf450f79f26a70da2b619cd07c7">CY_CAPSENSE_STATUS_SUCCESS</a> != <a class="code" href="group__group__capsense__low__level.html#ga182defda982b92d1f098b5b74184ef55">Cy_CapSense_LpSlotPinState</a>(1u,</div><div class="line">                                     &amp;cy_capsense_context.ptrWdConfig[widgetId].ptrEltdConfig[electrodeId],</div><div class="line">                                      <a class="code" href="group__group__capsense__macros__settings.html#ga82511fe1c0a47b01076ed2ef0bd5497f">CY_CAPSENSE_CTRLMUX_PIN_STATE_HIGH_Z</a>,</div><div class="line">                                     &amp;cy_capsense_context))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Insert the error handle code here, for instance as below */</span></div><div class="line">        CY_ASSERT(0u);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * This call starts scanning all low power widgets and the second slot is scanned with the electrodeId</span></div><div class="line"><span class="comment">     * of the widgetId state set to GROUND while the rest low power</span></div><div class="line"><span class="comment">     * slots are scanned with electrodes are set to the initially configured inactive state</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__capsense__macros__status.html#ga83824bf450f79f26a70da2b619cd07c7">CY_CAPSENSE_STATUS_SUCCESS</a> != <a class="code" href="group__group__capsense__high__level.html#gadee29d98f13ef5b927b6ce418a2bba3f">Cy_CapSense_ScanAllLpSlots</a>(&amp;cy_capsense_context))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Insert the error handle code here, for instance as below */</span></div><div class="line">        CY_ASSERT(0u);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">while</span> (<a class="code" href="group__group__capsense__macros__mw__state.html#ga1bd45eed2be393b7f53c20f1bae2814e">CY_CAPSENSE_NOT_BUSY</a> != <a class="code" href="group__group__capsense__high__level.html#ga7f8739755bba6b51c274f45b569b9ba0">Cy_CapSense_IsBusy</a>(&amp;cy_capsense_context))</div><div class="line">    {</div><div class="line">        Cy_SysPm_CpuEnterDeepSleep();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/*...*/</span></div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga5977d1af9e19f447f861bb9919afb30a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5977d1af9e19f447f861bb9919afb30a">&#9670;&nbsp;</a></span>Cy_CapSense_CalibrateAllLpWidgets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_CalibrateAllLpWidgets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes CapDAC auto-calibration for all relevant low power widgets if enabled. </p>
<p>Having enabled the CDAC auto-calibration algorithm is the most common use case. It helps to tune your system considering board-to-board variation, temperature drift, etc. CDAC auto-calibration is enabled by default.</p>
<p>The function performs searching of Reference CDAC code, Compensation CDAC code, Compensation Divider (whichever is enabled) by using a successive approximation method to make the sensor's raw count closest to the defined targets. The auto-calibration target values are defined (by default) as:</p><ul>
<li>85% of the maximum raw count for CSD widgets</li>
<li>40% of the maximum raw count for CSX widgets.</li>
<li>40% of the maximum raw count for ISX widgets.</li>
</ul>
<p>To change calibration targets use the <a class="el" href="group__group__capsense__low__level.html#ga2f9c2fe584e7038a923d28bf445205ee" title="Sets the CapDAC auto-calibration raw count target for CSD, CSX or ISX widgets. ">Cy_CapSense_SetCalibrationTarget()</a> function.</p>
<dl class="section note"><dt>Note</dt><dd>This function is available only for the fifth-generation low power CAPSENSE&trade;.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the operation:<ul>
<li>CY_CAPSENSE_STATUS_SUCCESS - The operation is performed successfully.</li>
<li>CY_CAPSENSE_STATUS_BAD_PARAM - The input parameter is invalid.</li>
<li>CY_CAPSENSE_STATUS_CALIBRATION_FAIL - The calibration is failed due to the issues with scanning (either watchdog timer, interrupt breaking, etc.).</li>
<li>CY_CAPSENSE_STATUS_CALIBRATION_REF_CHECK_FAIL - The reference/fine CapDAC calibration stage is failed as the raw count minimum across widget is out of range.</li>
<li>CY_CAPSENSE_STATUS_CALIBRATION_CHECK_FAIL - The resulting rawcounts across all sensors in widget are out of defined range. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga5cebf3e9d41b7e874369d1a083ab88c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5cebf3e9d41b7e874369d1a083ab88c6">&#9670;&nbsp;</a></span>Cy_CapSense_CalibrateAllLpSlots()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_CalibrateAllLpSlots </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calibrates CapDACs for all Low power widgets. </p>
<p>The function is the wrapper for the <a class="el" href="group__group__capsense__low__level.html#ga5977d1af9e19f447f861bb9919afb30a" title="Executes CapDAC auto-calibration for all relevant low power widgets if enabled. ">Cy_CapSense_CalibrateAllLpWidgets()</a> function to provide the backward compatibility.</p>
<dl class="section note"><dt>Note</dt><dd>This function is available only for the fifth-generation low power CAPSENSE&trade;.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the operation:<ul>
<li>CY_CAPSENSE_STATUS_SUCCESS - The operation is performed successfully.</li>
<li>CY_CAPSENSE_STATUS_BAD_PARAM - The input parameter is invalid.</li>
<li>CY_CAPSENSE_STATUS_CALIBRATION_FAIL - The calibration failed if software watchdog timeout occurred during any calibration scan, the scan was not completed, or resulted raw counts are outside the limits. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga99c4c3b3a577706d47fb4b01ca8d29c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99c4c3b3a577706d47fb4b01ca8d29c0">&#9670;&nbsp;</a></span>Cy_CapSense_ScanInitializeHwIirAllSlots()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_ScanInitializeHwIirAllSlots </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes (or re-initializes) the hardware IIR filter for all slots. </p>
<p>This function initiates the blocking scan of all slots to initialize the hardware IIR filter. This should be done before firmware filters and baselines initialization.</p>
<p>Calling this function is accompanied by:</p><ul>
<li><a class="el" href="group__group__capsense__low__level.html#ga1fcb002d0216bb96ab818276954606e7" title="Initializes (or re-initializes) all the firmware filter history, except the baseline. ">Cy_CapSense_InitializeAllFilters()</a></li>
<li><a class="el" href="group__group__capsense__low__level.html#gaa35b107fb94a8c8ff6d53463c62d0481" title="Initializes the baselines of all the sensors of all active widgets. ">Cy_CapSense_InitializeAllBaselines()</a></li>
<li><a class="el" href="group__group__capsense__low__level.html#ga91d3ccdc21ed235f4e3b61a0a583c7a1" title="Performs initialization of all statuses and related modules including debounce counters and touch pos...">Cy_CapSense_InitializeAllStatuses()</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the operation:<ul>
<li>CY_CAPSENSE_STATUS_SUCCESS - The operation is performed successfully.</li>
<li>CY_CAPSENSE_STATUS_BAD_PARAM - The input parameter is invalid.</li>
<li>CY_CAPSENSE_STATUS_HW_BUSY - The HW is busy with the previous scan.</li>
<li>CY_CAPSENSE_STATUS_TIMEOUT - The software watchdog timeout occurred during the scan, the scan was not completed.</li>
<li>CY_CAPSENSE_STATUS_MIXED_SENSORS - The requested sensors types can't be scanned in one frame (in autonomous mode). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gac8445556444b88df5ecab63085e698c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac8445556444b88df5ecab63085e698c7">&#9670;&nbsp;</a></span>Cy_CapSense_ScanInitializeHwIirSlots()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_ScanInitializeHwIirSlots </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>startSlotId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numberSlots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes (or re-initializes) the hardware IIR filter for specified slots. </p>
<p>This function initiates the blocking scan of specified slots to initialize the hardware IIR filter. This should be done before firmware filters and baselines initialization.</p>
<p>Calling this function is accompanied by:</p><ul>
<li><a class="el" href="group__group__capsense__low__level.html#ga101174469c4b6a2df8d44bddb0e33fcf" title="Initializes (or re-initializes) the raw count filter history of all the sensors in a widget specified...">Cy_CapSense_InitializeWidgetFilter()</a></li>
<li><a class="el" href="group__group__capsense__low__level.html#ga6dd0e7c6db3f269948623d2e0fa0c2d7" title="Initializes the baselines of all the sensors in a specific widget. ">Cy_CapSense_InitializeWidgetBaseline()</a></li>
<li><a class="el" href="group__group__capsense__low__level.html#ga0cd8087cced318d7a2ddd0aabe5d0b65" title="Performs initialization of all statuses, debounce counters, and touch positions of the specified widg...">Cy_CapSense_InitializeWidgetStatus()</a></li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This function is available only for the fifth-generation low power CAPSENSE&trade;.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startSlotId</td><td>The slot ID initialization will be started from.</td></tr>
    <tr><td class="paramname">numberSlots</td><td>The number of slots will be initialized.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the operation:<ul>
<li>CY_CAPSENSE_STATUS_SUCCESS - The operation is performed successfully.</li>
<li>CY_CAPSENSE_STATUS_BAD_PARAM - The input parameter is invalid.</li>
<li>CY_CAPSENSE_STATUS_HW_BUSY - The HW is busy with the previous scan.</li>
<li>CY_CAPSENSE_STATUS_TIMEOUT - The software watchdog timeout occurred during the scan, the scan was not completed.</li>
<li>CY_CAPSENSE_STATUS_MIXED_SENSORS - The requested sensors types can't be scanned in one frame (in autonomous mode). </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaf43c0cf61a95f11a5981f82f5b0d4e86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf43c0cf61a95f11a5981f82f5b0d4e86">&#9670;&nbsp;</a></span>Cy_CapSense_SetupWidgetExt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_SetupWidgetExt </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>widgetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sensorId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs extended initialization for the specified widget and also performs initialization required for a specific sensor in the widget. </p>
<p>This function requires using the <a class="el" href="group__group__capsense__low__level.html#ga31834a3fce1f5b57c72107b419626bab" title="Starts a conversion on the pre-configured sensor. ">Cy_CapSense_ScanExt()</a> function to initiate a scan.</p>
<p>This function does the same as <a class="el" href="group__group__capsense__high__level.html#ga9f798069c57bf91f7ce2bc19bb086191" title="Performs the initialization required to scan the specified widget. ">Cy_CapSense_SetupWidget()</a> and also does the following tasks:</p><ol type="1">
<li>Connects the specified sensor of the widget.</li>
<li>Configures the CSD HW block to perform a scan of the specified sensor.</li>
</ol>
<p>Once this function is called to initialize a widget and a sensor, the <a class="el" href="group__group__capsense__low__level.html#ga31834a3fce1f5b57c72107b419626bab" title="Starts a conversion on the pre-configured sensor. ">Cy_CapSense_ScanExt()</a> function is called to scan the sensor.</p>
<p>This function is called when no scanning is in progress. I.e. <a class="el" href="group__group__capsense__high__level.html#ga7f8739755bba6b51c274f45b569b9ba0" title="This function returns a status whether MW executes HW scanning at a particular moment. ">Cy_CapSense_IsBusy()</a> returns a non-busy status.</p>
<p>Calling this function directly from the application program is not recommended. This function is used to implement only the user's specific use cases (for faster execution time or pipeline scanning, for example).</p>
<dl class="section note"><dt>Note</dt><dd>This function is available only for the fourth-generation CAPSENSE&trade;.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">widgetId</td><td>Specifies the ID number of the widget. A macro for the widget ID can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;WIDGET_NAME&gt;_WDGT_ID.</td></tr>
    <tr><td class="paramname">sensorId</td><td>Specifies the ID number of the sensor within the widget. A macro for the sensor ID within a specified widget can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;WIDGET_NAME&gt;_SNS&lt;SENSOR_NUMBER&gt;_ID.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the widget setting up operation:<ul>
<li>CY_CAPSENSE_STATUS_SUCCESS - The operation is successfully completed.</li>
<li>CY_CAPSENSE_STATUS_BAD_PARAM - The widget is invalid or if the specified widget is disabled.</li>
<li>CY_CAPSENSE_STATUS_INVALID_STATE - The previous scanning is not completed and the CSD HW block is busy. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga31834a3fce1f5b57c72107b419626bab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31834a3fce1f5b57c72107b419626bab">&#9670;&nbsp;</a></span>Cy_CapSense_ScanExt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_ScanExt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts a conversion on the pre-configured sensor. </p>
<p>This function requires using the <a class="el" href="group__group__capsense__low__level.html#gaf43c0cf61a95f11a5981f82f5b0d4e86" title="Performs extended initialization for the specified widget and also performs initialization required f...">Cy_CapSense_SetupWidgetExt()</a> function to set up the a widget.</p>
<p>This function performs single scanning of one sensor in the widget configured by the <a class="el" href="group__group__capsense__low__level.html#gaf43c0cf61a95f11a5981f82f5b0d4e86" title="Performs extended initialization for the specified widget and also performs initialization required f...">Cy_CapSense_SetupWidgetExt()</a> function.</p>
<p>Calling this function directly from the application program is not recommended. This function is used to implement only the user's specific use cases (for faster execution time or pipeline scanning, for example). This function is called when no scanning is in progress. I.e. <a class="el" href="group__group__capsense__high__level.html#ga7f8739755bba6b51c274f45b569b9ba0" title="This function returns a status whether MW executes HW scanning at a particular moment. ">Cy_CapSense_IsBusy()</a> returns a non-busy status.</p>
<p>The sensor must be pre-configured by using the <a class="el" href="group__group__capsense__low__level.html#gaf43c0cf61a95f11a5981f82f5b0d4e86" title="Performs extended initialization for the specified widget and also performs initialization required f...">Cy_CapSense_SetupWidgetExt()</a> prior to calling this function. The sensor remains ready for the next scan if a previous scan was triggered by using the <a class="el" href="group__group__capsense__low__level.html#ga31834a3fce1f5b57c72107b419626bab" title="Starts a conversion on the pre-configured sensor. ">Cy_CapSense_ScanExt()</a> function. In this case, calling <a class="el" href="group__group__capsense__low__level.html#gaf43c0cf61a95f11a5981f82f5b0d4e86" title="Performs extended initialization for the specified widget and also performs initialization required f...">Cy_CapSense_SetupWidgetExt()</a> is not required every time before the <a class="el" href="group__group__capsense__low__level.html#ga31834a3fce1f5b57c72107b419626bab" title="Starts a conversion on the pre-configured sensor. ">Cy_CapSense_ScanExt()</a> function. If a previous scan was triggered in any other way - <a class="el" href="group__group__capsense__high__level.html#ga6473761292c2696bdea571b8bb10b308" title="Initiates scanning of all the sensors in the widget initialized by Cy_CapSense_SetupWidget(), if no scan is in progress. ">Cy_CapSense_Scan()</a>, <a class="el" href="group__group__capsense__high__level.html#ga50e6ef42f2834083715abe86d8a85b48" title="Initiates scanning of all enabled widgets (and sensors) in the project. ">Cy_CapSense_ScanAllWidgets()</a>, or <a class="el" href="group__group__capsense__high__level.html#ga0c613df550388c119fdab4e50341a6b4" title="Establishes synchronized operation between the CAPSENSE™ Middleware and the CAPSENSE™ Tuner tool...">Cy_CapSense_RunTuner()</a> - (see the <a class="el" href="group__group__capsense__high__level.html#ga0c613df550388c119fdab4e50341a6b4" title="Establishes synchronized operation between the CAPSENSE™ Middleware and the CAPSENSE™ Tuner tool...">Cy_CapSense_RunTuner()</a> function description for more details), the sensor must be pre-configured again by using the <a class="el" href="group__group__capsense__low__level.html#gaf43c0cf61a95f11a5981f82f5b0d4e86" title="Performs extended initialization for the specified widget and also performs initialization required f...">Cy_CapSense_SetupWidgetExt()</a> prior to calling the <a class="el" href="group__group__capsense__low__level.html#ga31834a3fce1f5b57c72107b419626bab" title="Starts a conversion on the pre-configured sensor. ">Cy_CapSense_ScanExt()</a> function.</p>
<dl class="section note"><dt>Note</dt><dd>This function is available only for the fourth-generation CAPSENSE&trade;.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the operation:<ul>
<li>CY_CAPSENSE_STATUS_SUCCESS - Scanning is successfully started.</li>
<li>CY_CAPSENSE_STATUS_BAD_CONFIG - The function does not suppose to be called with the current CAPSENSE&trade; configuration. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaa89c8ed15cddd778c2232c85300eb02d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa89c8ed15cddd778c2232c85300eb02d">&#9670;&nbsp;</a></span>Cy_CapSense_GetParam()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_GetParam </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>paramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptrTuner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a value of the specified parameter from the cy_capsense_tuner structure. </p>
<p>This function gets the value of the specified parameter by the paramId argument. The paramId for each register of cy_capsense_tuner is available in the cycfg_capsense.h file as CY_CAPSENSE_&lt;ParameterName&gt;_PARAM_ID. The paramId is a special enumerated value generated by the CAPSENSE&trade; Configurator tool. The format of paramId is as follows:</p><ol type="1">
<li>[ byte 3 byte 2 byte 1 byte 0 ]</li>
<li>[ RRRRRUTT IIIIIIII MMMMMMMM LLLLLLLL ]</li>
<li>U - indicates if the parameter affects the RAM Widget Object CRC.</li>
<li>T - encodes the parameter type:<ul>
<li>01b: uint8_t</li>
<li>10b: uint16_t</li>
<li>11b: uint32_t</li>
</ul>
</li>
<li>I - specifies that the widgetId parameter belongs to.</li>
<li>M,L - the parameter offset MSB and LSB accordingly in cy_capsense_tuner.</li>
<li>R - reserved</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">paramId</td><td>Specifies the ID of parameter to get its value. A macro for the parameter ID can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;ParameterName&gt;_PARAM_ID.</td></tr>
    <tr><td class="paramname">value</td><td>The pointer to a variable to be updated with the obtained value.</td></tr>
    <tr><td class="paramname">ptrTuner</td><td>The pointer to the cy_capsense_tuner variable of cy_stc_capsense_tuner_t. The cy_capsense_tuner is declared in CAPSENSE&trade; Configurator tool generated files:<ul>
<li>cycfg_capsense.c/h</li>
</ul>
</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the operation. If CY_CAPSENSE_STATUS_SUCCESS is not received, either paramId is invalid or ptrTuner is null. </dd></dl>

</div>
</div>
<a id="ga6049654627a08e866ebe5e93ac414177"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6049654627a08e866ebe5e93ac414177">&#9670;&nbsp;</a></span>Cy_CapSense_SetParam()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_SetParam </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>paramId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptrTuner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a new value for the specified parameter in cy_capsense_tuner structure. </p>
<p>This function sets the value of the specified parameter by the paramId argument. The paramId for each register of cy_capsense_tuner is available in the cycfg_capsense.h file as CY_CAPSENSE_&lt;ParameterName&gt;_PARAM_ID. The paramId is a special enumerated value generated by the CAPSENSE&trade; Configurator tool. The format of paramId is as follows:</p><ol type="1">
<li>[ byte 3 byte 2 byte 1 byte 0 ]</li>
<li>[ RRRRRUTT IIIIIIII MMMMMMMM LLLLLLLL ]</li>
<li>U - indicates if the parameter affects the RAM Widget Object CRC.</li>
<li>T - encodes the parameter type:<ul>
<li>01b: uint8_t</li>
<li>10b: uint16_t</li>
<li>11b: uint32_t</li>
</ul>
</li>
<li>I - specifies that the widgetId parameter belongs to</li>
<li>M,L - the parameter offset MSB and LSB accordingly in cy_capsense_tuner.</li>
<li>R - reserved</li>
</ol>
<p>This function writes specified value into the desired register without other registers update. It is application layer responsibility to keep all the data structure registers aligned. Repeated call of <a class="el" href="group__group__capsense__high__level.html#gade28f1f915ce6b97f13399074a819c0d" title="Initializes the CAPSENSE™ firmware modules. ">Cy_CapSense_Enable()</a> function helps aligning dependent register values.</p>
<p>This function updates also the widget CRC field if Built-in Self-test is enabled and paramId requires that.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">paramId</td><td>Specifies the ID of parameter to set its value. A macro for the parameter ID can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;ParameterName&gt;_PARAM_ID.</td></tr>
    <tr><td class="paramname">value</td><td>Specifies the new parameter's value.</td></tr>
    <tr><td class="paramname">ptrTuner</td><td>The pointer to the cy_capsense_tuner variable of cy_stc_capsense_tuner_t. The cy_capsense_tuner is declared in CAPSENSE&trade; Configurator tool generated files:<ul>
<li>cycfg_capsense.c/h</li>
</ul>
</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the operation. If CY_CAPSENSE_STATUS_SUCCESS is not received, the parameter was not updated with the new value, either paramId is invalid or ptrTuner is null. </dd></dl>

</div>
</div>
<a id="ga2de812825cd421ee05fec733206e157a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2de812825cd421ee05fec733206e157a">&#9670;&nbsp;</a></span>Cy_CapSense_GetCRC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t Cy_CapSense_GetCRC </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>ptrData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates CRC for the specified buffer and length. </p>
<p>This API is used for the CRC protection of a packet received from the CAPSENSE&trade; Tuner tool and for BIST operations. CRC polynomial is 0xAC9A. It has a Hamming distance 5 for data words up to 241 bits.</p>
<p>Reference: "P. Koopman, T. Chakravarthy,
"Cyclic Redundancy Code (CRC) Polynomial Selection for Embedded Networks",
The International Conference on Dependable Systems and Networks, DSN-2004"</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptrData</td><td>The pointer to the data.</td></tr>
    <tr><td class="paramname">len</td><td>The length of the data in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a calculated CRC-16 value. </dd></dl>

</div>
</div>
<a id="ga2ad536f018dd41e585fdd27107355a47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ad536f018dd41e585fdd27107355a47">&#9670;&nbsp;</a></span>Cy_CapSense_SetWidgetStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_SetWidgetStatus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>widgetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs configuring of the selected widget. </p>
<p>This function performs customized widget status configuration by the mode parameter. There are two general use cases for this function:</p><ol type="1">
<li>Make the specified widget Enabled/Disabled. This status is intended to define a set of widgets to be scanned/processed from the application layer.</li>
<li>Make the specified widget Working/Non-working. This status is integrated into the built-in self-test (BIST) library. If a test detects non-working widget, that widget status is set to non-working automatically by CAPSENSE&trade;. BIST never resets a widget working mask and the user makes a decision what to do next with this non-working widget.</li>
</ol>
<p>Although other statuses can be changed by this function, this is not recommended to avoid impact on CAPSENSE&trade; operation and is needed to implement only specific use cases.</p>
<p>By default, all widgets are enabled and working during CAPSENSE&trade; initialization. All disabled or non-working widgets are excluded from scanning and processing.</p>
<p>Excluding a widget from a scanning flow happens immediately by re-generation a new scanning frame. This function does it for optimization, which means that scanning functions save CPU time by checking if any widget status was changed.</p>
<p>Excluding from processing flow happens inside the process functions since they perform processing by widgets and not by slots. Therefore, changing the widget status should happen before a new scan and/or after processing.</p>
<p>The <a class="el" href="group__group__capsense__low__level.html#gafbfe743a98bd2c24a623a2c734c03f0e" title="Performs customized data processing on the selected widget. ">Cy_CapSense_ProcessWidgetExt()</a> and <a class="el" href="group__group__capsense__low__level.html#ga05d3f6e7d7fbef845ab4eb575e653dec" title="Performs customized data processing on the selected sensor. ">Cy_CapSense_ProcessSensorExt()</a> functions ignore widget disable and non-working statuses and perform processing based on specified mode provided to those functions.</p>
<p>The function also checks if there is at least one enabled and working widget. If no valid widgets are left for scanning, the function returns CY_CAPSENSE_STATUS_BAD_CONFIG separately for active and low-power widgets due to these groups' independent scanning frames.</p>
<dl class="section note"><dt>Note</dt><dd>For the fifth generation and fifth-generation low power CAPSENSE&trade;, if the specified widget has the enabled multi-frequency scan feature, then the status configuration happens to all the joined widgets:<ul>
<li>Sub-widget channel 2</li>
<li>Sub-widget channel 1</li>
<li>Main widget channel 0</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">widgetId</td><td>Specifies the widget ID number. A macro for the widget ID can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;WIDGET_NAME&gt;_WDGT_ID.</td></tr>
    <tr><td class="paramname">mode</td><td>Specifies the bit mask of widget status to be configured. It is allowed to configure several bits simultaneously.<ol type="1">
<li>Bit [0] - CY_CAPSENSE_WD_ACTIVE_MASK</li>
<li>Bit [1] - CY_CAPSENSE_WD_ENABLE_MASK</li>
<li>Bit [2] - CY_CAPSENSE_WD_WORKING_MASK</li>
<li>Bit [3] - CY_CAPSENSE_WD_MAXCOUNT_CALC_MASK</li>
<li>Bit [4] - CY_CAPSENSE_WD_MAXCOUNT_ROW_CALC_MASK.</li>
</ol>
</td></tr>
    <tr><td class="paramname">mask</td><td>Specifies the value of widget status field to be configured. All bit values not set by the mask passed as the mode parameter are ignored.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the widget processing operation:<ul>
<li>CY_CAPSENSE_STATUS_SUCCESS - The operation is successful.</li>
<li>CY_CAPSENSE_STATUS_BAD_PARAM - The input parameter is invalid. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gad1ce2644b0e056f861befcf8180de138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1ce2644b0e056f861befcf8180de138">&#9670;&nbsp;</a></span>Cy_CapSense_IsWidgetEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Cy_CapSense_IsWidgetEnabled </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>widgetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns widget enable/working status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">widgetId</td><td>Specifies the widget ID number. A macro for the widget ID can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;WIDGET_NAME&gt;_WDGT_ID.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the widget:<ul>
<li>Zero - The specified widget is disabled and / or non-working or the specified parameter is invalid.</li>
<li>Non-zero - The specified widget is enabled and working. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga4fbab9345b72bd9fe35d7f6084feed52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4fbab9345b72bd9fe35d7f6084feed52">&#9670;&nbsp;</a></span>Cy_CapSense_IsSlotEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Cy_CapSense_IsSlotEnabled </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>slotId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns slot enable/working status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slotId</td><td>Specifies the slot ID number.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the specified slot:<ul>
<li>Zero - The specified slot has disabled and / or non-working widgets on all channels or the specified parameter is invalid.</li>
<li>Non-zero - The specified slot has at least one widget enabled and working. </li>
</ul>
</dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>CAPSENSE™ Middleware Library 8.0.0</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>

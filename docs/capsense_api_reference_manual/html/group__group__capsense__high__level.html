<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CAPSENSE&trade; Middleware Library 3.0: High-level Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="IFXCYP_one-line.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CAPSENSE&trade; Middleware Library 3.0</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group__capsense__high__level.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">High-level Functions</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<p>High-level functions represent the highest abstraction layer of the CAPSENSE&trade; middleware. </p>
<p>These functions perform tasks such as scanning, data processing, data reporting and tuning interfaces. When performing a task, different initialization is required based on a sensing method or type of widgets is automatically handled by these functions. Therefore, these functions are sensing methods, features, and widget type agnostics.</p>
<p>All the tasks required to implement a sensing system can be fulfilled by the high-level functions. But, there is a set of <a class="el" href="group__group__capsense__low__level.html">Low-level Functions</a> that provides access to lower level and specific tasks. If a design requires access to low-level tasks, these functions can be used. The functions related to a given sensing methods are not available if the corresponding method is disabled. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga19b3aa9e14a04b76188f917c0dc004f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__high__level.html#ga19b3aa9e14a04b76188f917c0dc004f5">Cy_CapSense_Init</a> (<a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga19b3aa9e14a04b76188f917c0dc004f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Captures HW blocks (one or more) for CAPSENSE&trade; operations and configures them to the default state.  <a href="#ga19b3aa9e14a04b76188f917c0dc004f5">More...</a><br /></td></tr>
<tr class="separator:ga19b3aa9e14a04b76188f917c0dc004f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b8a365213dde3be6c6932dc23fdcee6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__high__level.html#ga7b8a365213dde3be6c6932dc23fdcee6">Cy_CapSense_DeInit</a> (<a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga7b8a365213dde3be6c6932dc23fdcee6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops the middleware operation and releases the CAPSENSE&trade; captured HW blocks.  <a href="#ga7b8a365213dde3be6c6932dc23fdcee6">More...</a><br /></td></tr>
<tr class="separator:ga7b8a365213dde3be6c6932dc23fdcee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade28f1f915ce6b97f13399074a819c0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__high__level.html#gade28f1f915ce6b97f13399074a819c0d">Cy_CapSense_Enable</a> (<a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:gade28f1f915ce6b97f13399074a819c0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the CAPSENSE&trade; firmware modules.  <a href="#gade28f1f915ce6b97f13399074a819c0d">More...</a><br /></td></tr>
<tr class="separator:gade28f1f915ce6b97f13399074a819c0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga899ef1058ead082503771da68e584b82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__high__level.html#ga899ef1058ead082503771da68e584b82">Cy_CapSense_Save</a> (<a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga899ef1058ead082503771da68e584b82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves the state of CAPSENSE&trade; so the functionality can be restored using the <a class="el" href="group__group__capsense__high__level.html#gaf87102783ec511c2e5f2024680112d16" title="Resumes the middleware operation if the Cy_CapSense_Save() function was called previously. ">Cy_CapSense_Restore()</a> function.  <a href="#ga899ef1058ead082503771da68e584b82">More...</a><br /></td></tr>
<tr class="separator:ga899ef1058ead082503771da68e584b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf87102783ec511c2e5f2024680112d16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__high__level.html#gaf87102783ec511c2e5f2024680112d16">Cy_CapSense_Restore</a> (<a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:gaf87102783ec511c2e5f2024680112d16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resumes the middleware operation if the <a class="el" href="group__group__capsense__high__level.html#ga899ef1058ead082503771da68e584b82" title="Saves the state of CAPSENSEâ„¢ so the functionality can be restored using the Cy_CapSense_Restore() fu...">Cy_CapSense_Save()</a> function was called previously.  <a href="#gaf87102783ec511c2e5f2024680112d16">More...</a><br /></td></tr>
<tr class="separator:gaf87102783ec511c2e5f2024680112d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a185db228d5cae975fbc92bd3bc6367"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__high__level.html#ga2a185db228d5cae975fbc92bd3bc6367">Cy_CapSense_ProcessAllWidgets</a> (<a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga2a185db228d5cae975fbc92bd3bc6367"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs full data processing of all enabled widgets.  <a href="#ga2a185db228d5cae975fbc92bd3bc6367">More...</a><br /></td></tr>
<tr class="separator:ga2a185db228d5cae975fbc92bd3bc6367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52874ea98333723ec92aef1bb4791a7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__high__level.html#ga52874ea98333723ec92aef1bb4791a7d">Cy_CapSense_ProcessWidget</a> (uint32_t widgetId, <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga52874ea98333723ec92aef1bb4791a7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs full data processing of the specified widget if it is enabled.  <a href="#ga52874ea98333723ec92aef1bb4791a7d">More...</a><br /></td></tr>
<tr class="separator:ga52874ea98333723ec92aef1bb4791a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga904eb69e694e4daf45bc778281b39d9e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__high__level.html#ga904eb69e694e4daf45bc778281b39d9e">Cy_CapSense_IncrementGestureTimestamp</a> (<a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga904eb69e694e4daf45bc778281b39d9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments the timestamp register for the predefined timestamp interval.  <a href="#ga904eb69e694e4daf45bc778281b39d9e">More...</a><br /></td></tr>
<tr class="separator:ga904eb69e694e4daf45bc778281b39d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf0789f59e23077cba0005b1499468f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__high__level.html#gabf0789f59e23077cba0005b1499468f9">Cy_CapSense_SetGestureTimestamp</a> (uint32_t value, <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:gabf0789f59e23077cba0005b1499468f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrites the timestamp register by the specified value.  <a href="#gabf0789f59e23077cba0005b1499468f9">More...</a><br /></td></tr>
<tr class="separator:gabf0789f59e23077cba0005b1499468f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9436a7ec9b18880dbc046e91462710b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__high__level.html#gaf9436a7ec9b18880dbc046e91462710b">Cy_CapSense_Wakeup</a> (const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:gaf9436a7ec9b18880dbc046e91462710b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resumes the middleware after System Deep Sleep.  <a href="#gaf9436a7ec9b18880dbc046e91462710b">More...</a><br /></td></tr>
<tr class="separator:gaf9436a7ec9b18880dbc046e91462710b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c47887109b22521eba45109b7a27f31"><td class="memItemLeft" align="right" valign="top">cy_en_syspm_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__high__level.html#ga9c47887109b22521eba45109b7a27f31">Cy_CapSense_DeepSleepCallback</a> (cy_stc_syspm_callback_params_t *callbackParams, cy_en_syspm_callback_mode_t mode)</td></tr>
<tr class="memdesc:ga9c47887109b22521eba45109b7a27f31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles CPU active to System Deep Sleep power mode transition for the CAPSENSE&trade; middleware.  <a href="#ga9c47887109b22521eba45109b7a27f31">More...</a><br /></td></tr>
<tr class="separator:ga9c47887109b22521eba45109b7a27f31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga289c4fd495135399a9ad9897920836a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__high__level.html#ga289c4fd495135399a9ad9897920836a7">Cy_CapSense_RegisterCallback</a> (<a class="el" href="group__group__capsense__enums.html#gabfbff81b8b80d4ee1a1d53c1fe0c9a11">cy_en_capsense_callback_event_t</a> callbackType, <a class="el" href="group__group__capsense__structures.html#ga908447ccc2720f31c861d9eb79ff75d2">cy_capsense_callback_t</a> callbackFunction, <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga289c4fd495135399a9ad9897920836a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a ures's callback function.  <a href="#ga289c4fd495135399a9ad9897920836a7">More...</a><br /></td></tr>
<tr class="separator:ga289c4fd495135399a9ad9897920836a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf43b3cdfce7a3e8c0e5622f42e0a6319"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__high__level.html#gaf43b3cdfce7a3e8c0e5622f42e0a6319">Cy_CapSense_UnRegisterCallback</a> (<a class="el" href="group__group__capsense__enums.html#gabfbff81b8b80d4ee1a1d53c1fe0c9a11">cy_en_capsense_callback_event_t</a> callbackType, <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:gaf43b3cdfce7a3e8c0e5622f42e0a6319"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function unregisters a previously registered user's callback function in the CAPSENSE&trade; middleware.  <a href="#gaf43b3cdfce7a3e8c0e5622f42e0a6319">More...</a><br /></td></tr>
<tr class="separator:gaf43b3cdfce7a3e8c0e5622f42e0a6319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55fa694191705971b3aa2c29021fb9aa"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__high__level.html#ga55fa694191705971b3aa2c29021fb9aa">Cy_CapSense_DecodeWidgetGestures</a> (uint32_t widgetId, const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga55fa694191705971b3aa2c29021fb9aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs decoding of all gestures for the specified widget.  <a href="#ga55fa694191705971b3aa2c29021fb9aa">More...</a><br /></td></tr>
<tr class="separator:ga55fa694191705971b3aa2c29021fb9aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1f1514db0566e14ba20fd8647ecb3ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__enums.html#gafbe67572b1e6a637676b0a6e1040857c">cy_en_capsense_bist_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__high__level.html#gab1f1514db0566e14ba20fd8647ecb3ad">Cy_CapSense_RunSelfTest</a> (uint32_t testEnMask, <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:gab1f1514db0566e14ba20fd8647ecb3ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs built-in self-tests specified by the test enable mask.  <a href="#gab1f1514db0566e14ba20fd8647ecb3ad">More...</a><br /></td></tr>
<tr class="separator:gab1f1514db0566e14ba20fd8647ecb3ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50e6ef42f2834083715abe86d8a85b48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__high__level.html#ga50e6ef42f2834083715abe86d8a85b48">Cy_CapSense_ScanAllWidgets</a> (<a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga50e6ef42f2834083715abe86d8a85b48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiates scanning of all enabled widgets (and sensors) in the project.  <a href="#ga50e6ef42f2834083715abe86d8a85b48">More...</a><br /></td></tr>
<tr class="separator:ga50e6ef42f2834083715abe86d8a85b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad98e953def0673cd879f01a00fb2d01b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__high__level.html#gad98e953def0673cd879f01a00fb2d01b">Cy_CapSense_ScanWidget</a> (uint32_t widgetId, <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:gad98e953def0673cd879f01a00fb2d01b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiates the scanning of all sensors in the widget.  <a href="#gad98e953def0673cd879f01a00fb2d01b">More...</a><br /></td></tr>
<tr class="separator:gad98e953def0673cd879f01a00fb2d01b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f8739755bba6b51c274f45b569b9ba0"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__high__level.html#ga7f8739755bba6b51c274f45b569b9ba0">Cy_CapSense_IsBusy</a> (const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga7f8739755bba6b51c274f45b569b9ba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns a status of the CAPSENSE&trade; middleware whether a scan is currently in progress or not.  <a href="#ga7f8739755bba6b51c274f45b569b9ba0">More...</a><br /></td></tr>
<tr class="separator:ga7f8739755bba6b51c274f45b569b9ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeab57caca852dae59618fbfbcd431c27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__high__level.html#gaeab57caca852dae59618fbfbcd431c27">Cy_CapSense_InterruptHandler</a> (void *base, <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:gaeab57caca852dae59618fbfbcd431c27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements interrupt service routine for CAPSENSE&trade; Middleware.  <a href="#gaeab57caca852dae59618fbfbcd431c27">More...</a><br /></td></tr>
<tr class="separator:gaeab57caca852dae59618fbfbcd431c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f798069c57bf91f7ce2bc19bb086191"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__high__level.html#ga9f798069c57bf91f7ce2bc19bb086191">Cy_CapSense_SetupWidget</a> (uint32_t widgetId, <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga9f798069c57bf91f7ce2bc19bb086191"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the initialization required to scan the specified widget.  <a href="#ga9f798069c57bf91f7ce2bc19bb086191">More...</a><br /></td></tr>
<tr class="separator:ga9f798069c57bf91f7ce2bc19bb086191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6473761292c2696bdea571b8bb10b308"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__high__level.html#ga6473761292c2696bdea571b8bb10b308">Cy_CapSense_Scan</a> (<a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga6473761292c2696bdea571b8bb10b308"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiates scanning of all the sensors in the widget initialized by <a class="el" href="group__group__capsense__high__level.html#ga9f798069c57bf91f7ce2bc19bb086191" title="Performs the initialization required to scan the specified widget. ">Cy_CapSense_SetupWidget()</a>, if no scan is in progress.  <a href="#ga6473761292c2696bdea571b8bb10b308">More...</a><br /></td></tr>
<tr class="separator:ga6473761292c2696bdea571b8bb10b308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga045f3f46ff4e43c4f4dbe087c0156f56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__high__level.html#ga045f3f46ff4e43c4f4dbe087c0156f56">Cy_CapSense_ScanAllSlots</a> (<a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga045f3f46ff4e43c4f4dbe087c0156f56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiates the non-blocking scan of all slots.  <a href="#ga045f3f46ff4e43c4f4dbe087c0156f56">More...</a><br /></td></tr>
<tr class="separator:ga045f3f46ff4e43c4f4dbe087c0156f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf10ce0cc817442374d2df04c9d241f9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__high__level.html#gaf10ce0cc817442374d2df04c9d241f9b">Cy_CapSense_ScanSlots</a> (uint32_t startSlotId, uint32_t numberSlots, <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:gaf10ce0cc817442374d2df04c9d241f9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiates the non-blocking scan of specified slots.  <a href="#gaf10ce0cc817442374d2df04c9d241f9b">More...</a><br /></td></tr>
<tr class="separator:gaf10ce0cc817442374d2df04c9d241f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1530a032b2c5239f7efde29fa23d1793"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gaae9a4f12c83f84c5a02079bb0eeeb3c9">cy_capsense_mw_state_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__high__level.html#ga1530a032b2c5239f7efde29fa23d1793">Cy_CapSense_MwState</a> (const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga1530a032b2c5239f7efde29fa23d1793"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns a detailed state of the CAPSENSE&trade; middleware and MSC hardware in Single- or Multi-channel mode.  <a href="#ga1530a032b2c5239f7efde29fa23d1793">More...</a><br /></td></tr>
<tr class="separator:ga1530a032b2c5239f7efde29fa23d1793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga036e1061e289e038c3e13df5c8751aed"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__high__level.html#ga036e1061e289e038c3e13df5c8751aed">Cy_CapSense_IsAnyWidgetActive</a> (const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga036e1061e289e038c3e13df5c8751aed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports whether any widget has detected touch.  <a href="#ga036e1061e289e038c3e13df5c8751aed">More...</a><br /></td></tr>
<tr class="separator:ga036e1061e289e038c3e13df5c8751aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4afba79341aef27afc40054d376d7193"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__high__level.html#ga4afba79341aef27afc40054d376d7193">Cy_CapSense_IsWidgetActive</a> (uint32_t widgetId, const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga4afba79341aef27afc40054d376d7193"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports whether the specified widget detected touch on any of its sensors.  <a href="#ga4afba79341aef27afc40054d376d7193">More...</a><br /></td></tr>
<tr class="separator:ga4afba79341aef27afc40054d376d7193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeaa2dc78e56e2fc1ec0cc2b265851d69"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__high__level.html#gaeaa2dc78e56e2fc1ec0cc2b265851d69">Cy_CapSense_IsSensorActive</a> (uint32_t widgetId, uint32_t sensorId, const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:gaeaa2dc78e56e2fc1ec0cc2b265851d69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports whether the specified sensor in the widget detected touch.  <a href="#gaeaa2dc78e56e2fc1ec0cc2b265851d69">More...</a><br /></td></tr>
<tr class="separator:gaeaa2dc78e56e2fc1ec0cc2b265851d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96509342c580a9c5f6e17bdf8c74e53a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__high__level.html#ga96509342c580a9c5f6e17bdf8c74e53a">Cy_CapSense_IsProximitySensorActive</a> (uint32_t widgetId, uint32_t sensorId, const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga96509342c580a9c5f6e17bdf8c74e53a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the status of the specified proximity widget/sensor.  <a href="#ga96509342c580a9c5f6e17bdf8c74e53a">More...</a><br /></td></tr>
<tr class="separator:ga96509342c580a9c5f6e17bdf8c74e53a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6192ba34167662ac9573c0a4cd71682f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcy__stc__capsense__touch__t.html">cy_stc_capsense_touch_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__high__level.html#ga6192ba34167662ac9573c0a4cd71682f">Cy_CapSense_GetTouchInfo</a> (uint32_t widgetId, const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga6192ba34167662ac9573c0a4cd71682f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the details of touch position detected on the specified touchpad, matrix buttons or slider widgets.  <a href="#ga6192ba34167662ac9573c0a4cd71682f">More...</a><br /></td></tr>
<tr class="separator:ga6192ba34167662ac9573c0a4cd71682f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c613df550388c119fdab4e50341a6b4"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__high__level.html#ga0c613df550388c119fdab4e50341a6b4">Cy_CapSense_RunTuner</a> (<a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga0c613df550388c119fdab4e50341a6b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes synchronized operation between the CAPSENSE&trade; Middleware and the CAPSENSE&trade; Tuner tool.  <a href="#ga0c613df550388c119fdab4e50341a6b4">More...</a><br /></td></tr>
<tr class="separator:ga0c613df550388c119fdab4e50341a6b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f0fdedcec1ad936f5e9e4ae28f17274"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__high__level.html#ga1f0fdedcec1ad936f5e9e4ae28f17274">Cy_CapSense_CheckTunerCmdIntegrity</a> (const uint8_t *commandPacket)</td></tr>
<tr class="memdesc:ga1f0fdedcec1ad936f5e9e4ae28f17274"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks command format, header, tail, CRC, etc.  <a href="#ga1f0fdedcec1ad936f5e9e4ae28f17274">More...</a><br /></td></tr>
<tr class="separator:ga1f0fdedcec1ad936f5e9e4ae28f17274"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga19b3aa9e14a04b76188f917c0dc004f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19b3aa9e14a04b76188f917c0dc004f5">&#9670;&nbsp;</a></span>Cy_CapSense_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Captures HW blocks (one or more) for CAPSENSE&trade; operations and configures them to the default state. </p>
<p>Call this function with the application program prior to calling any other function of the middleware.</p>
<p>The following tasks are executed:</p><ol type="1">
<li>Capturing not used HW blocks. If any of HW block is already in use, then the function returns the fail status, and the application program should perform corresponding actions. For example, releasing the HW block captured by another middleware.</li>
<li>If the HW block has been captured successfully, this function configures it to the default state.</li>
</ol>
<p>After the middleware is configured using the <a class="el" href="group__group__capsense__high__level.html#ga19b3aa9e14a04b76188f917c0dc004f5" title="Captures HW blocks (one or more) for CAPSENSEâ„¢ operations and configures them to the default state...">Cy_CapSense_Init()</a> function, the application program configures and enables the HW block interrupt(s), and then call of the <a class="el" href="group__group__capsense__high__level.html#gade28f1f915ce6b97f13399074a819c0d" title="Initializes the CAPSENSEâ„¢ firmware modules. ">Cy_CapSense_Enable()</a> function to complete the middleware initialization process. See the function usage example below for more details.</p>
<p>When the middleware operation is stopped by the <a class="el" href="group__group__capsense__high__level.html#ga7b8a365213dde3be6c6932dc23fdcee6" title="Stops the middleware operation and releases the CAPSENSEâ„¢ captured HW blocks. ">Cy_CapSense_DeInit()</a> function, subsequent call of the <a class="el" href="group__group__capsense__high__level.html#ga19b3aa9e14a04b76188f917c0dc004f5" title="Captures HW blocks (one or more) for CAPSENSEâ„¢ operations and configures them to the default state...">Cy_CapSense_Init()</a> function repeats initialization process and it is not needed to call the <a class="el" href="group__group__capsense__high__level.html#gade28f1f915ce6b97f13399074a819c0d" title="Initializes the CAPSENSEâ„¢ firmware modules. ">Cy_CapSense_Enable()</a> function second time. However, to implement time-multiplexed mode (sharing the HW block(s) between multiple middleware) the <a class="el" href="group__group__capsense__high__level.html#ga899ef1058ead082503771da68e584b82" title="Saves the state of CAPSENSEâ„¢ so the functionality can be restored using the Cy_CapSense_Restore() fu...">Cy_CapSense_Save()</a> and <a class="el" href="group__group__capsense__high__level.html#gaf87102783ec511c2e5f2024680112d16" title="Resumes the middleware operation if the Cy_CapSense_Save() function was called previously. ">Cy_CapSense_Restore()</a> functions should be used instead of the <a class="el" href="group__group__capsense__high__level.html#ga7b8a365213dde3be6c6932dc23fdcee6" title="Stops the middleware operation and releases the CAPSENSEâ„¢ captured HW blocks. ">Cy_CapSense_DeInit()</a> and <a class="el" href="group__group__capsense__high__level.html#ga19b3aa9e14a04b76188f917c0dc004f5" title="Captures HW blocks (one or more) for CAPSENSEâ„¢ operations and configures them to the default state...">Cy_CapSense_Init()</a> functions for further compatibility.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> generated by the CAPSENSE&trade; Configurator tool. The structure contains both, CAPSENSE&trade; configuration and internal data and it is used during whole CAPSENSE&trade; operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the initialization process. If CY_CAPSENSE_STATUS_SUCCESS is not received, some of the initialization fails, the middleware may not operate as expected, and repeating of initialization is required.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd></dd></dl>
<div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Capture the CAPSENSE&amp;trade; HW block and initialize it to the default state. */</span></div><div class="line">    <a class="code" href="group__group__capsense__high__level.html#ga19b3aa9e14a04b76188f917c0dc004f5">Cy_CapSense_Init</a>(&amp;cy_capsense_context);</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize CAPSENSE&amp;trade; interrupt */</span></div><div class="line">    Cy_SysInt_Init(&amp;CapSense_ISR_cfg, &amp;snippet_Cy_CapSense_IntHandler);</div><div class="line">    NVIC_ClearPendingIRQ(CapSense_ISR_cfg.intrSrc);</div><div class="line">    NVIC_EnableIRQ(CapSense_ISR_cfg.intrSrc);</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize the CAPSENSE&amp;trade; firmware modules. */</span></div><div class="line">    <a class="code" href="group__group__capsense__high__level.html#gade28f1f915ce6b97f13399074a819c0d">Cy_CapSense_Enable</a>(&amp;cy_capsense_context);</div><div class="line"></div></div><!-- fragment --><p>The 'cy_capsense_context' variable that is used as the parameter of the <a class="el" href="group__group__capsense__high__level.html#ga19b3aa9e14a04b76188f917c0dc004f5" title="Captures HW blocks (one or more) for CAPSENSEâ„¢ operations and configures them to the default state...">Cy_CapSense_Init()</a> and <a class="el" href="group__group__capsense__high__level.html#gade28f1f915ce6b97f13399074a819c0d" title="Initializes the CAPSENSEâ„¢ firmware modules. ">Cy_CapSense_Enable()</a> functions is declared in the cycfg_capsense.h file.</p>
<p>The CapSense_ISR_cfg variable should be declared by the application program according to the examples below:<br />
 For PSoC&trade; 4 CPU or for PSoC&trade; 6 CM0+ core: </p><div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">    #if (!(CY_CAPSENSE_PSOC4_FIFTH_GEN))</span></div><div class="line">        <span class="keyword">const</span> cy_stc_sysint_t CapSense_ISR_cfg =</div><div class="line">        {</div><div class="line">            .intrSrc = csd_interrupt_IRQn,  <span class="comment">/* CM0+ interrupt is NVIC #2 */</span></div><div class="line">            .intrPriority = 3u,             <span class="comment">/* Interrupt priority is 3 */</span></div><div class="line">        };</div><div class="line"><span class="preprocessor">    #else</span></div><div class="line">        <span class="keyword">const</span> cy_stc_sysint_t CapSense_ISR_cfg =</div><div class="line">        {</div><div class="line">            .intrSrc = msc_0_interrupt_IRQn,  <span class="comment">/* CM0+ interrupt is NVIC #2 */</span></div><div class="line">            .intrPriority = 3u,             <span class="comment">/* Interrupt priority is 3 */</span></div><div class="line">        };</div><div class="line"><span class="preprocessor">    #endif</span></div><div class="line"></div></div><!-- fragment --><p> For CM4 core: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="keyword">const</span> cy_stc_sysint_t CapSense_ISR_cfg =</div><div class="line">    {</div><div class="line">        .intrSrc = csd_interrupt_IRQn, <span class="comment">/* Interrupt source is the CSD interrupt */</span></div><div class="line">        .intrPriority = 7u,            <span class="comment">/* Interrupt priority is 7 */</span></div><div class="line">    };</div><div class="line"></div></div><!-- fragment --><p> The CAPSENSE&trade; interrupt handler should be declared by the application program according to the example below: </p><div class="fragment"><div class="line"></div><div class="line"><span class="keywordtype">void</span> snippet_Cy_CapSense_IntHandler(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group__group__capsense__high__level.html#gaeab57caca852dae59618fbfbcd431c27">Cy_CapSense_InterruptHandler</a>(CapSense_HW, &amp;cy_capsense_context);</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p> The CapSense_HW is the pointer to the base register address of the CAPSENSE&trade; HW block. A macro for the pointer is in the cycfg_peripherals.h file defined as &lt;Personality_Name&gt;_HW. If no name is specified, the following default names are used:</p><ul>
<li>csd_&lt;Block_Number&gt;_csd_&lt;Block_Number&gt;_HW - for forth-generation CAPSENSE&trade; HW.</li>
<li>msc_&lt;Block_Number&gt;_msc_&lt;Block_Number&gt;_HW - for fifth-generation CAPSENSE&trade; HW. </li>
</ul>

</div>
</div>
<a id="ga7b8a365213dde3be6c6932dc23fdcee6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b8a365213dde3be6c6932dc23fdcee6">&#9670;&nbsp;</a></span>Cy_CapSense_DeInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_DeInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stops the middleware operation and releases the CAPSENSE&trade; captured HW blocks. </p>
<p>No sensor scanning can be executed when the middleware is stopped. This function should be called only when no scanning is in progress. I.e. <a class="el" href="group__group__capsense__high__level.html#ga7f8739755bba6b51c274f45b569b9ba0" title="This function returns a status of the CAPSENSEâ„¢ middleware whether a scan is currently in progress o...">Cy_CapSense_IsBusy()</a> returns a non-busy status.</p>
<p>After the middleware stops, the CAPSENSE&trade; HW block(s) may be reconfigured with the application program or other middleware for any other usage.</p>
<p>When the middleware operation is stopped by the <a class="el" href="group__group__capsense__high__level.html#ga7b8a365213dde3be6c6932dc23fdcee6" title="Stops the middleware operation and releases the CAPSENSEâ„¢ captured HW blocks. ">Cy_CapSense_DeInit()</a> function, subsequent call of the <a class="el" href="group__group__capsense__high__level.html#ga19b3aa9e14a04b76188f917c0dc004f5" title="Captures HW blocks (one or more) for CAPSENSEâ„¢ operations and configures them to the default state...">Cy_CapSense_Init()</a> function repeats initialization process and it is not needed to call the <a class="el" href="group__group__capsense__high__level.html#gade28f1f915ce6b97f13399074a819c0d" title="Initializes the CAPSENSEâ„¢ firmware modules. ">Cy_CapSense_Enable()</a> function second time. However, to implement time-multiplexed mode (sharing the CAPSENSE&trade; HW block(s) between multiple middleware) the <a class="el" href="group__group__capsense__high__level.html#ga899ef1058ead082503771da68e584b82" title="Saves the state of CAPSENSEâ„¢ so the functionality can be restored using the Cy_CapSense_Restore() fu...">Cy_CapSense_Save()</a> and <a class="el" href="group__group__capsense__high__level.html#gaf87102783ec511c2e5f2024680112d16" title="Resumes the middleware operation if the Cy_CapSense_Save() function was called previously. ">Cy_CapSense_Restore()</a> functions should be used instead of the <a class="el" href="group__group__capsense__high__level.html#ga7b8a365213dde3be6c6932dc23fdcee6" title="Stops the middleware operation and releases the CAPSENSEâ„¢ captured HW blocks. ">Cy_CapSense_DeInit()</a> and <a class="el" href="group__group__capsense__high__level.html#ga19b3aa9e14a04b76188f917c0dc004f5" title="Captures HW blocks (one or more) for CAPSENSEâ„¢ operations and configures them to the default state...">Cy_CapSense_Init()</a> functions for further compatibility.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the stop process. If CY_CAPSENSE_STATUS_SUCCESS is not received, the stop process fails and retries may be required. </dd></dl>

</div>
</div>
<a id="gade28f1f915ce6b97f13399074a819c0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade28f1f915ce6b97f13399074a819c0d">&#9670;&nbsp;</a></span>Cy_CapSense_Enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_Enable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the CAPSENSE&trade; firmware modules. </p>
<p>Call the <a class="el" href="group__group__capsense__high__level.html#ga19b3aa9e14a04b76188f917c0dc004f5" title="Captures HW blocks (one or more) for CAPSENSEâ„¢ operations and configures them to the default state...">Cy_CapSense_Init()</a> function and configure CAPSENSE&trade; HW block interrupts prior to calling this function. See the function usage example below for details on usage.</p>
<p>The following are executed as part of the function:</p><ol type="1">
<li>Check CAPSENSE&trade; configuration integrity.</li>
<li>Pre-calculate of internal register values to speed up operation.</li>
<li>Configure the CAPSENSE&trade; HW block to perform capacitive sensing operation.</li>
<li>If the smart sensing algorithm is selected for the CSD Tuning mode in the Basic tab, the auto-tuning functionality is executed to set the optimal values for the CAPSENSE&trade; HW block parameters of the widgets/sensors.</li>
<li>Calibrate the sensors and find the optimal values for DACs of each widget/sensor, if the auto-calibration is enabled in the CSD Setting or CSX Setting tabs.</li>
<li>Perform scanning for all the sensors and initialize the baseline history.</li>
<li>If the firmware filters are enabled in the Advanced General tab, the filter histories are also initialized.</li>
</ol>
<p>Any subsequent call of this function repeats initialization process. Therefore, it is possible to change the middleware configuration from the application program by writing registers to the data structure and calling this function again.</p>
<p>The repeated call of this function is also done inside the <a class="el" href="group__group__capsense__high__level.html#ga0c613df550388c119fdab4e50341a6b4" title="Establishes synchronized operation between the CAPSENSEâ„¢ Middleware and the CAPSENSEâ„¢ Tuner tool...">Cy_CapSense_RunTuner()</a> function when a restart command is received.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the initialization process. If CY_CAPSENSE_STATUS_SUCCESS is not received, some of the initialization fails.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd></dd></dl>
<div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Capture the CAPSENSE&amp;trade; HW block and initialize it to the default state. */</span></div><div class="line">    <a class="code" href="group__group__capsense__high__level.html#ga19b3aa9e14a04b76188f917c0dc004f5">Cy_CapSense_Init</a>(&amp;cy_capsense_context);</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize CAPSENSE&amp;trade; interrupt */</span></div><div class="line">    Cy_SysInt_Init(&amp;CapSense_ISR_cfg, &amp;snippet_Cy_CapSense_IntHandler);</div><div class="line">    NVIC_ClearPendingIRQ(CapSense_ISR_cfg.intrSrc);</div><div class="line">    NVIC_EnableIRQ(CapSense_ISR_cfg.intrSrc);</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize the CAPSENSE&amp;trade; firmware modules. */</span></div><div class="line">    <a class="code" href="group__group__capsense__high__level.html#gade28f1f915ce6b97f13399074a819c0d">Cy_CapSense_Enable</a>(&amp;cy_capsense_context);</div><div class="line"></div></div><!-- fragment --><p>The 'cy_capsense_context' variable that is used as the parameter of the <a class="el" href="group__group__capsense__high__level.html#ga19b3aa9e14a04b76188f917c0dc004f5" title="Captures HW blocks (one or more) for CAPSENSEâ„¢ operations and configures them to the default state...">Cy_CapSense_Init()</a> and <a class="el" href="group__group__capsense__high__level.html#gade28f1f915ce6b97f13399074a819c0d" title="Initializes the CAPSENSEâ„¢ firmware modules. ">Cy_CapSense_Enable()</a> functions is declared in the cycfg_capsense.h file.</p>
<p>The CapSense_ISR_cfg variable should be declared by the application program according to the examples below:<br />
 For CM0+ core: </p><div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">    #if (!(CY_CAPSENSE_PSOC4_FIFTH_GEN))</span></div><div class="line">        <span class="keyword">const</span> cy_stc_sysint_t CapSense_ISR_cfg =</div><div class="line">        {</div><div class="line">            .intrSrc = csd_interrupt_IRQn,  <span class="comment">/* CM0+ interrupt is NVIC #2 */</span></div><div class="line">            .intrPriority = 3u,             <span class="comment">/* Interrupt priority is 3 */</span></div><div class="line">        };</div><div class="line"><span class="preprocessor">    #else</span></div><div class="line">        <span class="keyword">const</span> cy_stc_sysint_t CapSense_ISR_cfg =</div><div class="line">        {</div><div class="line">            .intrSrc = msc_0_interrupt_IRQn,  <span class="comment">/* CM0+ interrupt is NVIC #2 */</span></div><div class="line">            .intrPriority = 3u,             <span class="comment">/* Interrupt priority is 3 */</span></div><div class="line">        };</div><div class="line"><span class="preprocessor">    #endif</span></div><div class="line"></div></div><!-- fragment --><p> For CM4 core: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="keyword">const</span> cy_stc_sysint_t CapSense_ISR_cfg =</div><div class="line">    {</div><div class="line">        .intrSrc = csd_interrupt_IRQn, <span class="comment">/* Interrupt source is the CSD interrupt */</span></div><div class="line">        .intrPriority = 7u,            <span class="comment">/* Interrupt priority is 7 */</span></div><div class="line">    };</div><div class="line"></div></div><!-- fragment --><p> The CAPSENSE&trade; interrupt handler should be declared by the application program according to the example below: </p><div class="fragment"><div class="line"></div><div class="line"><span class="keywordtype">void</span> snippet_Cy_CapSense_IntHandler(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group__group__capsense__high__level.html#gaeab57caca852dae59618fbfbcd431c27">Cy_CapSense_InterruptHandler</a>(CapSense_HW, &amp;cy_capsense_context);</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p> The CapSense_HW is the pointer to the base register address of the CAPSENSE&trade; HW block. A macro for the pointer is in the cycfg_peripherals.h file defined as &lt;Personality_Name&gt;_HW. If no name is specified, the following default names are used:</p><ul>
<li>csd_&lt;Block_Number&gt;_csd_&lt;Block_Number&gt;_HW - for forth-generation CAPSENSE&trade; HW.</li>
<li>msc_&lt;Block_Number&gt;_msc_&lt;Block_Number&gt;_HW - for fifth-generation CAPSENSE&trade; HW. </li>
</ul>

</div>
</div>
<a id="ga899ef1058ead082503771da68e584b82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga899ef1058ead082503771da68e584b82">&#9670;&nbsp;</a></span>Cy_CapSense_Save()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_Save </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves the state of CAPSENSE&trade; so the functionality can be restored using the <a class="el" href="group__group__capsense__high__level.html#gaf87102783ec511c2e5f2024680112d16" title="Resumes the middleware operation if the Cy_CapSense_Save() function was called previously. ">Cy_CapSense_Restore()</a> function. </p>
<p>This function, along with the <a class="el" href="group__group__capsense__high__level.html#gaf87102783ec511c2e5f2024680112d16" title="Resumes the middleware operation if the Cy_CapSense_Save() function was called previously. ">Cy_CapSense_Restore()</a> function, is specifically designed for ease of use and supports time multiplexing of the CAPSENSE&trade; HW block among multiple middleware. When the CAPSENSE&trade; HW block is shared by multiple middleware, this function can be used to save the current state of the CAPSENSE&trade; HW block and CAPSENSE&trade; Middleware prior to releasing the CAPSENSE&trade; HW block for use by other middleware. See the function usage example below for details on usage.</p>
<p>This function performs the same tasks as the <a class="el" href="group__group__capsense__high__level.html#ga7b8a365213dde3be6c6932dc23fdcee6" title="Stops the middleware operation and releases the CAPSENSEâ„¢ captured HW blocks. ">Cy_CapSense_DeInit()</a> function and is kept for API consistency among middlewares. It is recommended to use <a class="el" href="group__group__capsense__high__level.html#ga899ef1058ead082503771da68e584b82" title="Saves the state of CAPSENSEâ„¢ so the functionality can be restored using the Cy_CapSense_Restore() fu...">Cy_CapSense_Save()</a> and <a class="el" href="group__group__capsense__high__level.html#gaf87102783ec511c2e5f2024680112d16" title="Resumes the middleware operation if the Cy_CapSense_Save() function was called previously. ">Cy_CapSense_Restore()</a> functions to implement Time-multiplexed mode instead of <a class="el" href="group__group__capsense__high__level.html#ga7b8a365213dde3be6c6932dc23fdcee6" title="Stops the middleware operation and releases the CAPSENSEâ„¢ captured HW blocks. ">Cy_CapSense_DeInit()</a> and <a class="el" href="group__group__capsense__high__level.html#ga19b3aa9e14a04b76188f917c0dc004f5" title="Captures HW blocks (one or more) for CAPSENSEâ„¢ operations and configures them to the default state...">Cy_CapSense_Init()</a> functions for further compatibility.</p>
<p>This function performs the following operations:</p><ul>
<li>Releases the CAPSENSE&trade; HW block.</li>
<li>Configures sensor pins to the default state and disconnects them from analog buses.</li>
<li>Disconnects external capacitors from analog buses.</li>
<li>Sets the middleware state to default.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the process. If CY_CAPSENSE_STATUS_SUCCESS is not received, the save process fails and retries may be required.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd></dd></dl>
<p>An example of sharing the CAPSENSE&trade; HW block by the CapSense and CSDADC middleware.<br />
 Declares the CapSense_ISR_cfg variable: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="keyword">const</span> cy_stc_sysint_t CapSense_ISR_cfg =</div><div class="line">    {</div><div class="line">        .intrSrc = csd_interrupt_IRQn, <span class="comment">/* Interrupt source is the CSD interrupt */</span></div><div class="line">        .intrPriority = 7u,            <span class="comment">/* Interrupt priority is 7 */</span></div><div class="line">    };</div><div class="line"></div></div><!-- fragment --><p> Declares the CSDADC_ISR_cfg variable: </p><div class="fragment"><div class="line"></div><div class="line">        <span class="keyword">const</span> cy_stc_sysint_t CSDADC_ISR_cfg =</div><div class="line">        {</div><div class="line">            .intrSrc = csd_interrupt_IRQn, <span class="comment">/* Interrupt source is the CSD interrupt */</span></div><div class="line">            .intrPriority = 7u,            <span class="comment">/* Interrupt priority is 7 */</span></div><div class="line">        };</div><div class="line"></div></div><!-- fragment --><p> Defines the CapSense interrupt handler: </p><div class="fragment"><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> CapSense_Interrupt(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group__group__capsense__high__level.html#gaeab57caca852dae59618fbfbcd431c27">Cy_CapSense_InterruptHandler</a>(CapSense_HW, &amp;cy_capsense_context);</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p> Defines the CSDADC interrupt handler: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> CSDADC_Interrupt(<span class="keywordtype">void</span>)</div><div class="line">    {</div><div class="line">        Cy_CSDADC_InterruptHandler(CSD0, &amp;cy_csd_0_context);</div><div class="line">    }</div><div class="line"></div></div><!-- fragment --><p> The part of the main.c FW flow: </p><div class="fragment"><div class="line">        <span class="comment">/* ... */</span></div><div class="line"></div><div class="line">        <span class="comment">/* Initialize CAPSENSE&amp;trade; MW */</span></div><div class="line">        <a class="code" href="group__group__capsense__high__level.html#ga19b3aa9e14a04b76188f917c0dc004f5">Cy_CapSense_Init</a>(&amp;cy_capsense_context);</div><div class="line">        Cy_SysInt_Init(&amp;CapSense_ISR_cfg, &amp;CapSense_Interrupt);</div><div class="line">        NVIC_ClearPendingIRQ(CapSense_ISR_cfg.intrSrc);</div><div class="line">        NVIC_EnableIRQ(CapSense_ISR_cfg.intrSrc);</div><div class="line">        <a class="code" href="group__group__capsense__high__level.html#gade28f1f915ce6b97f13399074a819c0d">Cy_CapSense_Enable</a>(&amp;cy_capsense_context);</div><div class="line">        <a class="code" href="group__group__capsense__high__level.html#ga899ef1058ead082503771da68e584b82">Cy_CapSense_Save</a>(&amp;cy_capsense_context);</div><div class="line"></div><div class="line">        <span class="comment">/* Initialize CSDADC MW */</span></div><div class="line">        Cy_CSDADC_Init(&amp;CapSense_csdadc_config, &amp;cy_csdadc_context);</div><div class="line">        Cy_SysInt_Init(&amp;CSDADC_ISR_cfg, &amp;CSDADC_Interrupt);</div><div class="line">        NVIC_ClearPendingIRQ(CSDADC_ISR_cfg.intrSrc);</div><div class="line">        NVIC_EnableIRQ(CSDADC_ISR_cfg.intrSrc);</div><div class="line">        Cy_CSDADC_Enable(&amp;cy_csdadc_context);</div><div class="line">        Cy_CSDADC_Save(&amp;cy_csdadc_context);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (;;)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Switch to CAPSENSE&amp;trade; MW */</span></div><div class="line">            <a class="code" href="group__group__capsense__high__level.html#gaf87102783ec511c2e5f2024680112d16">Cy_CapSense_Restore</a>(&amp;cy_capsense_context);</div><div class="line">            Cy_SysInt_Init(&amp;CapSense_ISR_cfg, &amp;CapSense_Interrupt);</div><div class="line">                <span class="comment">/* Do CAPSENSE&amp;trade; sensing operation */</span></div><div class="line">            <a class="code" href="group__group__capsense__high__level.html#ga899ef1058ead082503771da68e584b82">Cy_CapSense_Save</a>(&amp;cy_capsense_context);</div><div class="line"></div><div class="line">            <span class="comment">/* Switch to CSDADC MW */</span></div><div class="line">            Cy_CSDADC_Restore(&amp;cy_csdadc_context);</div><div class="line">            Cy_SysInt_Init(&amp;CSDADC_ISR_cfg, &amp;CSDADC_Interrupt);</div><div class="line">                <span class="comment">/* Do CSDADC measurement operation */</span></div><div class="line">            Cy_CSDADC_Save(&amp;cy_csdadc_context);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">/* ... */</span></div></div><!-- fragment -->
</div>
</div>
<a id="gaf87102783ec511c2e5f2024680112d16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf87102783ec511c2e5f2024680112d16">&#9670;&nbsp;</a></span>Cy_CapSense_Restore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_Restore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resumes the middleware operation if the <a class="el" href="group__group__capsense__high__level.html#ga899ef1058ead082503771da68e584b82" title="Saves the state of CAPSENSEâ„¢ so the functionality can be restored using the Cy_CapSense_Restore() fu...">Cy_CapSense_Save()</a> function was called previously. </p>
<p>This function, along with the <a class="el" href="group__group__capsense__high__level.html#ga899ef1058ead082503771da68e584b82" title="Saves the state of CAPSENSEâ„¢ so the functionality can be restored using the Cy_CapSense_Restore() fu...">Cy_CapSense_Save()</a> function is specifically designed for ease of use and supports time multiplexing of the CAPSENSE&trade; HW block among multiple middleware. When the CAPSENSE&trade; HW blocks are shared by multiple middleware, this function can be used to restore the previous state of the CAPSENSE&trade; HW block(s) and CAPSENSE&trade; Middleware is saved using the <a class="el" href="group__group__capsense__high__level.html#ga899ef1058ead082503771da68e584b82" title="Saves the state of CAPSENSEâ„¢ so the functionality can be restored using the Cy_CapSense_Restore() fu...">Cy_CapSense_Save()</a> function. See the function usage example below for details on usage.</p>
<p>This function performs the same tasks as <a class="el" href="group__group__capsense__high__level.html#ga19b3aa9e14a04b76188f917c0dc004f5" title="Captures HW blocks (one or more) for CAPSENSEâ„¢ operations and configures them to the default state...">Cy_CapSense_Init()</a> function and is kept for API consistency among middlewares. It is recommended to use <a class="el" href="group__group__capsense__high__level.html#ga899ef1058ead082503771da68e584b82" title="Saves the state of CAPSENSEâ„¢ so the functionality can be restored using the Cy_CapSense_Restore() fu...">Cy_CapSense_Save()</a> and <a class="el" href="group__group__capsense__high__level.html#gaf87102783ec511c2e5f2024680112d16" title="Resumes the middleware operation if the Cy_CapSense_Save() function was called previously. ">Cy_CapSense_Restore()</a> functions to implement time-multiplexed mode instead of <a class="el" href="group__group__capsense__high__level.html#ga7b8a365213dde3be6c6932dc23fdcee6" title="Stops the middleware operation and releases the CAPSENSEâ„¢ captured HW blocks. ">Cy_CapSense_DeInit()</a> and <a class="el" href="group__group__capsense__high__level.html#ga19b3aa9e14a04b76188f917c0dc004f5" title="Captures HW blocks (one or more) for CAPSENSEâ„¢ operations and configures them to the default state...">Cy_CapSense_Init()</a> functions for further compatibility.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the resume process. If CY_CAPSENSE_STATUS_SUCCESS is not received, the resume process fails and retries may be required.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd></dd></dl>
<p>An example of sharing the CAPSENSE&trade; HW block by CAPSENSE&trade; and CSDADC middleware: </p><div class="fragment"><div class="line">        <span class="comment">/* ... */</span></div><div class="line"></div><div class="line">        <span class="comment">/* Initialize CAPSENSE&amp;trade; MW */</span></div><div class="line">        <a class="code" href="group__group__capsense__high__level.html#ga19b3aa9e14a04b76188f917c0dc004f5">Cy_CapSense_Init</a>(&amp;cy_capsense_context);</div><div class="line">        Cy_SysInt_Init(&amp;CapSense_ISR_cfg, &amp;CapSense_Interrupt);</div><div class="line">        NVIC_ClearPendingIRQ(CapSense_ISR_cfg.intrSrc);</div><div class="line">        NVIC_EnableIRQ(CapSense_ISR_cfg.intrSrc);</div><div class="line">        <a class="code" href="group__group__capsense__high__level.html#gade28f1f915ce6b97f13399074a819c0d">Cy_CapSense_Enable</a>(&amp;cy_capsense_context);</div><div class="line">        <a class="code" href="group__group__capsense__high__level.html#ga899ef1058ead082503771da68e584b82">Cy_CapSense_Save</a>(&amp;cy_capsense_context);</div><div class="line"></div><div class="line">        <span class="comment">/* Initialize CSDADC MW */</span></div><div class="line">        Cy_CSDADC_Init(&amp;CapSense_csdadc_config, &amp;cy_csdadc_context);</div><div class="line">        Cy_SysInt_Init(&amp;CSDADC_ISR_cfg, &amp;CSDADC_Interrupt);</div><div class="line">        NVIC_ClearPendingIRQ(CSDADC_ISR_cfg.intrSrc);</div><div class="line">        NVIC_EnableIRQ(CSDADC_ISR_cfg.intrSrc);</div><div class="line">        Cy_CSDADC_Enable(&amp;cy_csdadc_context);</div><div class="line">        Cy_CSDADC_Save(&amp;cy_csdadc_context);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (;;)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Switch to CAPSENSE&amp;trade; MW */</span></div><div class="line">            <a class="code" href="group__group__capsense__high__level.html#gaf87102783ec511c2e5f2024680112d16">Cy_CapSense_Restore</a>(&amp;cy_capsense_context);</div><div class="line">            Cy_SysInt_Init(&amp;CapSense_ISR_cfg, &amp;CapSense_Interrupt);</div><div class="line">                <span class="comment">/* Do CAPSENSE&amp;trade; sensing operation */</span></div><div class="line">            <a class="code" href="group__group__capsense__high__level.html#ga899ef1058ead082503771da68e584b82">Cy_CapSense_Save</a>(&amp;cy_capsense_context);</div><div class="line"></div><div class="line">            <span class="comment">/* Switch to CSDADC MW */</span></div><div class="line">            Cy_CSDADC_Restore(&amp;cy_csdadc_context);</div><div class="line">            Cy_SysInt_Init(&amp;CSDADC_ISR_cfg, &amp;CSDADC_Interrupt);</div><div class="line">                <span class="comment">/* Do CSDADC measurement operation */</span></div><div class="line">            Cy_CSDADC_Save(&amp;cy_csdadc_context);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">/* ... */</span></div></div><!-- fragment -->
</div>
</div>
<a id="ga2a185db228d5cae975fbc92bd3bc6367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a185db228d5cae975fbc92bd3bc6367">&#9670;&nbsp;</a></span>Cy_CapSense_ProcessAllWidgets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_ProcessAllWidgets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs full data processing of all enabled widgets. </p>
<p>This function performs all data processes for all enabled widgets and sensors in the middleware to produce meaningful status output from widgets and sensors. The following tasks are executed as part of processing all the widgets:</p><ol type="1">
<li>Apply raw count filters to the raw counts, if they are enabled.</li>
<li>Update the thresholds if the smart sensing algorithm Full Auto-Tuning is enabled.</li>
<li>Update the baselines and difference counts for all the sensors.</li>
<li>Update the sensor and widget output status. Updates on/off status for buttons and proximity widgets, centroid/position for the sliders and the X/Y position for the touchpads.</li>
</ol>
<p>This function is called by the application program only after all the enabled widgets (and sensors) in the middleware are scanned. Calling this function multiple times without sensor scanning causes unexpected behavior.</p>
<p>The disabled widgets are not processed by this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the processing operation. If CY_CAPSENSE_STATUS_SUCCESS is not received, the processing fails and retries may be required. </dd></dl>

</div>
</div>
<a id="ga52874ea98333723ec92aef1bb4791a7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52874ea98333723ec92aef1bb4791a7d">&#9670;&nbsp;</a></span>Cy_CapSense_ProcessWidget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_ProcessWidget </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>widgetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs full data processing of the specified widget if it is enabled. </p>
<p>This function performs exactly the same tasks as <a class="el" href="group__group__capsense__high__level.html#ga2a185db228d5cae975fbc92bd3bc6367" title="Performs full data processing of all enabled widgets. ">Cy_CapSense_ProcessAllWidgets()</a>, but only for a specified widget. This function can be used along with the <a class="el" href="group__group__capsense__high__level.html#ga9f798069c57bf91f7ce2bc19bb086191" title="Performs the initialization required to scan the specified widget. ">Cy_CapSense_SetupWidget()</a> and <a class="el" href="group__group__capsense__high__level.html#ga6473761292c2696bdea571b8bb10b308" title="Initiates scanning of all the sensors in the widget initialized by Cy_CapSense_SetupWidget(), if no scan is in progress. ">Cy_CapSense_Scan()</a> functions (4th Generation) to scan and process data for a specific widget or with the <a class="el" href="group__group__capsense__high__level.html#gaf10ce0cc817442374d2df04c9d241f9b" title="Initiates the non-blocking scan of specified slots. ">Cy_CapSense_ScanSlots()</a> function (5th Generation). This function is called only after all the sensors in the widgets are scanned. A disabled widget is not processed by this function.</p>
<p>A pipeline scan method (i.e. during scanning of a current widget (N), perform processing of the previously scanned widget (N-1)) can be implemented using this function and it may reduce the total execution time, increase the refresh rate, and decrease the average power consumption. See the function usage example below for details on usage.</p>
<p>For the Fifth generation CapSense if the specified widget has the enabled multi-frequency scan feature then the function does the following:</p><ul>
<li>If the specified widget ID refers to main (base) frequency then the function processes raw count processing of all three widgets (main and two sub-widgets) and then status processing of the main widget only.</li>
<li>If the specified widget ID refers to sub-widgets (1st or 2nd frequency channels) then the function returns CY_CAPSENSE_STATUS_BAD_PARAM. To perform customized processing use the <a class="el" href="group__group__capsense__low__level.html#gafbfe743a98bd2c24a623a2c734c03f0e" title="Performs customized data processing on the selected widget. ">Cy_CapSense_ProcessWidgetExt()</a> function.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">widgetId</td><td>Specifies the ID number of the widget. A macro for the widget ID can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;WIDGET_NAME&gt;_WDGT_ID.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the widget processing:<ul>
<li>CY_CAPSENSE_STATUS_SUCCESS - The operation is successfully completed</li>
<li>CY_CAPSENSE_STATUS_BAD_PARAM - The input parameter is invalid</li>
<li>CY_CAPSENSE_STATUS_INVALID_STATE - The specified widget is disabled</li>
<li>CY_CAPSENSE_STATUS_BAD_DATA - The processing is failed</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd></dd></dl>
<p>An example of pipeline implementation: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/*...*/</span></div><div class="line">    currentWidgetId = 0u;</div><div class="line">    previousWidgetId = 0u;</div><div class="line"></div><div class="line"><span class="preprocessor">    #if (CY_CAPSENSE_PLATFORM_BLOCK_FIFTH_GEN)</span></div><div class="line">            <a class="code" href="group__group__capsense__high__level.html#gaf10ce0cc817442374d2df04c9d241f9b">Cy_CapSense_ScanSlots</a>(cy_capsense_context.ptrWdConfig[CY_CAPSENSE_TOUCHPAD0_WDGT_ID].firstSlotId,</div><div class="line">                        cy_capsense_context.ptrWdConfig[CY_CAPSENSE_TOUCHPAD0_WDGT_ID].numSlots, &amp;cy_capsense_context);</div><div class="line"><span class="preprocessor">    #else</span></div><div class="line">        <a class="code" href="group__group__capsense__high__level.html#gad98e953def0673cd879f01a00fb2d01b">Cy_CapSense_ScanWidget</a>(CY_CAPSENSE_TOUCHPAD0_WDGT_ID, &amp;cy_capsense_context);</div><div class="line"><span class="preprocessor">    #endif</span></div><div class="line"></div><div class="line">    <span class="keywordflow">for</span>(;;)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">if</span> (<a class="code" href="group__group__capsense__macros__general.html#ga1bd45eed2be393b7f53c20f1bae2814e">CY_CAPSENSE_NOT_BUSY</a> == <a class="code" href="group__group__capsense__high__level.html#ga7f8739755bba6b51c274f45b569b9ba0">Cy_CapSense_IsBusy</a>(&amp;cy_capsense_context))</div><div class="line">        {</div><div class="line">            currentWidgetId = (currentWidgetId &lt; (cy_capsense_context.ptrCommonConfig-&gt;numWd - 1u)) ? (currentWidgetId + 1u) : 0u;</div><div class="line"></div><div class="line"><span class="preprocessor">            #if (CY_CAPSENSE_PLATFORM_BLOCK_FIFTH_GEN)</span></div><div class="line">                <a class="code" href="group__group__capsense__high__level.html#gaf10ce0cc817442374d2df04c9d241f9b">Cy_CapSense_ScanSlots</a>(cy_capsense_context.ptrWdConfig[CY_CAPSENSE_TOUCHPAD0_WDGT_ID].firstSlotId,</div><div class="line">                            cy_capsense_context.ptrWdConfig[CY_CAPSENSE_TOUCHPAD0_WDGT_ID].numSlots, &amp;cy_capsense_context);</div><div class="line"><span class="preprocessor">            #else</span></div><div class="line">                <a class="code" href="group__group__capsense__high__level.html#gad98e953def0673cd879f01a00fb2d01b">Cy_CapSense_ScanWidget</a>(CY_CAPSENSE_TOUCHPAD0_WDGT_ID, &amp;cy_capsense_context);</div><div class="line"><span class="preprocessor">            #endif</span></div><div class="line">            <span class="comment">/* Process a previous widget during scanning of the current widget */</span></div><div class="line">            <a class="code" href="group__group__capsense__high__level.html#ga52874ea98333723ec92aef1bb4791a7d">Cy_CapSense_ProcessWidget</a>(previousWidgetId, &amp;cy_capsense_context);</div><div class="line">            previousWidgetId = currentWidgetId;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="comment">/*...*/</span></div><div class="line"></div></div><!-- fragment -->
</div>
</div>
<a id="ga904eb69e694e4daf45bc778281b39d9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga904eb69e694e4daf45bc778281b39d9e">&#9670;&nbsp;</a></span>Cy_CapSense_IncrementGestureTimestamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_CapSense_IncrementGestureTimestamp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increments the timestamp register for the predefined timestamp interval. </p>
<p>A timestamp is required for operation of the Gesture and Ballistic multiplier feature. Hence this function and timestamp is required only if the Gesture detection or Ballistic multiplier feature is enabled.</p>
<p>This function increments the timestamp by the interval specified in the context-&gt;ptrCommonContext-&gt;timestampInterval register. The unit for the timestamp and timestamp interval is milliseconds and the default value of the interval is 1.</p>
<p>The application program must periodically call this function or register a periodic callback to this function to keep the timestamp updated and operational for the operation of the Gesture and Ballistic multiplier feature.</p>
<p>The timestamp can be updated in one of the three methods:</p><ol type="1">
<li>Register a periodic callback for the <a class="el" href="group__group__capsense__high__level.html#ga904eb69e694e4daf45bc778281b39d9e" title="Increments the timestamp register for the predefined timestamp interval. ">Cy_CapSense_IncrementGestureTimestamp()</a> function.</li>
<li>Periodically call the <a class="el" href="group__group__capsense__high__level.html#ga904eb69e694e4daf45bc778281b39d9e" title="Increments the timestamp register for the predefined timestamp interval. ">Cy_CapSense_IncrementGestureTimestamp()</a> function from the application program.</li>
<li>Directly modify the timestamp using the <a class="el" href="group__group__capsense__high__level.html#gabf0789f59e23077cba0005b1499468f9" title="Rewrites the timestamp register by the specified value. ">Cy_CapSense_SetGestureTimestamp()</a> function.</li>
</ol>
<p>See the function usage example below for more details.</p>
<p>The interval at which this function is called should match with interval defined in context-&gt;ptrCommonContext-&gt;timestampInterval register. Either the register value can be updated to match the callback interval or the callback can be made at interval set in the register.</p>
<p>If a timestamp is available from another source, the application program may choose to periodically update the timestamp by using the <a class="el" href="group__group__capsense__high__level.html#gabf0789f59e23077cba0005b1499468f9" title="Rewrites the timestamp register by the specified value. ">Cy_CapSense_SetGestureTimestamp()</a> function instead of registering a callback.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function Usage</dt><dd></dd></dl>
<p>An example of timestamp updating: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* If previous scan complete, process widget data and trigger the next scan */</span></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__capsense__macros__general.html#ga1bd45eed2be393b7f53c20f1bae2814e">CY_CAPSENSE_NOT_BUSY</a> == <a class="code" href="group__group__capsense__high__level.html#ga7f8739755bba6b51c274f45b569b9ba0">Cy_CapSense_IsBusy</a>(&amp;cy_capsense_context))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Increment timestamp: Option 2 */</span></div><div class="line">        <a class="code" href="group__group__capsense__high__level.html#ga904eb69e694e4daf45bc778281b39d9e">Cy_CapSense_IncrementGestureTimestamp</a>(&amp;cy_capsense_context);</div><div class="line">        <span class="comment">/* Increment timestamp: Option 3 */</span></div><div class="line">        cy_capsense_context.ptrCommonContext-&gt;timestamp = newTimestamp;</div><div class="line"></div><div class="line">        <a class="code" href="group__group__capsense__high__level.html#ga52874ea98333723ec92aef1bb4791a7d">Cy_CapSense_ProcessWidget</a>(CY_CAPSENSE_TOUCHPAD0_WDGT_ID, &amp;cy_capsense_context);</div><div class="line">        <a class="code" href="group__group__capsense__high__level.html#ga55fa694191705971b3aa2c29021fb9aa">Cy_CapSense_DecodeWidgetGestures</a>(CY_CAPSENSE_TOUCHPAD0_WDGT_ID, &amp;cy_capsense_context);</div><div class="line"></div><div class="line"><span class="preprocessor">        #if (CY_CAPSENSE_PLATFORM_BLOCK_FIFTH_GEN)</span></div><div class="line">            <a class="code" href="group__group__capsense__high__level.html#gaf10ce0cc817442374d2df04c9d241f9b">Cy_CapSense_ScanSlots</a>(cy_capsense_context.ptrWdConfig[CY_CAPSENSE_TOUCHPAD0_WDGT_ID].firstSlotId,</div><div class="line">                        cy_capsense_context.ptrWdConfig[CY_CAPSENSE_TOUCHPAD0_WDGT_ID].numSlots, &amp;cy_capsense_context);</div><div class="line"><span class="preprocessor">        #else</span></div><div class="line">            <a class="code" href="group__group__capsense__high__level.html#gad98e953def0673cd879f01a00fb2d01b">Cy_CapSense_ScanWidget</a>(CY_CAPSENSE_TOUCHPAD0_WDGT_ID, &amp;cy_capsense_context);</div><div class="line"><span class="preprocessor">        #endif</span></div><div class="line">    }</div><div class="line"></div></div><!-- fragment -->
</div>
</div>
<a id="gabf0789f59e23077cba0005b1499468f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf0789f59e23077cba0005b1499468f9">&#9670;&nbsp;</a></span>Cy_CapSense_SetGestureTimestamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_CapSense_SetGestureTimestamp </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrites the timestamp register by the specified value. </p>
<p>This function writes the specified value into the middleware timestamp context-&gt;ptrCommonContext-&gt;timestamp register.</p>
<p>If a timestamp is available from another source, the application program may choose to periodically update the timestamp by using this function instead of registering a callback.</p>
<p>Do not modify the timestamp arbitrarily or simultaneously use with the <a class="el" href="group__group__capsense__high__level.html#ga904eb69e694e4daf45bc778281b39d9e" title="Increments the timestamp register for the predefined timestamp interval. ">Cy_CapSense_IncrementGestureTimestamp()</a> function, which may result in unexpected result.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Specifies the timestamp value (in ms).</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf9436a7ec9b18880dbc046e91462710b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9436a7ec9b18880dbc046e91462710b">&#9670;&nbsp;</a></span>Cy_CapSense_Wakeup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_CapSense_Wakeup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resumes the middleware after System Deep Sleep. </p>
<p>This function is used to resume the middleware operation after exiting System Deep Sleep. After the CAPSENSE&trade; HW block is powered off, an extra delay is required to establish the correct operation of the CAPSENSE&trade; HW block.</p>
<p>This function is called by the <a class="el" href="group__group__capsense__high__level.html#ga9c47887109b22521eba45109b7a27f31" title="Handles CPU active to System Deep Sleep power mode transition for the CAPSENSEâ„¢ middleware. ">Cy_CapSense_DeepSleepCallback()</a> function after exiting System Deep Sleep if the CAPSENSE&trade; Deep Sleep callback is registered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9c47887109b22521eba45109b7a27f31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c47887109b22521eba45109b7a27f31">&#9670;&nbsp;</a></span>Cy_CapSense_DeepSleepCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cy_en_syspm_status_t Cy_CapSense_DeepSleepCallback </td>
          <td>(</td>
          <td class="paramtype">cy_stc_syspm_callback_params_t *&#160;</td>
          <td class="paramname"><em>callbackParams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cy_en_syspm_callback_mode_t&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handles CPU active to System Deep Sleep power mode transition for the CAPSENSE&trade; middleware. </p>
<p>Calling this function directly from the application program is not recommended. Instead, Cy_SysPm_CpuEnterDeepSleep() should be used for the CPU active to System Deep Sleep power mode transition of the device. </p><dl class="section note"><dt>Note</dt><dd>After the CPU Deep Sleep transition, the device automatically goes to System Deep Sleep if all conditions are fulfilled: another core is in CPU Deep Sleep, all the peripherals are ready to System Deep Sleep, etc. (see details in the device TRM).</dd></dl>
<p>For proper operation of the CAPSENSE&trade; middleware during the CPU active to System Deep Sleep mode transition, a callback to this function should be registered using the Cy_SysPm_RegisterCallback() function with CY_SYSPM_DEEPSLEEP type. After the callback is registered, this function is called by the Cy_SysPm_CpuEnterDeepSleep() function to prepare the middleware to the device power mode transition.</p>
<p>When this function is called with CY_SYSPM_CHECK_READY as an input, this function returns CY_SYSPM_SUCCESS if no scanning is in progress or not a single HW block is captured by the CAPSENSE&trade; middleware. Otherwise CY_SYSPM_FAIL is returned. If CY_SYSPM_FAIL status is returned, a device cannot change the power mode without completing the current scan as a transition to System Deep Sleep during the scan can disrupt the middleware operation.</p>
<p>When this function is called with CY_SYSPM_AFTER_TRANSITION as an input, then the <a class="el" href="group__group__capsense__high__level.html#gaf9436a7ec9b18880dbc046e91462710b" title="Resumes the middleware after System Deep Sleep. ">Cy_CapSense_Wakeup()</a> function is called to resume the middleware operation after exiting System Deep Sleep. If there are no CAPSENSE&trade; captured HW blocks the <a class="el" href="group__group__capsense__high__level.html#gaf9436a7ec9b18880dbc046e91462710b" title="Resumes the middleware after System Deep Sleep. ">Cy_CapSense_Wakeup()</a> function calling is omitted and restoring CAPSENSE&trade; immediately after Deep Sleep without the wake-up delay can lead to unpredictable behavior.</p>
<p>For details of SysPm types and macros refer to the SysPm section of the PDL documentation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callbackParams</td><td>Refer to the description of the cy_stc_syspm_callback_params_t type in the Peripheral Driver Library documentation.</td></tr>
    <tr><td class="paramname">mode</td><td>Specifies mode cy_en_syspm_callback_mode_t.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status cy_en_syspm_status_t of the operation requested by the mode parameter:<ul>
<li>CY_SYSPM_SUCCESS - System Deep Sleep power mode can be entered.</li>
<li>CY_SYSPM_FAIL - System Deep Sleep power mode cannot be entered. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga289c4fd495135399a9ad9897920836a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga289c4fd495135399a9ad9897920836a7">&#9670;&nbsp;</a></span>Cy_CapSense_RegisterCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_RegisterCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__capsense__enums.html#gabfbff81b8b80d4ee1a1d53c1fe0c9a11">cy_en_capsense_callback_event_t</a>&#160;</td>
          <td class="paramname"><em>callbackType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__capsense__structures.html#ga908447ccc2720f31c861d9eb79ff75d2">cy_capsense_callback_t</a>&#160;</td>
          <td class="paramname"><em>callbackFunction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers a ures's callback function. </p>
<p>The registered function will be called by the CAPSENSE&trade; middleware when the specified event <a class="el" href="group__group__capsense__enums.html#gabfbff81b8b80d4ee1a1d53c1fe0c9a11">cy_en_capsense_callback_event_t</a> has occurred in the CAPSENSE&trade; middleware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callbackType</td><td>The event on which the registered user's function is called by the CAPSENSE&trade; middleware. Refer to <a class="el" href="group__group__capsense__enums.html#gabfbff81b8b80d4ee1a1d53c1fe0c9a11">cy_en_capsense_callback_event_t</a> for the list of supported events.</td></tr>
    <tr><td class="paramname">callbackFunction</td><td>The pointer to the user's callback function to be called by the middleware.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the callback registration:<ul>
<li>CY_CAPSENSE_STATUS_SUCCESS - The action performed successfully.</li>
<li>CY_CAPSENSE_STATUS_BAD_PARAM - The input parameter is invalid. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaf43b3cdfce7a3e8c0e5622f42e0a6319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf43b3cdfce7a3e8c0e5622f42e0a6319">&#9670;&nbsp;</a></span>Cy_CapSense_UnRegisterCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_UnRegisterCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__capsense__enums.html#gabfbff81b8b80d4ee1a1d53c1fe0c9a11">cy_en_capsense_callback_event_t</a>&#160;</td>
          <td class="paramname"><em>callbackType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function unregisters a previously registered user's callback function in the CAPSENSE&trade; middleware. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callbackType</td><td>The event on which the callback function should be unregistered. Refer to <a class="el" href="group__group__capsense__enums.html#gabfbff81b8b80d4ee1a1d53c1fe0c9a11">cy_en_capsense_callback_event_t</a> for the list of supported events.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the callback deregistration:<ul>
<li>CY_CAPSENSE_STATUS_SUCCESS - The action performed successfully.</li>
<li>CY_CAPSENSE_STATUS_BAD_PARAM - The input parameter is invalid. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga55fa694191705971b3aa2c29021fb9aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55fa694191705971b3aa2c29021fb9aa">&#9670;&nbsp;</a></span>Cy_CapSense_DecodeWidgetGestures()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Cy_CapSense_DecodeWidgetGestures </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>widgetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs decoding of all gestures for the specified widget. </p>
<p>This function should be called by application program only after all sensors are scanned and all data processing is executed using <a class="el" href="group__group__capsense__high__level.html#ga2a185db228d5cae975fbc92bd3bc6367" title="Performs full data processing of all enabled widgets. ">Cy_CapSense_ProcessAllWidgets()</a> or <a class="el" href="group__group__capsense__high__level.html#ga52874ea98333723ec92aef1bb4791a7d" title="Performs full data processing of the specified widget if it is enabled. ">Cy_CapSense_ProcessWidget()</a> functions for the widget. Calling this function multiple times without a new sensor scan and process causes unexpected behavior.</p>
<dl class="section note"><dt>Note</dt><dd>The function (Gesture detection functionality) requires a timestamp for its operation. The timestamp should be initialized and maintained in the application program prior to calling this function. See the descriptions of the <a class="el" href="group__group__capsense__high__level.html#gabf0789f59e23077cba0005b1499468f9" title="Rewrites the timestamp register by the specified value. ">Cy_CapSense_SetGestureTimestamp()</a> and <a class="el" href="group__group__capsense__high__level.html#ga904eb69e694e4daf45bc778281b39d9e" title="Increments the timestamp register for the predefined timestamp interval. ">Cy_CapSense_IncrementGestureTimestamp()</a> functions for details.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">widgetId</td><td>Specifies the ID number of the widget. A macro for the widget ID can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;WIDGET_NAME&gt;_WDGT_ID.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the detected Gesture mask and direction of detected gestures. The same information is stored in ptrWdContext-&gt;gestureDetected and ptrWdContext-&gt;gestureDirection registers. Corresponding macros could be found <a class="el" href="group__group__capsense__macros__gesture.html">Gesture Macros</a>.<ul>
<li>bit[0..15] - detected gesture masks gesture<ul>
<li>bit[0] - one-finger single click gesture</li>
<li>bit[1] - one-finger double click gesture</li>
<li>bit[2] - one-finger click and drag gesture</li>
<li>bit[3] - two-finger single click gesture</li>
<li>bit[4] - one-finger scroll gesture</li>
<li>bit[5] - two-finger scroll gesture</li>
<li>bit[6] - one-finger edge swipe</li>
<li>bit[7] - one-finger flick</li>
<li>bit[8] - one-finger rotate</li>
<li>bit[9] - two-finger zoom</li>
<li>bit[13] - touchdown event</li>
<li>bit[14] - liftoff event</li>
</ul>
</li>
<li>bit[16..31] - gesture direction if detected<ul>
<li>bit[0..1] - direction of one-finger scroll gesture</li>
<li>bit[2..3] - direction of two-finger scroll gesture</li>
<li>bit[4..5] - direction of one-finger edge swipe gesture</li>
<li>bit[6] - direction of one-finger rotate gesture</li>
<li>bit[7] - direction of two-finger zoom gesture</li>
<li>bit[8..10] - direction of one-finger flick gesture</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd></dd></dl>
<p>An example of gesture decoding: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* If previous scan complete, process widget data and trigger the next scan */</span></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__capsense__macros__general.html#ga1bd45eed2be393b7f53c20f1bae2814e">CY_CAPSENSE_NOT_BUSY</a> == <a class="code" href="group__group__capsense__high__level.html#ga7f8739755bba6b51c274f45b569b9ba0">Cy_CapSense_IsBusy</a>(&amp;cy_capsense_context))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Increment timestamp before widget data processing if ballistic multiplier is enabled */</span></div><div class="line">        <a class="code" href="group__group__capsense__high__level.html#ga904eb69e694e4daf45bc778281b39d9e">Cy_CapSense_IncrementGestureTimestamp</a>(&amp;cy_capsense_context);</div><div class="line"></div><div class="line">        <span class="comment">/* Process widget data: Calculate diff counts, status, position, etc. */</span></div><div class="line">        <a class="code" href="group__group__capsense__high__level.html#ga52874ea98333723ec92aef1bb4791a7d">Cy_CapSense_ProcessWidget</a>(CY_CAPSENSE_TOUCHPAD0_WDGT_ID, &amp;cy_capsense_context);</div><div class="line"></div><div class="line">        <span class="comment">/* Process gesture for the widget */</span></div><div class="line">        gestureStatus = <a class="code" href="group__group__capsense__high__level.html#ga55fa694191705971b3aa2c29021fb9aa">Cy_CapSense_DecodeWidgetGestures</a>(CY_CAPSENSE_TOUCHPAD0_WDGT_ID, &amp;cy_capsense_context);</div><div class="line"></div><div class="line">        <span class="comment">/* The same gestureStatus can be read from the following registers */</span></div><div class="line">        gestureStatus = cy_capsense_context.ptrWdContext[CY_CAPSENSE_TOUCHPAD0_WDGT_ID].gestureDetected |</div><div class="line">                    ((uint32_t)cy_capsense_context.ptrWdContext[CY_CAPSENSE_TOUCHPAD0_WDGT_ID].gestureDirection &lt;&lt; <a class="code" href="group__group__capsense__macros__gesture.html#ga3bfd7aa90e3ef1bf3c124c90ec9c2e13">CY_CAPSENSE_GESTURE_DIRECTION_OFFSET</a>);</div><div class="line"></div><div class="line"><span class="preprocessor">        #if (CY_CAPSENSE_PLATFORM_BLOCK_FIFTH_GEN)</span></div><div class="line">            <a class="code" href="group__group__capsense__high__level.html#gaf10ce0cc817442374d2df04c9d241f9b">Cy_CapSense_ScanSlots</a>(cy_capsense_context.ptrWdConfig[CY_CAPSENSE_TOUCHPAD0_WDGT_ID].firstSlotId,</div><div class="line">                        cy_capsense_context.ptrWdConfig[CY_CAPSENSE_TOUCHPAD0_WDGT_ID].numSlots, &amp;cy_capsense_context);</div><div class="line"><span class="preprocessor">        #else</span></div><div class="line">            <a class="code" href="group__group__capsense__high__level.html#gad98e953def0673cd879f01a00fb2d01b">Cy_CapSense_ScanWidget</a>(CY_CAPSENSE_TOUCHPAD0_WDGT_ID, &amp;cy_capsense_context);</div><div class="line"><span class="preprocessor">        #endif</span></div><div class="line">    }</div><div class="line"></div></div><!-- fragment --><p> An example of gesture status parsing: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* If Two-finger Scroll gesture is detected */</span></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__capsense__macros__gesture.html#ga438d3109bdaa4dd9bd2a5653c37322f5">CY_CAPSENSE_GESTURE_NO_GESTURE</a> != (gestureStatus &amp; <a class="code" href="group__group__capsense__macros__gesture.html#gae8a61309c25e5255fa4a46436384184d">CY_CAPSENSE_GESTURE_TWO_FNGR_SCROLL_MASK</a>))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Get gesture direction */</span></div><div class="line">        direction = (gestureStatus &gt;&gt; <a class="code" href="group__group__capsense__macros__gesture.html#ga3bfd7aa90e3ef1bf3c124c90ec9c2e13">CY_CAPSENSE_GESTURE_DIRECTION_OFFSET</a>) &amp; <a class="code" href="group__group__capsense__macros__gesture.html#ga2b1afba16625a4f234e167a4580f28af">CY_CAPSENSE_GESTURE_DIRECTION_MASK_TWO_SCROLL</a>;</div><div class="line">        <span class="keywordflow">switch</span> (direction &gt;&gt; <a class="code" href="group__group__capsense__macros__gesture.html#gab65415405b4a5a8e2dcd432aeba8dad5">CY_CAPSENSE_GESTURE_DIRECTION_OFFSET_TWO_SCROLL</a>)</div><div class="line">        {</div><div class="line">            <span class="keywordflow">case</span> <a class="code" href="group__group__capsense__macros__gesture.html#gad81547dd95beb218449d8d209d6f2d90">CY_CAPSENSE_GESTURE_DIRECTION_UP</a>:</div><div class="line">                <span class="comment">/* UP is detected */</span></div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line">            <span class="keywordflow">case</span> <a class="code" href="group__group__capsense__macros__gesture.html#gac6a805800ada8e6f499d063f45fb8ba8">CY_CAPSENSE_GESTURE_DIRECTION_DOWN</a>:</div><div class="line">                <span class="comment">/* DOWN is detected */</span></div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line">            <span class="keywordflow">case</span> <a class="code" href="group__group__capsense__macros__gesture.html#ga5660ae39ff90e08e33a71508d3059817">CY_CAPSENSE_GESTURE_DIRECTION_LEFT</a>:</div><div class="line">                <span class="comment">/* LEFT is detected */</span></div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line">            <span class="keywordflow">case</span> <a class="code" href="group__group__capsense__macros__gesture.html#gabeb98d13bdc3570bca825b5a5d4a4ae0">CY_CAPSENSE_GESTURE_DIRECTION_RIGHT</a>:</div><div class="line">                <span class="comment">/* RIGHT is detected */</span></div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div></div><!-- fragment -->
</div>
</div>
<a id="gab1f1514db0566e14ba20fd8647ecb3ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1f1514db0566e14ba20fd8647ecb3ad">&#9670;&nbsp;</a></span>Cy_CapSense_RunSelfTest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__enums.html#gafbe67572b1e6a637676b0a6e1040857c">cy_en_capsense_bist_status_t</a> Cy_CapSense_RunSelfTest </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>testEnMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runs built-in self-tests specified by the test enable mask. </p>
<p>The function performs various self-tests on all the enabled widgets and sensors in the project. Select the required set of tests using the bit-mask in testEnMask parameter.</p>
<p>Use CY_CAPSENSE_BIST_RUN_AVAILABLE_SELF_TEST_MASK to execute all the self-tests or any combination of the masks (defined in testEnMask parameter) to specify the desired test list.</p>
<p>To execute a single-element test (i.e. for one widget or one sensor), the following low-level functions are available: for the fourth-generation CAPSENSE&trade;:</p><ul>
<li><a class="el" href="group__group__capsense__low__level.html#ga8266fcf05ad962580844a2c9c01f2fb8" title="Checks the stored CRC of the cy_stc_capsense_widget_context_t data structure of the specified widget...">Cy_CapSense_CheckCRCWidget()</a></li>
<li><a class="el" href="group__group__capsense__low__level.html#gadcc9fa570b4c5aa91c66570f5c6f57d4" title="Checks the specified widget/sensor for shorts to GND, VDD or other sensors. ">Cy_CapSense_CheckIntegritySensorPins()</a></li>
<li><a class="el" href="group__group__capsense__low__level.html#ga3bf9894c313d4ffce1be841141d6b8e5" title="Measures the specified CSD sensor / CSX electrode capacitance in femtofarads. ">Cy_CapSense_MeasureCapacitanceSensor()</a></li>
<li><a class="el" href="group__group__capsense__low__level.html#gacc9c800180cd40a8ca3e53321d6a249b" title="Measures shield electrode capacitance in femtofarads. ">Cy_CapSense_MeasureCapacitanceShield()</a></li>
<li><a class="el" href="group__group__capsense__low__level.html#ga80ad1c421ea794bd493bb37e76c48a2b" title="Measures the capacitance in picofarads of the specified CAPSENSEâ„¢ integration (external) capacitor...">Cy_CapSense_MeasureCapacitanceCap()</a></li>
<li><a class="el" href="group__group__capsense__low__level.html#ga0214428f5737ef46a2f755620c4e7316" title="Measures a VDDA voltage, returns the measured voltage in millivolts through the ptrValue argument and...">Cy_CapSense_MeasureVdda()</a> for the fifth-generation CAPSENSE&trade;:</li>
<li><a class="el" href="group__group__capsense__low__level.html#ga8266fcf05ad962580844a2c9c01f2fb8" title="Checks the stored CRC of the cy_stc_capsense_widget_context_t data structure of the specified widget...">Cy_CapSense_CheckCRCWidget()</a></li>
<li><a class="el" href="group__group__capsense__low__level.html#gadcc9fa570b4c5aa91c66570f5c6f57d4" title="Checks the specified widget/sensor for shorts to GND, VDD or other sensors. ">Cy_CapSense_CheckIntegritySensorPins()</a></li>
<li><a class="el" href="group__group__capsense__low__level.html#ga23f23f4e684b25788f999851f20aa58c" title="Measures the specified CSD sensor / CSX electrode capacitance in femtofarads. ">Cy_CapSense_MeasureCapacitanceSensorElectrode()</a></li>
<li><a class="el" href="group__group__capsense__low__level.html#gadb467c284dc3fea4c7347a25c5ff57df" title="Measures the specified slot sensor capacitance in femtofarads. ">Cy_CapSense_MeasureCapacitanceSlotSensors()</a></li>
<li><a class="el" href="group__group__capsense__low__level.html#gaff014dbf80fc7824a7e6e3e377d2942f" title="Measures shield electrode capacitances in femtofarads. ">Cy_CapSense_MeasureCapacitanceShieldElectrode()</a></li>
</ul>
<p>Refer to these functions descriptions for detail information on the corresponding test.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">testEnMask</td><td>Specifies the tests to be executed. Each bit corresponds to one test. It is possible to launch the function with any combination of the available tests.<ul>
<li>CY_CAPSENSE_BIST_CRC_WDGT_MASK - Verifies the RAM widget structure CRC for all the widgets.</li>
<li>CY_CAPSENSE_BIST_SNS_INTEGRITY_MASK - Checks all the sensors for a short to GND / VDD / other sensors.</li>
<li>CY_CAPSENSE_BIST_SNS_CAP_MASK - Measures all the sensors capacitance.</li>
<li>CY_CAPSENSE_BIST_ELTD_CAP_MASK - Measures all the electrodes capacitance (only for the fifth-generation CAPSENSE&trade;).</li>
<li>CY_CAPSENSE_BIST_SHIELD_CAP_MASK - Measures the shield capacitance.</li>
<li>CY_CAPSENSE_BIST_EXTERNAL_CAP_MASK - Measures the capacitance of the available external capacitors (only for the fourth-generation CAPSENSE&trade;).</li>
<li>CY_CAPSENSE_BIST_VDDA_MASK - Measures the VDDA voltage (only for the fourth-generation CAPSENSE&trade;).</li>
<li>CY_CAPSENSE_BIST_RUN_AVAILABLE_SELF_TEST_MASK<ul>
<li>Executes all available tests.</li>
</ul>
</li>
</ul>
</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a bit-mask with a status of execution of the specified tests:<ul>
<li>CY_CAPSENSE_BIST_SUCCESS_E - All the tests passed successfully.</li>
<li>CY_CAPSENSE_BIST_BAD_PARAM_E - A non-defined test was requested in the testEnMask parameter or the context is a NULL pointer. The function was not performed.</li>
<li>CY_CAPSENSE_BIST_HW_BUSY_E - The CSD HW block is busy with a previous operation. The function was not performed.</li>
<li>CY_CAPSENSE_BIST_ERROR_E - An unexpected fault occurred during the measurement, you may need to repeat the measurement.</li>
<li>CY_CAPSENSE_BIST_FAIL_E - Any of tests specified by the testEnMask parameters has faulted. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga50e6ef42f2834083715abe86d8a85b48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50e6ef42f2834083715abe86d8a85b48">&#9670;&nbsp;</a></span>Cy_CapSense_ScanAllWidgets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_ScanAllWidgets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiates scanning of all enabled widgets (and sensors) in the project. </p>
<p>Scanning is initiated only if no scan is in progress.</p>
<p>This function initiates a scan only for the first sensor in the first widget for the fourth-generation CAPSENSE&trade; or a scan for the first slot for the fifth-generation CAPSENSE&trade; and then exits the function. The scan for the remaining sensors(slots) are initiated in the interrupt-driven mode in the interrupt service routine (part of middleware) triggered at the end of each scan completion or by DMA controllers in the DMA mode. The status of the current scan should be checked by using the <a class="el" href="group__group__capsense__high__level.html#ga7f8739755bba6b51c274f45b569b9ba0" title="This function returns a status of the CAPSENSEâ„¢ middleware whether a scan is currently in progress o...">Cy_CapSense_IsBusy()</a> and wait until all scans is finished prior to starting a next scan or initializing another widget.</p>
<dl class="section note"><dt>Note</dt><dd>For the fifth-generation CAPSENSE&trade; it is recommended to use the <a class="el" href="group__group__capsense__high__level.html#ga045f3f46ff4e43c4f4dbe087c0156f56" title="Initiates the non-blocking scan of all slots. ">Cy_CapSense_ScanAllSlots()</a> function instead for compatibility with further CAPSENSE&trade; middleware versions.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the operation <a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>. </dd></dl>

</div>
</div>
<a id="gad98e953def0673cd879f01a00fb2d01b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad98e953def0673cd879f01a00fb2d01b">&#9670;&nbsp;</a></span>Cy_CapSense_ScanWidget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_ScanWidget </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>widgetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiates the scanning of all sensors in the widget. </p>
<p>Scanning is initiated only if no scan is in progress. Scan finishing can be checked by the <a class="el" href="group__group__capsense__high__level.html#ga7f8739755bba6b51c274f45b569b9ba0" title="This function returns a status of the CAPSENSEâ„¢ middleware whether a scan is currently in progress o...">Cy_CapSense_IsBusy()</a> function.</p>
<dl class="section note"><dt>Note</dt><dd>For the fifth-generation CAPSENSE&trade; this function is available in single-channel solution only. It is recommended to use the <a class="el" href="group__group__capsense__high__level.html#gaf10ce0cc817442374d2df04c9d241f9b" title="Initiates the non-blocking scan of specified slots. ">Cy_CapSense_ScanSlots()</a> function instead for compatibility with further CAPSENSE&trade; middleware versions.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">widgetId</td><td>Specifies the ID number of the widget. A macro for the widget ID can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;WIDGET_NAME&gt;_WDGT_ID.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the operation <a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>. </dd></dl>

</div>
</div>
<a id="ga7f8739755bba6b51c274f45b569b9ba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f8739755bba6b51c274f45b569b9ba0">&#9670;&nbsp;</a></span>Cy_CapSense_IsBusy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Cy_CapSense_IsBusy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns a status of the CAPSENSE&trade; middleware whether a scan is currently in progress or not. </p>
<p>If the middleware is busy, a new scan or setup widgets should not be initiated.</p>
<p>Use the <a class="el" href="group__group__capsense__high__level.html#ga1530a032b2c5239f7efde29fa23d1793" title="This function returns a detailed state of the CAPSENSEâ„¢ middleware and MSC hardware in Single- or Mu...">Cy_CapSense_MwState()</a> function to check a detailed CAPSENSE&trade; middleware state for the fifth-generation CAPSENSE&trade;.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the middleware as a sum of the masks.<ul>
<li>CY_CAPSENSE_NOT_BUSY - No scan is in progress and a next scan can be initiated.</li>
<li>CY_CAPSENSE_BUSY - The previously initiated scan is in progress. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaeab57caca852dae59618fbfbcd431c27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeab57caca852dae59618fbfbcd431c27">&#9670;&nbsp;</a></span>Cy_CapSense_InterruptHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_CapSense_InterruptHandler </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements interrupt service routine for CAPSENSE&trade; Middleware. </p>
<p>The MSC HW block generates an interrupt at end of every sensor scan. The CAPSENSE&trade; middleware uses this interrupt to implement a non-blocking sensor scan method, in which only the first sensor scan is initiated by the application program and subsequent sensor scans are initiated in the interrupt service routine as soon as the current scan is completed. The above stated interrupt service routine is implemented as a part of the CAPSENSE&trade; middleware.</p>
<p>The CAPSENSE&trade; middleware does not initialize or modify the priority of interrupts. For the operation of middleware, the application program must configure MSC interrupt and assign interrupt vector to the <a class="el" href="group__group__capsense__high__level.html#gaeab57caca852dae59618fbfbcd431c27" title="Implements interrupt service routine for CAPSENSEâ„¢ Middleware. ">Cy_CapSense_InterruptHandler()</a> function. Refer to function usage example for details.</p>
<p>The calls of the Start Sample and End Of Scan callbacks (see the <a class="el" href="group__group__capsense__callbacks.html">Callbacks</a> section for details) are the part of the <a class="el" href="group__group__capsense__high__level.html#gaeab57caca852dae59618fbfbcd431c27" title="Implements interrupt service routine for CAPSENSEâ„¢ Middleware. ">Cy_CapSense_InterruptHandler()</a> routine and they lengthen its execution. These callbacks will lengthen the ISR execution in case of a direct call of the <a class="el" href="group__group__capsense__high__level.html#gaeab57caca852dae59618fbfbcd431c27" title="Implements interrupt service routine for CAPSENSEâ„¢ Middleware. ">Cy_CapSense_InterruptHandler()</a> function from a ISR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the base register address of the CSD HW block. This argument is kept for uniformity and backward compatibility and is not used. The function can be called with value NULL.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function Usage</dt><dd></dd></dl>
<p>An example of the ISR initialization:</p>
<p>The CapSense_ISR_cfg variable should be declared by the application program according to the examples below:<br />
 For Core CM0+: </p><div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">    #if (!(CY_CAPSENSE_PSOC4_FIFTH_GEN))</span></div><div class="line">        <span class="keyword">const</span> cy_stc_sysint_t CapSense_ISR_cfg =</div><div class="line">        {</div><div class="line">            .intrSrc = csd_interrupt_IRQn,  <span class="comment">/* CM0+ interrupt is NVIC #2 */</span></div><div class="line">            .intrPriority = 3u,             <span class="comment">/* Interrupt priority is 3 */</span></div><div class="line">        };</div><div class="line"><span class="preprocessor">    #else</span></div><div class="line">        <span class="keyword">const</span> cy_stc_sysint_t CapSense_ISR_cfg =</div><div class="line">        {</div><div class="line">            .intrSrc = msc_0_interrupt_IRQn,  <span class="comment">/* CM0+ interrupt is NVIC #2 */</span></div><div class="line">            .intrPriority = 3u,             <span class="comment">/* Interrupt priority is 3 */</span></div><div class="line">        };</div><div class="line"><span class="preprocessor">    #endif</span></div><div class="line"></div></div><!-- fragment --><p> For Core CM4: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="keyword">const</span> cy_stc_sysint_t CapSense_ISR_cfg =</div><div class="line">    {</div><div class="line">        .intrSrc = csd_interrupt_IRQn, <span class="comment">/* Interrupt source is the CSD interrupt */</span></div><div class="line">        .intrPriority = 7u,            <span class="comment">/* Interrupt priority is 7 */</span></div><div class="line">    };</div><div class="line"></div></div><!-- fragment --><p> The CAPSENSE&trade; interrupt handler should be defined by the application program according to the example below: </p><div class="fragment"><div class="line"></div><div class="line"><span class="keywordtype">void</span> snippet_Cy_CapSense_IntHandler(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group__group__capsense__high__level.html#gaeab57caca852dae59618fbfbcd431c27">Cy_CapSense_InterruptHandler</a>(CapSense_HW, &amp;cy_capsense_context);</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p> Then, the application program should configure and enable the CSD block interrupt between calls of the <a class="el" href="group__group__capsense__high__level.html#ga19b3aa9e14a04b76188f917c0dc004f5" title="Captures HW blocks (one or more) for CAPSENSEâ„¢ operations and configures them to the default state...">Cy_CapSense_Init()</a> and <a class="el" href="group__group__capsense__high__level.html#gade28f1f915ce6b97f13399074a819c0d" title="Initializes the CAPSENSEâ„¢ firmware modules. ">Cy_CapSense_Enable()</a> functions: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Capture the CAPSENSE&amp;trade; HW block and initialize it to the default state. */</span></div><div class="line">    <a class="code" href="group__group__capsense__high__level.html#ga19b3aa9e14a04b76188f917c0dc004f5">Cy_CapSense_Init</a>(&amp;cy_capsense_context);</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize CAPSENSE&amp;trade; interrupt */</span></div><div class="line">    Cy_SysInt_Init(&amp;CapSense_ISR_cfg, &amp;snippet_Cy_CapSense_IntHandler);</div><div class="line">    NVIC_ClearPendingIRQ(CapSense_ISR_cfg.intrSrc);</div><div class="line">    NVIC_EnableIRQ(CapSense_ISR_cfg.intrSrc);</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize the CAPSENSE&amp;trade; firmware modules. */</span></div><div class="line">    <a class="code" href="group__group__capsense__high__level.html#gade28f1f915ce6b97f13399074a819c0d">Cy_CapSense_Enable</a>(&amp;cy_capsense_context);</div><div class="line"></div></div><!-- fragment --><p> CapSense_HW is the pointer to the base register address of the CSD HW block. A macro for the pointer can be found in the cycfg_peripherals.h file defined as &lt;Csd_Personality_Name&gt;_HW. If no name specified, the default name is used csd_&lt;Block_Number&gt;_csd_&lt;Block_Number&gt;_HW.</p>
<p>An example of sharing the CSD HW block by the CAPSENSE&trade; and CSDADC middleware.<br />
 Declares the CapSense_ISR_cfg variable: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="keyword">const</span> cy_stc_sysint_t CapSense_ISR_cfg =</div><div class="line">    {</div><div class="line">        .intrSrc = csd_interrupt_IRQn, <span class="comment">/* Interrupt source is the CSD interrupt */</span></div><div class="line">        .intrPriority = 7u,            <span class="comment">/* Interrupt priority is 7 */</span></div><div class="line">    };</div><div class="line"></div></div><!-- fragment --><p> Declares the CSDADC_ISR_cfg variable: </p><div class="fragment"><div class="line"></div><div class="line">        <span class="keyword">const</span> cy_stc_sysint_t CSDADC_ISR_cfg =</div><div class="line">        {</div><div class="line">            .intrSrc = csd_interrupt_IRQn, <span class="comment">/* Interrupt source is the CSD interrupt */</span></div><div class="line">            .intrPriority = 7u,            <span class="comment">/* Interrupt priority is 7 */</span></div><div class="line">        };</div><div class="line"></div></div><!-- fragment --><p> Defines the CAPSENSE&trade; interrupt handler: </p><div class="fragment"><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> CapSense_Interrupt(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group__group__capsense__high__level.html#gaeab57caca852dae59618fbfbcd431c27">Cy_CapSense_InterruptHandler</a>(CapSense_HW, &amp;cy_capsense_context);</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p> Defines the CSDADC interrupt handler: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> CSDADC_Interrupt(<span class="keywordtype">void</span>)</div><div class="line">    {</div><div class="line">        Cy_CSDADC_InterruptHandler(CSD0, &amp;cy_csd_0_context);</div><div class="line">    }</div><div class="line"></div></div><!-- fragment --><p> The part of the main.c FW flow: </p><div class="fragment"><div class="line">        <span class="comment">/* ... */</span></div><div class="line"></div><div class="line">        <span class="comment">/* Initialize CAPSENSE&amp;trade; MW */</span></div><div class="line">        <a class="code" href="group__group__capsense__high__level.html#ga19b3aa9e14a04b76188f917c0dc004f5">Cy_CapSense_Init</a>(&amp;cy_capsense_context);</div><div class="line">        Cy_SysInt_Init(&amp;CapSense_ISR_cfg, &amp;CapSense_Interrupt);</div><div class="line">        NVIC_ClearPendingIRQ(CapSense_ISR_cfg.intrSrc);</div><div class="line">        NVIC_EnableIRQ(CapSense_ISR_cfg.intrSrc);</div><div class="line">        <a class="code" href="group__group__capsense__high__level.html#gade28f1f915ce6b97f13399074a819c0d">Cy_CapSense_Enable</a>(&amp;cy_capsense_context);</div><div class="line">        <a class="code" href="group__group__capsense__high__level.html#ga899ef1058ead082503771da68e584b82">Cy_CapSense_Save</a>(&amp;cy_capsense_context);</div><div class="line"></div><div class="line">        <span class="comment">/* Initialize CSDADC MW */</span></div><div class="line">        Cy_CSDADC_Init(&amp;CapSense_csdadc_config, &amp;cy_csdadc_context);</div><div class="line">        Cy_SysInt_Init(&amp;CSDADC_ISR_cfg, &amp;CSDADC_Interrupt);</div><div class="line">        NVIC_ClearPendingIRQ(CSDADC_ISR_cfg.intrSrc);</div><div class="line">        NVIC_EnableIRQ(CSDADC_ISR_cfg.intrSrc);</div><div class="line">        Cy_CSDADC_Enable(&amp;cy_csdadc_context);</div><div class="line">        Cy_CSDADC_Save(&amp;cy_csdadc_context);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (;;)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Switch to CAPSENSE&amp;trade; MW */</span></div><div class="line">            <a class="code" href="group__group__capsense__high__level.html#gaf87102783ec511c2e5f2024680112d16">Cy_CapSense_Restore</a>(&amp;cy_capsense_context);</div><div class="line">            Cy_SysInt_Init(&amp;CapSense_ISR_cfg, &amp;CapSense_Interrupt);</div><div class="line">                <span class="comment">/* Do CAPSENSE&amp;trade; sensing operation */</span></div><div class="line">            <a class="code" href="group__group__capsense__high__level.html#ga899ef1058ead082503771da68e584b82">Cy_CapSense_Save</a>(&amp;cy_capsense_context);</div><div class="line"></div><div class="line">            <span class="comment">/* Switch to CSDADC MW */</span></div><div class="line">            Cy_CSDADC_Restore(&amp;cy_csdadc_context);</div><div class="line">            Cy_SysInt_Init(&amp;CSDADC_ISR_cfg, &amp;CSDADC_Interrupt);</div><div class="line">                <span class="comment">/* Do CSDADC measurement operation */</span></div><div class="line">            Cy_CSDADC_Save(&amp;cy_csdadc_context);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">/* ... */</span></div></div><!-- fragment -->
</div>
</div>
<a id="ga9f798069c57bf91f7ce2bc19bb086191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f798069c57bf91f7ce2bc19bb086191">&#9670;&nbsp;</a></span>Cy_CapSense_SetupWidget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_SetupWidget </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>widgetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the initialization required to scan the specified widget. </p>
<p>This function prepares the middleware to scan all the sensors in the specified widget by executing the following tasks:</p><ol type="1">
<li>Configure the CSD HW block if it is not configured to perform the sensing method used by the specified widget. This happens only if the CSD and CSX methods are used in a user's project.</li>
<li>Initialize the CSD HW block with specific sensing configuration (e.g. sensor clock, scan resolution) used by the widget.</li>
<li>Disconnect all previously connected electrodes, if the electrodes are connected by the Cy_CapSense_CSDSetupWidgetExt(), Cy_CapSense_CSXSetupWidgetExt(), or Cy_CapSense_CSDConnectSns() functions and are not disconnected.</li>
</ol>
<p>This function does not start sensor scanning. The <a class="el" href="group__group__capsense__high__level.html#ga6473761292c2696bdea571b8bb10b308" title="Initiates scanning of all the sensors in the widget initialized by Cy_CapSense_SetupWidget(), if no scan is in progress. ">Cy_CapSense_Scan()</a> function must be called to start the scan sensors in the widget. If this function is called more than once, it does not break the middleware operation, but only the last initialized widget is in effect.</p>
<p>The status of a sensor scan must be checked using the <a class="el" href="group__group__capsense__high__level.html#ga7f8739755bba6b51c274f45b569b9ba0" title="This function returns a status of the CAPSENSEâ„¢ middleware whether a scan is currently in progress o...">Cy_CapSense_IsBusy()</a> function prior to starting a next scan or setting up another widget.</p>
<dl class="section note"><dt>Note</dt><dd>This function is available only for the fourth-generation CAPSENSE&trade;.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">widgetId</td><td>Specifies the ID number of the widget. A macro for the widget ID can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;WIDGET_NAME&gt;_WDGT_ID.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the widget setting up operation:<ul>
<li>CY_CAPSENSE_STATUS_SUCCESS - The operation is successfully completed.</li>
<li>CY_CAPSENSE_STATUS_BAD_PARAM - The widget is invalid or if the specified widget is disabled.</li>
<li>CY_CAPSENSE_STATUS_INVALID_STATE - The previous scanning is not completed and the CSD HW block is busy.</li>
<li>CY_CAPSENSE_STATUS_UNKNOWN - An unknown sensing method is used by the widget or any other spurious error occurred. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga6473761292c2696bdea571b8bb10b308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6473761292c2696bdea571b8bb10b308">&#9670;&nbsp;</a></span>Cy_CapSense_Scan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_Scan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiates scanning of all the sensors in the widget initialized by <a class="el" href="group__group__capsense__high__level.html#ga9f798069c57bf91f7ce2bc19bb086191" title="Performs the initialization required to scan the specified widget. ">Cy_CapSense_SetupWidget()</a>, if no scan is in progress. </p>
<p>Prior to calling this function to scan sensors, the widget required to be scanned must be initialized using <a class="el" href="group__group__capsense__high__level.html#ga9f798069c57bf91f7ce2bc19bb086191" title="Performs the initialization required to scan the specified widget. ">Cy_CapSense_SetupWidget()</a> function.</p>
<p>This function initiates scan only for the first sensor in the widget and then exits the function. The scan for the remaining sensors in the widget is initiated in the interrupt service routine (part of middleware) triggered at the end of each scan completion. Hence, status of the current scan should be checked using the <a class="el" href="group__group__capsense__high__level.html#ga7f8739755bba6b51c274f45b569b9ba0" title="This function returns a status of the CAPSENSEâ„¢ middleware whether a scan is currently in progress o...">Cy_CapSense_IsBusy()</a> and wait until all scans in the current widget are finished prior to starting the next scan or initializing another widget.</p>
<dl class="section note"><dt>Note</dt><dd>This function is available only for the fourth-generation CAPSENSE&trade;.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the scan initiation operation:<ul>
<li>CY_CAPSENSE_STATUS_SUCCESS - Scanning is successfully started.</li>
<li>CY_CAPSENSE_STATUS_INVALID_STATE - The previous scan is not completed and the CSD HW block is busy.</li>
<li>CY_CAPSENSE_STATUS_UNKNOWN - An unknown sensing method is used by the widget. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga045f3f46ff4e43c4f4dbe087c0156f56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga045f3f46ff4e43c4f4dbe087c0156f56">&#9670;&nbsp;</a></span>Cy_CapSense_ScanAllSlots()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_ScanAllSlots </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiates the non-blocking scan of all slots. </p>
<p>Scanning is initiated only if no scan is in progress. Scan finishing can be checked by the <a class="el" href="group__group__capsense__high__level.html#ga7f8739755bba6b51c274f45b569b9ba0" title="This function returns a status of the CAPSENSEâ„¢ middleware whether a scan is currently in progress o...">Cy_CapSense_IsBusy()</a> function.</p>
<p>This function initiates a scan only for the first slot for all channels and then exits. Scans for the remaining slots in the Interrupt-driven scan mode are initiated in the interrupt service routine (part of middleware) triggered at the end of each scan completion for each channel. If the syncMode field in the <a class="el" href="structcy__stc__capsense__common__config__t.html" title="Common configuration structure. ">cy_stc_capsense_common_config_t</a> structure is set to CY_CAPSENSE_SYNC_MODE_OFF, then the next slot scan for the channel with the fired interrupt, will start regardless of the another channel readiness for the next scan. If the syncMode field is set to CY_CAPSENSE_SYNC_INTERNAL (for single-chip projects) or to CY_CAPSENSE_SYNC_EXTERNAL (for multi-chip projects), then the next slot scan for the channel with the fired interrupt, will start in lockstep with another channels after they all are ready for the next scan (the next scan configuration is loaded into the channel MSC HW block). Scans for the remaining slots in CS-DMA scan mode are initiated by DMAC triggered at the end of each scan completion for each channel. The channel scan synchronization is performed as in Interrupt-driven scan mode. After all slots are scanned, the FRAME interrupt is fired and the interrupt service routine (part of middleware) updates the busy status.</p>
<p>The status of the current scan should be checked using the <a class="el" href="group__group__capsense__high__level.html#ga7f8739755bba6b51c274f45b569b9ba0" title="This function returns a status of the CAPSENSEâ„¢ middleware whether a scan is currently in progress o...">Cy_CapSense_IsBusy()</a> function, where there are separate busy bits for each channel and the application program waits until all scans are finished prior to starting a next scan by using this function.</p>
<dl class="section note"><dt>Note</dt><dd>This function is available only for the fifth-generation CAPSENSE&trade;.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the operation:<ul>
<li>CY_CAPSENSE_STATUS_SUCCESS - The operation is performed successfully.</li>
<li>CY_CAPSENSE_STATUS_BAD_PARAM - The input parameter is invalid.</li>
<li>CY_CAPSENSE_STATUS_HW_BUSY - The HW is busy with the previous scan. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaf10ce0cc817442374d2df04c9d241f9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf10ce0cc817442374d2df04c9d241f9b">&#9670;&nbsp;</a></span>Cy_CapSense_ScanSlots()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_ScanSlots </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>startSlotId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numberSlots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiates the non-blocking scan of specified slots. </p>
<p>Scanning is initiated only if no scan is in progress. Scan finishing can be checked by the <a class="el" href="group__group__capsense__high__level.html#ga7f8739755bba6b51c274f45b569b9ba0" title="This function returns a status of the CAPSENSEâ„¢ middleware whether a scan is currently in progress o...">Cy_CapSense_IsBusy()</a> function.</p>
<p>This function initiates a scan only for the first specified slot for all channels and then exits. Scans for the remaining slots in the interrupt-driven scan mode are initiated in the interrupt service routine (part of middleware) triggered at the end of each scan completion for each channel. If the syncMode field in the <a class="el" href="structcy__stc__capsense__common__config__t.html" title="Common configuration structure. ">cy_stc_capsense_common_config_t</a> structure is set to CY_CAPSENSE_SYNC_MODE_OFF, then the next slot scan for the channel with the fired interrupt, will start regardless of the another channel readiness for the next scan. If the syncMode field is set to CY_CAPSENSE_SYNC_INTERNAL (for single-chip projects) or to CY_CAPSENSE_SYNC_EXTERNAL (for multi-chip projects), then the next slot scan for the channel with the fired interrupt, will start in lockstep with another channels after they all are ready for the next scan. The scan for the remaining slots in CS-DMA scan mode are initiated by DMAC triggered at the end of each scan completion for each channel. The channel scan synchronization is performed as in Interrupt-driven scan mode. After all slots are scanned, the FRAME interrupt is fired and the interrupt service routine (part of middleware) updates the busy status. To decrease the start scan time when it is intended to scan the same slot, i.e. the startSlotId parameter is the same and numberSlots = 1u, then the scan is performed without the MSC HW block reconfiguration. Also, in the AMUX mode sensors are not disconnected.</p>
<dl class="section note"><dt>Note</dt><dd>This function is available only for the fifth-generation CAPSENSE&trade;.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startSlotId</td><td>The slot ID scan will be started from.</td></tr>
    <tr><td class="paramname">numberSlots</td><td>The number of slots will be scanned.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the operation:<ul>
<li>CY_CAPSENSE_STATUS_SUCCESS - The operation is performed successfully.</li>
<li>CY_CAPSENSE_STATUS_BAD_PARAM - The input parameter is invalid.</li>
<li>CY_CAPSENSE_STATUS_HW_BUSY - The HW is busy with the previous scan. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga1530a032b2c5239f7efde29fa23d1793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1530a032b2c5239f7efde29fa23d1793">&#9670;&nbsp;</a></span>Cy_CapSense_MwState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gaae9a4f12c83f84c5a02079bb0eeeb3c9">cy_capsense_mw_state_t</a> Cy_CapSense_MwState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns a detailed state of the CAPSENSE&trade; middleware and MSC hardware in Single- or Multi-channel mode. </p>
<p>This feature is useful in multi-thread applications or in ISR. Use the <a class="el" href="group__group__capsense__high__level.html#ga7f8739755bba6b51c274f45b569b9ba0" title="This function returns a status of the CAPSENSEâ„¢ middleware whether a scan is currently in progress o...">Cy_CapSense_IsBusy()</a> function to verify if HW is busy at a particular moment.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the state of the middleware as a sum of the state and status masks:</dd></dl>
<ul>
<li>CY_CAPSENSE_BUSY_CH_MASK - The set [x] bit of the result means that the previously initiated scan for the [x] channel is in progress. The next scan frame cannot be started.</li>
<li>CY_CAPSENSE_BUSY - The previously initiated scan is in progress.</li>
<li>CY_CAPSENSE_MW_STATE_BIST_MASK - The BIST is in progress. The next scan frame cannot be started.</li>
<li>CY_CAPSENSE_MW_STATE_CALIBRATION_MASK - The auto-calibration is in progress. The next scan frame cannot be started.</li>
<li>CY_CAPSENSE_MW_STATE_SMARTSENSE_MASK - The smart sensing algorithm is in progress. The next scan frame cannot be started.</li>
<li>CY_CAPSENSE_MW_STATE_INITIALIZATION_MASK - Middleware initialization is in progress and the next scan frame cannot be initiated.</li>
<li>CY_CAPSENSE_MW_STATE_SCAN_SLOT_MASK[x] - The set [x] number of the result means that the previously initiated scan for the [x] slot is completed or in progress. In CS-DMA mode, this field is set only for the first scanned slot. </li>
</ul>

</div>
</div>
<a id="ga036e1061e289e038c3e13df5c8751aed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga036e1061e289e038c3e13df5c8751aed">&#9670;&nbsp;</a></span>Cy_CapSense_IsAnyWidgetActive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Cy_CapSense_IsAnyWidgetActive </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports whether any widget has detected touch. </p>
<p>This function reports whether any widget has detected a touch by extracting information from the widget status registers. This function does not process widget data but extracts previously processed results from the <a class="el" href="group__group__capsense__structures.html">Structures</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the touch detection status of all the widgets:<ul>
<li>Zero - No touch is detected in any of the widgets or sensors.</li>
<li>Non-zero - At least one widget or sensor has detected a touch. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga4afba79341aef27afc40054d376d7193"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4afba79341aef27afc40054d376d7193">&#9670;&nbsp;</a></span>Cy_CapSense_IsWidgetActive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Cy_CapSense_IsWidgetActive </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>widgetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports whether the specified widget detected touch on any of its sensors. </p>
<p>This function reports whether the specified widget has detected a touch by extracting information from the widget status register. This function does not process widget data but extracts previously processed results from the <a class="el" href="group__group__capsense__structures.html">Structures</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">widgetId</td><td>Specifies the ID number of the widget. A macro for the widget ID can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;WIDGET_NAME&gt;_WDGT_ID.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the touch detection status of the specified widgets:<ul>
<li>Zero - No touch is detected in the specified widget or a wrong widgetId is specified.</li>
<li>Non-zero if at least one sensor of the specified widget is active, i.e. a touch is detected. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaeaa2dc78e56e2fc1ec0cc2b265851d69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeaa2dc78e56e2fc1ec0cc2b265851d69">&#9670;&nbsp;</a></span>Cy_CapSense_IsSensorActive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Cy_CapSense_IsSensorActive </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>widgetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sensorId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports whether the specified sensor in the widget detected touch. </p>
<p>This function reports whether the specified sensor in the widget has detected a touch by extracting information from the widget status register. This function does not process widget or sensor data but extracts previously processed results from the <a class="el" href="group__group__capsense__structures.html">Structures</a>.</p>
<p>For proximity sensors, this function returns the proximity detection status. To get the touch status of proximity sensors, use the <a class="el" href="group__group__capsense__high__level.html#ga96509342c580a9c5f6e17bdf8c74e53a" title="Reports the status of the specified proximity widget/sensor. ">Cy_CapSense_IsProximitySensorActive()</a> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">widgetId</td><td>Specifies the ID number of the widget. A macro for the widget ID can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;WIDGET_NAME&gt;_WDGT_ID.</td></tr>
    <tr><td class="paramname">sensorId</td><td>Specifies the ID number of the sensor within the widget. A macro for the sensor ID within a specified widget can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;WIDGET_NAME&gt;_SNS&lt;SENSOR_NUMBER&gt;_ID.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the touch detection status of the specified sensor/widget:<ul>
<li>Zero if no touch is detected in the specified sensor/widget or a wrong widget ID/sensor ID is specified.</li>
<li>Non-zero if the specified sensor is active, i.e. touch is detected. If the specific sensor belongs to a proximity widget, the proximity detection status is returned. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga96509342c580a9c5f6e17bdf8c74e53a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga96509342c580a9c5f6e17bdf8c74e53a">&#9670;&nbsp;</a></span>Cy_CapSense_IsProximitySensorActive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Cy_CapSense_IsProximitySensorActive </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>widgetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sensorId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the status of the specified proximity widget/sensor. </p>
<p>This function reports whether the specified proximity sensor has detected a touch or proximity event by extracting information from the widget status register. This function is used only with proximity widgets. This function does not process widget data but extracts previously processed results from the <a class="el" href="group__group__capsense__structures.html">Structures</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">widgetId</td><td>Specifies the ID number of the widget. A macro for the widget ID can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;WIDGET_NAME&gt;_WDGT_ID.</td></tr>
    <tr><td class="paramname">sensorId</td><td>Specifies the ID number of the sensor within the widget. A macro for the sensor ID within a specified widget can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;WIDGET_NAME&gt;_SNS&lt;SENSOR_NUMBER&gt;_ID.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the specified sensor of the proximity widget. Zero indicates that no touch is detected in the specified sensor/widget or a wrong widgetId/proxId is specified.<ul>
<li>Bits [31..2] are reserved.</li>
<li>Bit [1] indicates that a touch is detected.</li>
<li>Bit [0] indicates that a proximity is detected. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga6192ba34167662ac9573c0a4cd71682f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6192ba34167662ac9573c0a4cd71682f">&#9670;&nbsp;</a></span>Cy_CapSense_GetTouchInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcy__stc__capsense__touch__t.html">cy_stc_capsense_touch_t</a>* Cy_CapSense_GetTouchInfo </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>widgetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the details of touch position detected on the specified touchpad, matrix buttons or slider widgets. </p>
<p>This function does not process widget data but extracts previously processed results from the <a class="el" href="group__group__capsense__structures.html">Structures</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">widgetId</td><td>Specifies the ID number of the widget. A macro for the widget ID can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;WIDGET_NAME&gt;_WDGT_ID.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the pointer to widget <a class="el" href="structcy__stc__capsense__touch__t.html" title="Declares touch structure used to store positions of Touchpad, Matrix buttons and Slider widgets...">cy_stc_capsense_touch_t</a> structure that contains number of positions and data about each position. </dd></dl>

</div>
</div>
<a id="ga0c613df550388c119fdab4e50341a6b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c613df550388c119fdab4e50341a6b4">&#9670;&nbsp;</a></span>Cy_CapSense_RunTuner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Cy_CapSense_RunTuner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Establishes synchronized operation between the CAPSENSE&trade; Middleware and the CAPSENSE&trade; Tuner tool. </p>
<p>This function is called periodically in the application program. It serves the CAPSENSE&trade; Tuner tool requests and commands to synchronize the operation. Mostly, the best place to call this function is between processing and next scanning. If the user changes some parameters in the Tuner tool, the middleware is re-started - the Tuner issues a restart command to be executed by this function.</p>
<p>The Tuner interface supports two communication protocol: EZI2C and UART.</p>
<p>To use an EZI2C-based tuner interface, only initialization of the EZI2C driver and interface is required in the application program. Refer to the I2C driver documentation for details of the protocol implementation and data package format by the EZI2C interface.</p>
<p>To use a UART-based tuner interface, the user must:</p><ul>
<li>Initialize the UART driver and interface</li>
<li>Use a callback function to facilitate data transmission and reception using the UART driver.</li>
</ul>
<p>The application program must:</p><ul>
<li>Form a transmission data packet</li>
<li>Validate the data package on receiver implementation prior to passing to the CAPSENSE&trade; Middleware.</li>
</ul>
<p>The transmission packet includes a CAPSENSE&trade; context structure sandwiched between a header (0x0D0A) and a tail (0x00FFFF), hence the package size is dependent on CAPSENSE&trade; context information. The receiver packet is 16-byte (fixed length) data explained under the <a class="el" href="group__group__capsense__high__level.html#ga1f0fdedcec1ad936f5e9e4ae28f17274" title="Checks command format, header, tail, CRC, etc. ">Cy_CapSense_CheckTunerCmdIntegrity()</a> function. The <a class="el" href="group__group__capsense__high__level.html#ga1f0fdedcec1ad936f5e9e4ae28f17274" title="Checks command format, header, tail, CRC, etc. ">Cy_CapSense_CheckTunerCmdIntegrity()</a> function is used to validate the received data package prior to passing it to the CAPSENSE&trade; middleware.</p>
<p>Periodical calling the <a class="el" href="group__group__capsense__high__level.html#ga0c613df550388c119fdab4e50341a6b4" title="Establishes synchronized operation between the CAPSENSEâ„¢ Middleware and the CAPSENSEâ„¢ Tuner tool...">Cy_CapSense_RunTuner()</a> function is:</p><ul>
<li>mandatory for operation of a UART-based tuner interface. The middleware operation is always synchronous to the Tuner tool.</li>
<li>optional to periodically call <a class="el" href="group__group__capsense__high__level.html#ga0c613df550388c119fdab4e50341a6b4" title="Establishes synchronized operation between the CAPSENSEâ„¢ Middleware and the CAPSENSEâ„¢ Tuner tool...">Cy_CapSense_RunTuner()</a> for EZI2C based interface.</li>
</ul>
<p>If the <a class="el" href="group__group__capsense__high__level.html#ga0c613df550388c119fdab4e50341a6b4" title="Establishes synchronized operation between the CAPSENSEâ„¢ Middleware and the CAPSENSEâ„¢ Tuner tool...">Cy_CapSense_RunTuner()</a> function is not periodically called by the application program, the middleware operation is asynchronous to the Tuner tool and the following disadvantages are applicable:</p><ul>
<li>The raw counts displayed in the CAPSENSE&trade; Tuner tool may be filtered and/or non-filtered. Result - noise and SNR measurements are not accurate.</li>
<li>The CAPSENSE&trade; Tuner tool can read sensor data (such as raw counts) from a scan multiply. Result - noise and SNR measurement are not accurate.</li>
<li>The CAPSENSE&trade; Tuner tool and Host controller should not change the parameters via the Tuner interface - in async mode this leads to abnormal behavior.</li>
<li>Displaying detected gestures may be missed.</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>This function executes received commands. Two commands CY_CAPSENSE_TU_CMD_ONE_SCAN_E and CY_CAPSENSE_TU_CMD_SUSPEND_E change the FW tuner module state to suspend. In this state, the function waits until CY_CAPSENSE_TU_CMD_RESUME_E is received. Use a callback mechanism of command receiving to avoid FW hanging. Refer to the Function Usage section for examples.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CAPSENSE&trade; context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return parameter indicates whether a middleware re-start was executed by this function or not:<ul>
<li>CY_CAPSENSE_STATUS_RESTART_DONE - Based on a received command, the CAPSENSE&trade; was re-initialized.</li>
<li>CY_CAPSENSE_STATUS_RESTART_NONE - Re-start was not executed by this function.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd></dd></dl>
<p>An example of synchronization with the Tuner tool using EzI2C: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* EZI2C Initialization and assignment of communication buffer to cy_capsense_tuner */</span></div><div class="line">    Cy_SCB_EZI2C_Init(EZI2C_HW, &amp;EZI2C_config, &amp;EZI2C_context);</div><div class="line">    Cy_SysInt_Init(&amp;EZI2C_ISR_cfg, &amp;EZI2C_Interrupt);</div><div class="line">    NVIC_EnableIRQ(EZI2C_ISR_cfg.intrSrc);</div><div class="line">    Cy_SCB_EZI2C_SetBuffer1(EZI2C_HW, (uint8 *)&amp;cy_capsense_tuner, <span class="keyword">sizeof</span>(cy_capsense_tuner), <span class="keyword">sizeof</span>(cy_capsense_tuner), &amp;EZI2C_context);</div><div class="line">    Cy_SCB_EZI2C_Enable(EZI2C_HW);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span>(;;)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">if</span> (<a class="code" href="group__group__capsense__macros__general.html#ga1bd45eed2be393b7f53c20f1bae2814e">CY_CAPSENSE_NOT_BUSY</a> == <a class="code" href="group__group__capsense__high__level.html#ga7f8739755bba6b51c274f45b569b9ba0">Cy_CapSense_IsBusy</a>(&amp;cy_capsense_context))</div><div class="line">        {</div><div class="line">            <a class="code" href="group__group__capsense__high__level.html#ga2a185db228d5cae975fbc92bd3bc6367">Cy_CapSense_ProcessAllWidgets</a>(&amp;cy_capsense_context);</div><div class="line">            <a class="code" href="group__group__capsense__high__level.html#ga0c613df550388c119fdab4e50341a6b4">Cy_CapSense_RunTuner</a>(&amp;cy_capsense_context);</div><div class="line"></div><div class="line"><span class="preprocessor">            #if (CY_CAPSENSE_PLATFORM_BLOCK_FIFTH_GEN)</span></div><div class="line">                <a class="code" href="group__group__capsense__high__level.html#ga045f3f46ff4e43c4f4dbe087c0156f56">Cy_CapSense_ScanAllSlots</a>(&amp;cy_capsense_context);</div><div class="line"><span class="preprocessor">            #else</span></div><div class="line">                <a class="code" href="group__group__capsense__high__level.html#ga50e6ef42f2834083715abe86d8a85b48">Cy_CapSense_ScanAllWidgets</a>(&amp;cy_capsense_context);</div><div class="line"><span class="preprocessor">            #endif</span></div><div class="line">        }</div><div class="line">    }</div><div class="line"></div></div><!-- fragment --><p> An example of synchronization with the Tuner tool using UART.<br />
 Tuner Send callback implementation: Transmitting data through UART interface: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> TunerSend(<span class="keywordtype">void</span> * context)</div><div class="line">{</div><div class="line">    uint8_t uartTxHeader[] = {0x0Du, 0x0Au};</div><div class="line">    uint8_t uartTxTail[] = {0x00u, 0xFFu, 0xFFu};</div><div class="line"></div><div class="line">    (void)context;</div><div class="line"></div><div class="line">    Cy_SCB_UART_PutArrayBlocking(UART_HW, &amp;(uartTxHeader[0u]), <span class="keyword">sizeof</span>(uartTxHeader));</div><div class="line">    Cy_SCB_UART_PutArrayBlocking(UART_HW, (uint8 *)&amp;cy_capsense_tuner, <span class="keyword">sizeof</span>(cy_capsense_tuner));</div><div class="line">    Cy_SCB_UART_PutArrayBlocking(UART_HW, uartTxTail, <span class="keyword">sizeof</span>(uartTxTail));</div><div class="line">}</div></div><!-- fragment --><p> Tuner Receive callback implementation: Receiving data from UART interface: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> TunerReceive(uint8_t ** packet, uint8_t ** tunerPacket, <span class="keywordtype">void</span> * context)</div><div class="line">{</div><div class="line">    uint32_t i;</div><div class="line">    (void) context;</div><div class="line">    <span class="keyword">static</span> uint32_t dataIndex = 0u;</div><div class="line">    <span class="keyword">static</span> uint8_t commandPacket[16u] = {0u};</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span>(0u != Cy_SCB_UART_GetNumInRxFifo(UART_HW))</div><div class="line">    {</div><div class="line">        commandPacket[dataIndex++] = (uint8_t)Cy_SCB_UART_Get(UART_HW);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (CY_CAPSENSE_COMMAND_PACKET_SIZE &lt;= dataIndex)</div><div class="line">        {</div><div class="line">            <span class="keywordflow">if</span> (CY_CAPSENSE_COMMAND_OK == <a class="code" href="group__group__capsense__high__level.html#ga1f0fdedcec1ad936f5e9e4ae28f17274">Cy_CapSense_CheckTunerCmdIntegrity</a>(&amp;commandPacket[0u]))</div><div class="line">            {</div><div class="line">                <span class="comment">/* Found a correct command, reset data index and assign pointers to buffers */</span></div><div class="line">                dataIndex = 0u;</div><div class="line">                *tunerPacket = (uint8_t *)&amp;cy_capsense_tuner;</div><div class="line">                *packet = &amp;commandPacket[0u];</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line">            }</div><div class="line">            <span class="keywordflow">else</span></div><div class="line">            {</div><div class="line">                <span class="comment">/* Command is not correct, remove the first byte in commandPacket FIFO */</span></div><div class="line">                dataIndex--;</div><div class="line">                <span class="keywordflow">for</span>(i = 0u; i &lt; (CY_CAPSENSE_COMMAND_PACKET_SIZE - 1u); i++)</div><div class="line">                {</div><div class="line">                    commandPacket[i] = commandPacket[i + 1u];</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p> A part of the main.c FW flow with registering callbacks: </p><div class="fragment"><div class="line">    <span class="comment">/*...*/</span></div><div class="line"></div><div class="line">    <span class="comment">/* Register communication callbacks */</span></div><div class="line">    cy_capsense_context.ptrInternalContext-&gt;ptrTunerSendCallback = TunerSend;</div><div class="line">    cy_capsense_context.ptrInternalContext-&gt;ptrTunerReceiveCallback = TunerReceive;</div><div class="line"></div><div class="line">    Cy_SCB_UART_Init(UART_HW, &amp;UART_config, &amp;UART_context);</div><div class="line">    Cy_SCB_UART_Enable(UART_HW);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span>(;;)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">if</span> (<a class="code" href="group__group__capsense__macros__general.html#ga1bd45eed2be393b7f53c20f1bae2814e">CY_CAPSENSE_NOT_BUSY</a> == <a class="code" href="group__group__capsense__high__level.html#ga7f8739755bba6b51c274f45b569b9ba0">Cy_CapSense_IsBusy</a>(&amp;cy_capsense_context))</div><div class="line">        {</div><div class="line">            <a class="code" href="group__group__capsense__high__level.html#ga2a185db228d5cae975fbc92bd3bc6367">Cy_CapSense_ProcessAllWidgets</a>(&amp;cy_capsense_context);</div><div class="line">            <span class="comment">/*</span></div><div class="line"><span class="comment">            * Cy_CapSense_RunTuner() calls periodically communication callbacks</span></div><div class="line"><span class="comment">            * for hence the Tuner tool are able to monitor sensor signals/statuses</span></div><div class="line"><span class="comment">            * and change CAPSENSE&amp;trade; parameters for easy tuning.</span></div><div class="line"><span class="comment">            */</span></div><div class="line">            <a class="code" href="group__group__capsense__high__level.html#ga0c613df550388c119fdab4e50341a6b4">Cy_CapSense_RunTuner</a>(&amp;cy_capsense_context);</div><div class="line"></div><div class="line"><span class="preprocessor">            #if (CY_CAPSENSE_PLATFORM_BLOCK_FIFTH_GEN)</span></div><div class="line">                <a class="code" href="group__group__capsense__high__level.html#ga045f3f46ff4e43c4f4dbe087c0156f56">Cy_CapSense_ScanAllSlots</a>(&amp;cy_capsense_context);</div><div class="line"><span class="preprocessor">            #else</span></div><div class="line">                <a class="code" href="group__group__capsense__high__level.html#ga50e6ef42f2834083715abe86d8a85b48">Cy_CapSense_ScanAllWidgets</a>(&amp;cy_capsense_context);</div><div class="line"><span class="preprocessor">            #endif</span></div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="comment">/*...*/</span></div><div class="line"></div></div><!-- fragment --><p> Refer to the <a class="el" href="group__group__capsense__callbacks.html">Callbacks</a> section for details. </p>

</div>
</div>
<a id="ga1f0fdedcec1ad936f5e9e4ae28f17274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f0fdedcec1ad936f5e9e4ae28f17274">&#9670;&nbsp;</a></span>Cy_CapSense_CheckTunerCmdIntegrity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Cy_CapSense_CheckTunerCmdIntegrity </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>commandPacket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks command format, header, tail, CRC, etc. </p>
<p>This function checks whether the specified packet with the size CY_CAPSENSE_COMMAND_PACKET_SIZE could be represented as a command received from the CAPSENSE&trade; Tuner tool. The verification includes the following items:</p><ul>
<li>Header</li>
<li>Tail</li>
<li>CRC</li>
<li>Command code</li>
</ul>
<p>Command format is the following:</p><ul>
<li>Byte 0: Header 0 = 0x0D</li>
<li>Byte 1: Header 1 = 0x0A</li>
<li>Byte 2: Command code = cy_en_capsense_tuner_cmd_t</li>
<li>Byte 3: Command counter</li>
<li>Byte 4: Size = either 1, 2 or 4</li>
<li>Byte 5: Offset MSB</li>
<li>Byte 6: Offset LSB</li>
<li>Byte 7: Data MSB</li>
<li>Byte 8: Data</li>
<li>Byte 9: Data</li>
<li>Byte 10: Data LSB</li>
<li>Byte 11: 16-bit CRC MSB</li>
<li>Byte 12: 16-bit CRC LSB</li>
<li>Byte 13: Tail 0 = 0x00</li>
<li>Byte 14: Tail 1 = 0xFF</li>
<li>Byte 15: Tail 2 = 0xFF</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandPacket</td><td>The pointer to the data packet that should be verified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result of the command verification:<ul>
<li>CY_CAPSENSE_COMMAND_OK - Command is correct.</li>
<li>CY_CAPSENSE_WRONG_HEADER - Wrong header.</li>
<li>CY_CAPSENSE_WRONG_TAIL - Wrong tail.</li>
<li>CY_CAPSENSE_WRONG_CRC - Wrong CRC.</li>
<li>CY_CAPSENSE_WRONG_CODE - Wrong Command code. </li>
</ul>
</dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>CAPSENSE&trade; Middleware Library 3.0</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>

<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CapSense Middleware Library 3.0 (Alpha): High-level Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="IFXCYP_one-line.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CapSense Middleware Library 3.0 (Alpha)</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group__capsense__high__level.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">High-level Functions</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<p>High-level functions represent the highest abstraction layer of the CapSense middleware. </p>
<p>These functions perform tasks such as scanning, data processing, data reporting and tuning interfaces. When performing a task, different initialization is required based on a sensing method or type of widgets is automatically handled by these functions. Therefore, these functions are sensing methods, features, and widget type agnostics.</p>
<p>All the tasks required to implement a sensing system can be fulfilled by the high-level functions. But, there is a set of <a class="el" href="group__group__capsense__low__level.html">Low-level Functions</a> that provides access to lower level and specific tasks. If a design requires access to low-level tasks, these functions can be used. The functions related to a given sensing methods are not available if the corresponding method is disabled. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga19b3aa9e14a04b76188f917c0dc004f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__high__level.html#ga19b3aa9e14a04b76188f917c0dc004f5">Cy_CapSense_Init</a> (<a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga19b3aa9e14a04b76188f917c0dc004f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Captures HW blocks (one or more) for CapSense operations and configures them to the default state.  <a href="#ga19b3aa9e14a04b76188f917c0dc004f5">More...</a><br /></td></tr>
<tr class="separator:ga19b3aa9e14a04b76188f917c0dc004f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b8a365213dde3be6c6932dc23fdcee6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__high__level.html#ga7b8a365213dde3be6c6932dc23fdcee6">Cy_CapSense_DeInit</a> (<a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga7b8a365213dde3be6c6932dc23fdcee6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops the middleware operation and releases the CapSense captured HW blocks.  <a href="#ga7b8a365213dde3be6c6932dc23fdcee6">More...</a><br /></td></tr>
<tr class="separator:ga7b8a365213dde3be6c6932dc23fdcee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade28f1f915ce6b97f13399074a819c0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__high__level.html#gade28f1f915ce6b97f13399074a819c0d">Cy_CapSense_Enable</a> (<a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:gade28f1f915ce6b97f13399074a819c0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the CapSense firmware modules.  <a href="#gade28f1f915ce6b97f13399074a819c0d">More...</a><br /></td></tr>
<tr class="separator:gade28f1f915ce6b97f13399074a819c0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga899ef1058ead082503771da68e584b82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__high__level.html#ga899ef1058ead082503771da68e584b82">Cy_CapSense_Save</a> (<a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga899ef1058ead082503771da68e584b82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves the state of CapSense so the functionality can be restored using the <a class="el" href="group__group__capsense__high__level.html#gaf87102783ec511c2e5f2024680112d16" title="Resumes the middleware operation if the Cy_CapSense_Save() function was called previously. ">Cy_CapSense_Restore()</a> function.  <a href="#ga899ef1058ead082503771da68e584b82">More...</a><br /></td></tr>
<tr class="separator:ga899ef1058ead082503771da68e584b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf87102783ec511c2e5f2024680112d16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__high__level.html#gaf87102783ec511c2e5f2024680112d16">Cy_CapSense_Restore</a> (<a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:gaf87102783ec511c2e5f2024680112d16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resumes the middleware operation if the <a class="el" href="group__group__capsense__high__level.html#ga899ef1058ead082503771da68e584b82" title="Saves the state of CapSense so the functionality can be restored using the Cy_CapSense_Restore() func...">Cy_CapSense_Save()</a> function was called previously.  <a href="#gaf87102783ec511c2e5f2024680112d16">More...</a><br /></td></tr>
<tr class="separator:gaf87102783ec511c2e5f2024680112d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a185db228d5cae975fbc92bd3bc6367"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__high__level.html#ga2a185db228d5cae975fbc92bd3bc6367">Cy_CapSense_ProcessAllWidgets</a> (<a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga2a185db228d5cae975fbc92bd3bc6367"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs full data processing of all enabled widgets.  <a href="#ga2a185db228d5cae975fbc92bd3bc6367">More...</a><br /></td></tr>
<tr class="separator:ga2a185db228d5cae975fbc92bd3bc6367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52874ea98333723ec92aef1bb4791a7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__high__level.html#ga52874ea98333723ec92aef1bb4791a7d">Cy_CapSense_ProcessWidget</a> (uint32_t widgetId, <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga52874ea98333723ec92aef1bb4791a7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs full data processing of the specified widget if it is enabled.  <a href="#ga52874ea98333723ec92aef1bb4791a7d">More...</a><br /></td></tr>
<tr class="separator:ga52874ea98333723ec92aef1bb4791a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga904eb69e694e4daf45bc778281b39d9e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__high__level.html#ga904eb69e694e4daf45bc778281b39d9e">Cy_CapSense_IncrementGestureTimestamp</a> (<a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga904eb69e694e4daf45bc778281b39d9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments the timestamp register for the predefined timestamp interval.  <a href="#ga904eb69e694e4daf45bc778281b39d9e">More...</a><br /></td></tr>
<tr class="separator:ga904eb69e694e4daf45bc778281b39d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf0789f59e23077cba0005b1499468f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__high__level.html#gabf0789f59e23077cba0005b1499468f9">Cy_CapSense_SetGestureTimestamp</a> (uint32_t value, <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:gabf0789f59e23077cba0005b1499468f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrites the timestamp register by the specified value.  <a href="#gabf0789f59e23077cba0005b1499468f9">More...</a><br /></td></tr>
<tr class="separator:gabf0789f59e23077cba0005b1499468f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9436a7ec9b18880dbc046e91462710b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__high__level.html#gaf9436a7ec9b18880dbc046e91462710b">Cy_CapSense_Wakeup</a> (const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:gaf9436a7ec9b18880dbc046e91462710b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resumes the middleware after System Deep Sleep.  <a href="#gaf9436a7ec9b18880dbc046e91462710b">More...</a><br /></td></tr>
<tr class="separator:gaf9436a7ec9b18880dbc046e91462710b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c47887109b22521eba45109b7a27f31"><td class="memItemLeft" align="right" valign="top">cy_en_syspm_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__high__level.html#ga9c47887109b22521eba45109b7a27f31">Cy_CapSense_DeepSleepCallback</a> (cy_stc_syspm_callback_params_t *callbackParams, cy_en_syspm_callback_mode_t mode)</td></tr>
<tr class="memdesc:ga9c47887109b22521eba45109b7a27f31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles CPU active to System Deep Sleep power mode transition for the CapSense middleware.  <a href="#ga9c47887109b22521eba45109b7a27f31">More...</a><br /></td></tr>
<tr class="separator:ga9c47887109b22521eba45109b7a27f31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga289c4fd495135399a9ad9897920836a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__high__level.html#ga289c4fd495135399a9ad9897920836a7">Cy_CapSense_RegisterCallback</a> (<a class="el" href="group__group__capsense__enums.html#gabfbff81b8b80d4ee1a1d53c1fe0c9a11">cy_en_capsense_callback_event_t</a> callbackType, <a class="el" href="group__group__capsense__structures.html#ga908447ccc2720f31c861d9eb79ff75d2">cy_capsense_callback_t</a> callbackFunction, <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga289c4fd495135399a9ad9897920836a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a ures's callback function.  <a href="#ga289c4fd495135399a9ad9897920836a7">More...</a><br /></td></tr>
<tr class="separator:ga289c4fd495135399a9ad9897920836a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf43b3cdfce7a3e8c0e5622f42e0a6319"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__high__level.html#gaf43b3cdfce7a3e8c0e5622f42e0a6319">Cy_CapSense_UnRegisterCallback</a> (<a class="el" href="group__group__capsense__enums.html#gabfbff81b8b80d4ee1a1d53c1fe0c9a11">cy_en_capsense_callback_event_t</a> callbackType, <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:gaf43b3cdfce7a3e8c0e5622f42e0a6319"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function unregisters a previously registered user's callback function in the CapSense middleware.  <a href="#gaf43b3cdfce7a3e8c0e5622f42e0a6319">More...</a><br /></td></tr>
<tr class="separator:gaf43b3cdfce7a3e8c0e5622f42e0a6319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55fa694191705971b3aa2c29021fb9aa"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__high__level.html#ga55fa694191705971b3aa2c29021fb9aa">Cy_CapSense_DecodeWidgetGestures</a> (uint32_t widgetId, const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga55fa694191705971b3aa2c29021fb9aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs decoding of all gestures for the specified widget.  <a href="#ga55fa694191705971b3aa2c29021fb9aa">More...</a><br /></td></tr>
<tr class="separator:ga55fa694191705971b3aa2c29021fb9aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga045f3f46ff4e43c4f4dbe087c0156f56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__high__level.html#ga045f3f46ff4e43c4f4dbe087c0156f56">Cy_CapSense_ScanAllSlots</a> (<a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga045f3f46ff4e43c4f4dbe087c0156f56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiates the non-blocking scan of all slots.  <a href="#ga045f3f46ff4e43c4f4dbe087c0156f56">More...</a><br /></td></tr>
<tr class="separator:ga045f3f46ff4e43c4f4dbe087c0156f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf10ce0cc817442374d2df04c9d241f9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__high__level.html#gaf10ce0cc817442374d2df04c9d241f9b">Cy_CapSense_ScanSlots</a> (uint32_t startSlotId, uint32_t numberSlots, <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:gaf10ce0cc817442374d2df04c9d241f9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiates the non-blocking scan of specified slots.  <a href="#gaf10ce0cc817442374d2df04c9d241f9b">More...</a><br /></td></tr>
<tr class="separator:gaf10ce0cc817442374d2df04c9d241f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50e6ef42f2834083715abe86d8a85b48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__high__level.html#ga50e6ef42f2834083715abe86d8a85b48">Cy_CapSense_ScanAllWidgets</a> (<a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga50e6ef42f2834083715abe86d8a85b48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiates the non-blocking scan for all widgets/sensors.  <a href="#ga50e6ef42f2834083715abe86d8a85b48">More...</a><br /></td></tr>
<tr class="separator:ga50e6ef42f2834083715abe86d8a85b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad98e953def0673cd879f01a00fb2d01b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__high__level.html#gad98e953def0673cd879f01a00fb2d01b">Cy_CapSense_ScanWidget</a> (uint32_t widgetId, <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:gad98e953def0673cd879f01a00fb2d01b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiates the scanning of all sensors in the widget.  <a href="#gad98e953def0673cd879f01a00fb2d01b">More...</a><br /></td></tr>
<tr class="separator:gad98e953def0673cd879f01a00fb2d01b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3f80b48c2596c149ca0b392a9a3da62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__high__level.html#gae3f80b48c2596c149ca0b392a9a3da62">Cy_CapSense_ScanSensor</a> (uint32_t widgetId, uint32_t sensorId, <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:gae3f80b48c2596c149ca0b392a9a3da62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiates the scanning of the selected sensor in the widget.  <a href="#gae3f80b48c2596c149ca0b392a9a3da62">More...</a><br /></td></tr>
<tr class="separator:gae3f80b48c2596c149ca0b392a9a3da62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f8739755bba6b51c274f45b569b9ba0"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__high__level.html#ga7f8739755bba6b51c274f45b569b9ba0">Cy_CapSense_IsBusy</a> (const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga7f8739755bba6b51c274f45b569b9ba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns a status of the CapSense middleware whether a scan is currently in progress or not.  <a href="#ga7f8739755bba6b51c274f45b569b9ba0">More...</a><br /></td></tr>
<tr class="separator:ga7f8739755bba6b51c274f45b569b9ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga694cd350c85fcdc9dd1bc984a91d2c38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__high__level.html#ga694cd350c85fcdc9dd1bc984a91d2c38">Cy_CapSense_InterruptHandler</a> (const MSC_Type *base, <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga694cd350c85fcdc9dd1bc984a91d2c38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements interrupt service routine for CapSense Middleware.  <a href="#ga694cd350c85fcdc9dd1bc984a91d2c38">More...</a><br /></td></tr>
<tr class="separator:ga694cd350c85fcdc9dd1bc984a91d2c38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga036e1061e289e038c3e13df5c8751aed"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__high__level.html#ga036e1061e289e038c3e13df5c8751aed">Cy_CapSense_IsAnyWidgetActive</a> (const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga036e1061e289e038c3e13df5c8751aed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports whether any widget has detected touch.  <a href="#ga036e1061e289e038c3e13df5c8751aed">More...</a><br /></td></tr>
<tr class="separator:ga036e1061e289e038c3e13df5c8751aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4afba79341aef27afc40054d376d7193"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__high__level.html#ga4afba79341aef27afc40054d376d7193">Cy_CapSense_IsWidgetActive</a> (uint32_t widgetId, const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga4afba79341aef27afc40054d376d7193"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports whether the specified widget detected touch on any of its sensors.  <a href="#ga4afba79341aef27afc40054d376d7193">More...</a><br /></td></tr>
<tr class="separator:ga4afba79341aef27afc40054d376d7193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeaa2dc78e56e2fc1ec0cc2b265851d69"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__high__level.html#gaeaa2dc78e56e2fc1ec0cc2b265851d69">Cy_CapSense_IsSensorActive</a> (uint32_t widgetId, uint32_t sensorId, const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:gaeaa2dc78e56e2fc1ec0cc2b265851d69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports whether the specified sensor in the widget detected touch.  <a href="#gaeaa2dc78e56e2fc1ec0cc2b265851d69">More...</a><br /></td></tr>
<tr class="separator:gaeaa2dc78e56e2fc1ec0cc2b265851d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96509342c580a9c5f6e17bdf8c74e53a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__high__level.html#ga96509342c580a9c5f6e17bdf8c74e53a">Cy_CapSense_IsProximitySensorActive</a> (uint32_t widgetId, uint32_t sensorId, const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga96509342c580a9c5f6e17bdf8c74e53a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the status of the specified proximity widget/sensor.  <a href="#ga96509342c580a9c5f6e17bdf8c74e53a">More...</a><br /></td></tr>
<tr class="separator:ga96509342c580a9c5f6e17bdf8c74e53a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6192ba34167662ac9573c0a4cd71682f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcy__stc__capsense__touch__t.html">cy_stc_capsense_touch_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__high__level.html#ga6192ba34167662ac9573c0a4cd71682f">Cy_CapSense_GetTouchInfo</a> (uint32_t widgetId, const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga6192ba34167662ac9573c0a4cd71682f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the details of touch position detected on the specified touchpad, matrix buttons or slider widgets.  <a href="#ga6192ba34167662ac9573c0a4cd71682f">More...</a><br /></td></tr>
<tr class="separator:ga6192ba34167662ac9573c0a4cd71682f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c613df550388c119fdab4e50341a6b4"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__high__level.html#ga0c613df550388c119fdab4e50341a6b4">Cy_CapSense_RunTuner</a> (<a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *context)</td></tr>
<tr class="memdesc:ga0c613df550388c119fdab4e50341a6b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes synchronized operation between the CapSense Middleware and the CapSense Tuner tool.  <a href="#ga0c613df550388c119fdab4e50341a6b4">More...</a><br /></td></tr>
<tr class="separator:ga0c613df550388c119fdab4e50341a6b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f0fdedcec1ad936f5e9e4ae28f17274"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__capsense__high__level.html#ga1f0fdedcec1ad936f5e9e4ae28f17274">Cy_CapSense_CheckTunerCmdIntegrity</a> (const uint8_t *commandPacket)</td></tr>
<tr class="memdesc:ga1f0fdedcec1ad936f5e9e4ae28f17274"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks command format, header, tail, CRC, etc.  <a href="#ga1f0fdedcec1ad936f5e9e4ae28f17274">More...</a><br /></td></tr>
<tr class="separator:ga1f0fdedcec1ad936f5e9e4ae28f17274"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga19b3aa9e14a04b76188f917c0dc004f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19b3aa9e14a04b76188f917c0dc004f5">&#9670;&nbsp;</a></span>Cy_CapSense_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Captures HW blocks (one or more) for CapSense operations and configures them to the default state. </p>
<p>Call this function with the application program prior to calling any other function of the middleware.</p>
<p>The following tasks are executed:</p><ol type="1">
<li>Capturing not used HW blocks. If any of HW block is already in use, then the function returns the fail status, and the application program should perform corresponding actions. For example, releasing the HW block captured by another middleware.</li>
<li>If the HW block has been captured successfully, this function configures it to the default state.</li>
</ol>
<p>After the middleware is configured using the <a class="el" href="group__group__capsense__high__level.html#ga19b3aa9e14a04b76188f917c0dc004f5" title="Captures HW blocks (one or more) for CapSense operations and configures them to the default state...">Cy_CapSense_Init()</a> function, the application program configures and enables the HW block interrupt(s), and then call of the <a class="el" href="group__group__capsense__high__level.html#gade28f1f915ce6b97f13399074a819c0d" title="Initializes the CapSense firmware modules. ">Cy_CapSense_Enable()</a> function to complete the middleware initialization process. See the function usage example below for more details.</p>
<p>When the middleware operation is stopped by the <a class="el" href="group__group__capsense__high__level.html#ga7b8a365213dde3be6c6932dc23fdcee6" title="Stops the middleware operation and releases the CapSense captured HW blocks. ">Cy_CapSense_DeInit()</a> function, subsequent call of the <a class="el" href="group__group__capsense__high__level.html#ga19b3aa9e14a04b76188f917c0dc004f5" title="Captures HW blocks (one or more) for CapSense operations and configures them to the default state...">Cy_CapSense_Init()</a> function repeats initialization process and it is not needed to call the <a class="el" href="group__group__capsense__high__level.html#gade28f1f915ce6b97f13399074a819c0d" title="Initializes the CapSense firmware modules. ">Cy_CapSense_Enable()</a> function second time. However, to implement time-multiplexed mode (sharing the HW block(s) between multiple middleware) the <a class="el" href="group__group__capsense__high__level.html#ga899ef1058ead082503771da68e584b82" title="Saves the state of CapSense so the functionality can be restored using the Cy_CapSense_Restore() func...">Cy_CapSense_Save()</a> and <a class="el" href="group__group__capsense__high__level.html#gaf87102783ec511c2e5f2024680112d16" title="Resumes the middleware operation if the Cy_CapSense_Save() function was called previously. ">Cy_CapSense_Restore()</a> functions should be used instead of the <a class="el" href="group__group__capsense__high__level.html#ga7b8a365213dde3be6c6932dc23fdcee6" title="Stops the middleware operation and releases the CapSense captured HW blocks. ">Cy_CapSense_DeInit()</a> and <a class="el" href="group__group__capsense__high__level.html#ga19b3aa9e14a04b76188f917c0dc004f5" title="Captures HW blocks (one or more) for CapSense operations and configures them to the default state...">Cy_CapSense_Init()</a> functions for further compatibility.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CapSense context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> generated by the CapSense Configurator tool. The structure contains both, CapSense configuration and internal data and it is used during whole CapSense operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the initialization process. If CY_CAPSENSE_STATUS_SUCCESS is not received, some of the initialization fails, the middleware may not operate as expected, and repeating of initialization is required.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd></dd></dl>
<div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Capture the CapSense HW block and initialize it to the default state. */</span></div><div class="line">    <a class="code" href="group__group__capsense__high__level.html#ga19b3aa9e14a04b76188f917c0dc004f5">Cy_CapSense_Init</a>(&amp;cy_capsense_context);</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize CapSense interrupt */</span></div><div class="line">    Cy_SysInt_Init(&amp;CapSense_ISR_cfg, &amp;snippet_Cy_CapSense_IntHandler);</div><div class="line">    NVIC_ClearPendingIRQ(CapSense_ISR_cfg.intrSrc);</div><div class="line">    NVIC_EnableIRQ(CapSense_ISR_cfg.intrSrc);</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize the CapSense firmware modules. */</span></div><div class="line">    <a class="code" href="group__group__capsense__high__level.html#gade28f1f915ce6b97f13399074a819c0d">Cy_CapSense_Enable</a>(&amp;cy_capsense_context);</div><div class="line"></div></div><!-- fragment --><p>The 'cy_capsense_context' variable that is used as the parameter of the <a class="el" href="group__group__capsense__high__level.html#ga19b3aa9e14a04b76188f917c0dc004f5" title="Captures HW blocks (one or more) for CapSense operations and configures them to the default state...">Cy_CapSense_Init()</a> and <a class="el" href="group__group__capsense__high__level.html#gade28f1f915ce6b97f13399074a819c0d" title="Initializes the CapSense firmware modules. ">Cy_CapSense_Enable()</a> functions is declared in the cycfg_capsense.h file.</p>
<p>The CapSense_ISR_cfg variable should be declared by the application program according to the examples below:<br />
 For PSoC4 CPU or for PSoC6 CM0+ core: </p><div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">    #if (!defined(CY_IP_M0S8MSCV3))</span></div><div class="line">        <span class="keyword">const</span> cy_stc_sysint_t CapSense_ISR_cfg =</div><div class="line">        {</div><div class="line">            .intrSrc = csd_interrupt_IRQn,  <span class="comment">/* CM0+ interrupt is NVIC #2 */</span></div><div class="line">            .intrPriority = 3u,             <span class="comment">/* Interrupt priority is 3 */</span></div><div class="line">        };</div><div class="line"><span class="preprocessor">    #else</span></div><div class="line">        <span class="keyword">const</span> cy_stc_sysint_t CapSense_ISR_cfg =</div><div class="line">        {</div><div class="line">            .intrSrc = msc_0_interrupt_IRQn,  <span class="comment">/* CM0+ interrupt is NVIC #2 */</span></div><div class="line">            .intrPriority = 3u,             <span class="comment">/* Interrupt priority is 3 */</span></div><div class="line">        };</div><div class="line"><span class="preprocessor">    #endif</span></div><div class="line"></div></div><!-- fragment --><p> The CapSense interrupt handler should be declared by the application program according to the example below: </p><div class="fragment"><div class="line"></div><div class="line"><span class="keywordtype">void</span> snippet_Cy_CapSense_IntHandler(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group__group__capsense__high__level.html#ga694cd350c85fcdc9dd1bc984a91d2c38">Cy_CapSense_InterruptHandler</a>(CapSense_HW, &amp;cy_capsense_context);</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p> The CY_MSC&lt;X&gt;_HW is the pointer to the base register address of the MSC_X HW block. A macro for the pointer is in the cycfg_peripherals.h file defined as &lt;Msc_Personality_Name&gt;_HW. If no name is specified, the default msc_&lt;Block_Number&gt;_msc_&lt;Block_Number&gt;_HW is used. </p>

</div>
</div>
<a id="ga7b8a365213dde3be6c6932dc23fdcee6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b8a365213dde3be6c6932dc23fdcee6">&#9670;&nbsp;</a></span>Cy_CapSense_DeInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_DeInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stops the middleware operation and releases the CapSense captured HW blocks. </p>
<p>No sensor scanning can be executed when the middleware is stopped. This function should be called only when no scanning is in progress. I.e. <a class="el" href="group__group__capsense__high__level.html#ga7f8739755bba6b51c274f45b569b9ba0" title="This function returns a status of the CapSense middleware whether a scan is currently in progress or ...">Cy_CapSense_IsBusy()</a> returns a non-busy status.</p>
<p>After the middleware stops, the MSC HW block(s) may be reconfigured with the application program or other middleware for any other usage.</p>
<p>When the middleware operation is stopped by the <a class="el" href="group__group__capsense__high__level.html#ga7b8a365213dde3be6c6932dc23fdcee6" title="Stops the middleware operation and releases the CapSense captured HW blocks. ">Cy_CapSense_DeInit()</a> function, subsequent call of the <a class="el" href="group__group__capsense__high__level.html#ga19b3aa9e14a04b76188f917c0dc004f5" title="Captures HW blocks (one or more) for CapSense operations and configures them to the default state...">Cy_CapSense_Init()</a> function repeats initialization process and it is not needed to call the <a class="el" href="group__group__capsense__high__level.html#gade28f1f915ce6b97f13399074a819c0d" title="Initializes the CapSense firmware modules. ">Cy_CapSense_Enable()</a> function second time. However, to implement time-multiplexed mode (sharing the MSC HW block(s) between multiple middleware) the <a class="el" href="group__group__capsense__high__level.html#ga899ef1058ead082503771da68e584b82" title="Saves the state of CapSense so the functionality can be restored using the Cy_CapSense_Restore() func...">Cy_CapSense_Save()</a> and <a class="el" href="group__group__capsense__high__level.html#gaf87102783ec511c2e5f2024680112d16" title="Resumes the middleware operation if the Cy_CapSense_Save() function was called previously. ">Cy_CapSense_Restore()</a> functions should be used instead of the <a class="el" href="group__group__capsense__high__level.html#ga7b8a365213dde3be6c6932dc23fdcee6" title="Stops the middleware operation and releases the CapSense captured HW blocks. ">Cy_CapSense_DeInit()</a> and <a class="el" href="group__group__capsense__high__level.html#ga19b3aa9e14a04b76188f917c0dc004f5" title="Captures HW blocks (one or more) for CapSense operations and configures them to the default state...">Cy_CapSense_Init()</a> functions for further compatibility.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CapSense context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the stop process. If CY_CAPSENSE_STATUS_SUCCESS is not received, the stop process fails and retries may be required. </dd></dl>

</div>
</div>
<a id="gade28f1f915ce6b97f13399074a819c0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade28f1f915ce6b97f13399074a819c0d">&#9670;&nbsp;</a></span>Cy_CapSense_Enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_Enable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the CapSense firmware modules. </p>
<p>Call the <a class="el" href="group__group__capsense__high__level.html#ga19b3aa9e14a04b76188f917c0dc004f5" title="Captures HW blocks (one or more) for CapSense operations and configures them to the default state...">Cy_CapSense_Init()</a> function and configure MSC HW block interrupts prior to calling this function. See the function usage example below for details on usage.</p>
<p>The following are executed as part of the function:</p><ol type="1">
<li>Check CapSense configuration integrity.</li>
<li>Pre-calculate of internal register values to speed up operation.</li>
<li>Configure the MSC HW block(s) to perform capacitive sensing operation.</li>
<li>Calibrate the sensors and find the optimal values for CDACs of each widget/sensor, if the Enable CDAC auto-calibration is enabled in the CSD Setting or CSX Setting tabs.</li>
</ol>
<ol type="1">
<li>Perform scanning for all the sensors and initialize the baseline history.</li>
<li>If the firmware filters are enabled in the Advanced General tab, the filter histories are also initialized.</li>
</ol>
<p>Any subsequent call of this function repeats initialization process. Therefore, it is possible to change the middleware configuration from the application program by writing registers to the data structure and calling this function again.</p>
<p>The repeated call of this function is also done inside the <a class="el" href="group__group__capsense__high__level.html#ga0c613df550388c119fdab4e50341a6b4" title="Establishes synchronized operation between the CapSense Middleware and the CapSense Tuner tool...">Cy_CapSense_RunTuner()</a> function when a restart command is received.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CapSense context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the initialization process. If CY_CAPSENSE_STATUS_SUCCESS is not received, some of the initialization fails.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd></dd></dl>
<div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Capture the CapSense HW block and initialize it to the default state. */</span></div><div class="line">    <a class="code" href="group__group__capsense__high__level.html#ga19b3aa9e14a04b76188f917c0dc004f5">Cy_CapSense_Init</a>(&amp;cy_capsense_context);</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize CapSense interrupt */</span></div><div class="line">    Cy_SysInt_Init(&amp;CapSense_ISR_cfg, &amp;snippet_Cy_CapSense_IntHandler);</div><div class="line">    NVIC_ClearPendingIRQ(CapSense_ISR_cfg.intrSrc);</div><div class="line">    NVIC_EnableIRQ(CapSense_ISR_cfg.intrSrc);</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize the CapSense firmware modules. */</span></div><div class="line">    <a class="code" href="group__group__capsense__high__level.html#gade28f1f915ce6b97f13399074a819c0d">Cy_CapSense_Enable</a>(&amp;cy_capsense_context);</div><div class="line"></div></div><!-- fragment --><p>The 'cy_capsense_context' variable that is used as the parameter of the <a class="el" href="group__group__capsense__high__level.html#ga19b3aa9e14a04b76188f917c0dc004f5" title="Captures HW blocks (one or more) for CapSense operations and configures them to the default state...">Cy_CapSense_Init()</a> and <a class="el" href="group__group__capsense__high__level.html#gade28f1f915ce6b97f13399074a819c0d" title="Initializes the CapSense firmware modules. ">Cy_CapSense_Enable()</a> functions is declared in the cycfg_capsense.h file.</p>
<p>The CapSense_ISR_cfg variable should be declared by the application program according to the examples below:<br />
 For CM0+ core: </p><div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">    #if (!defined(CY_IP_M0S8MSCV3))</span></div><div class="line">        <span class="keyword">const</span> cy_stc_sysint_t CapSense_ISR_cfg =</div><div class="line">        {</div><div class="line">            .intrSrc = csd_interrupt_IRQn,  <span class="comment">/* CM0+ interrupt is NVIC #2 */</span></div><div class="line">            .intrPriority = 3u,             <span class="comment">/* Interrupt priority is 3 */</span></div><div class="line">        };</div><div class="line"><span class="preprocessor">    #else</span></div><div class="line">        <span class="keyword">const</span> cy_stc_sysint_t CapSense_ISR_cfg =</div><div class="line">        {</div><div class="line">            .intrSrc = msc_0_interrupt_IRQn,  <span class="comment">/* CM0+ interrupt is NVIC #2 */</span></div><div class="line">            .intrPriority = 3u,             <span class="comment">/* Interrupt priority is 3 */</span></div><div class="line">        };</div><div class="line"><span class="preprocessor">    #endif</span></div><div class="line"></div></div><!-- fragment --><p> For CM4 core: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="keyword">const</span> cy_stc_sysint_t CapSense_ISR_cfg =</div><div class="line">    {</div><div class="line">        .intrSrc = csd_interrupt_IRQn, <span class="comment">/* Interrupt source is the CSD interrupt */</span></div><div class="line">        .intrPriority = 7u,            <span class="comment">/* Interrupt priority is 7 */</span></div><div class="line">    };</div><div class="line"></div></div><!-- fragment --><p> The CapSense interrupt handler should be declared by the application program according to the example below: </p><div class="fragment"><div class="line"></div><div class="line"><span class="keywordtype">void</span> snippet_Cy_CapSense_IntHandler(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group__group__capsense__high__level.html#ga694cd350c85fcdc9dd1bc984a91d2c38">Cy_CapSense_InterruptHandler</a>(CapSense_HW, &amp;cy_capsense_context);</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p> The CY_MSC&lt;X&gt;_HW is the pointer to the base register address of the MSC_X HW block. A macro for the pointer is in the cycfg_peripherals.h file defined as &lt;Msc_Personality_Name&gt;_HW. If no name is specified, the default msc_&lt;Block_Number&gt;_msc_&lt;Block_Number&gt;_HW is used. </p>

</div>
</div>
<a id="ga899ef1058ead082503771da68e584b82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga899ef1058ead082503771da68e584b82">&#9670;&nbsp;</a></span>Cy_CapSense_Save()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_Save </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves the state of CapSense so the functionality can be restored using the <a class="el" href="group__group__capsense__high__level.html#gaf87102783ec511c2e5f2024680112d16" title="Resumes the middleware operation if the Cy_CapSense_Save() function was called previously. ">Cy_CapSense_Restore()</a> function. </p>
<p>This function, along with the <a class="el" href="group__group__capsense__high__level.html#gaf87102783ec511c2e5f2024680112d16" title="Resumes the middleware operation if the Cy_CapSense_Save() function was called previously. ">Cy_CapSense_Restore()</a> function, is specifically designed for ease of use and supports time multiplexing of the MSC HW block among multiple middleware. When the MSC HW block is shared by multiple middleware, this function can be used to save the current state of the MSC HW block and CapSense middleware prior to releasing the MSC HW block for use by other middleware. See the function usage example below for details on usage.</p>
<p>This function performs the same tasks as the <a class="el" href="group__group__capsense__high__level.html#ga7b8a365213dde3be6c6932dc23fdcee6" title="Stops the middleware operation and releases the CapSense captured HW blocks. ">Cy_CapSense_DeInit()</a> function and is kept for API consistency among middlewares. It is recommended to use <a class="el" href="group__group__capsense__high__level.html#ga899ef1058ead082503771da68e584b82" title="Saves the state of CapSense so the functionality can be restored using the Cy_CapSense_Restore() func...">Cy_CapSense_Save()</a> and <a class="el" href="group__group__capsense__high__level.html#gaf87102783ec511c2e5f2024680112d16" title="Resumes the middleware operation if the Cy_CapSense_Save() function was called previously. ">Cy_CapSense_Restore()</a> functions to implement Time-multiplexed mode instead of <a class="el" href="group__group__capsense__high__level.html#ga7b8a365213dde3be6c6932dc23fdcee6" title="Stops the middleware operation and releases the CapSense captured HW blocks. ">Cy_CapSense_DeInit()</a> and <a class="el" href="group__group__capsense__high__level.html#ga19b3aa9e14a04b76188f917c0dc004f5" title="Captures HW blocks (one or more) for CapSense operations and configures them to the default state...">Cy_CapSense_Init()</a> functions for further compatibility.</p>
<p>This function performs the following operations:</p><ul>
<li>Releases the MSC HW block.</li>
<li>Configures sensor pins to the default state and disconnects them from analog buses.</li>
<li>Disconnects external capacitors from analog buses.</li>
<li>Sets the middleware state to default.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CapSense context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the process. If CY_CAPSENSE_STATUS_SUCCESS is not received, the save process fails and retries may be required.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd></dd></dl>

</div>
</div>
<a id="gaf87102783ec511c2e5f2024680112d16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf87102783ec511c2e5f2024680112d16">&#9670;&nbsp;</a></span>Cy_CapSense_Restore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_Restore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resumes the middleware operation if the <a class="el" href="group__group__capsense__high__level.html#ga899ef1058ead082503771da68e584b82" title="Saves the state of CapSense so the functionality can be restored using the Cy_CapSense_Restore() func...">Cy_CapSense_Save()</a> function was called previously. </p>
<p>This function, along with the <a class="el" href="group__group__capsense__high__level.html#ga899ef1058ead082503771da68e584b82" title="Saves the state of CapSense so the functionality can be restored using the Cy_CapSense_Restore() func...">Cy_CapSense_Save()</a> function is specifically designed for ease of use and supports time multiplexing of the MSC HW block among multiple middleware. When the MSC HW blocks are shared by multiple middleware, this function can be used to restore the previous state of the MSC HW block(s) and CapSense middleware is saved using the <a class="el" href="group__group__capsense__high__level.html#ga899ef1058ead082503771da68e584b82" title="Saves the state of CapSense so the functionality can be restored using the Cy_CapSense_Restore() func...">Cy_CapSense_Save()</a> function. See the function usage example below for details on usage.</p>
<p>This function performs the same tasks as <a class="el" href="group__group__capsense__high__level.html#ga19b3aa9e14a04b76188f917c0dc004f5" title="Captures HW blocks (one or more) for CapSense operations and configures them to the default state...">Cy_CapSense_Init()</a> function and is kept for API consistency among middlewares. It is recommended to use <a class="el" href="group__group__capsense__high__level.html#ga899ef1058ead082503771da68e584b82" title="Saves the state of CapSense so the functionality can be restored using the Cy_CapSense_Restore() func...">Cy_CapSense_Save()</a> and <a class="el" href="group__group__capsense__high__level.html#gaf87102783ec511c2e5f2024680112d16" title="Resumes the middleware operation if the Cy_CapSense_Save() function was called previously. ">Cy_CapSense_Restore()</a> functions to implement time-multiplexed mode instead of <a class="el" href="group__group__capsense__high__level.html#ga7b8a365213dde3be6c6932dc23fdcee6" title="Stops the middleware operation and releases the CapSense captured HW blocks. ">Cy_CapSense_DeInit()</a> and <a class="el" href="group__group__capsense__high__level.html#ga19b3aa9e14a04b76188f917c0dc004f5" title="Captures HW blocks (one or more) for CapSense operations and configures them to the default state...">Cy_CapSense_Init()</a> functions for further compatibility.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CapSense context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the resume process. If CY_CAPSENSE_STATUS_SUCCESS is not received, the resume process fails and retries may be required.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd></dd></dl>

</div>
</div>
<a id="ga2a185db228d5cae975fbc92bd3bc6367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a185db228d5cae975fbc92bd3bc6367">&#9670;&nbsp;</a></span>Cy_CapSense_ProcessAllWidgets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_ProcessAllWidgets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs full data processing of all enabled widgets. </p>
<p>This function performs all data processes for all enabled widgets and sensors in the middleware to produce meaningful status output from widgets and sensors. The following tasks are executed as part of processing all the widgets:</p><ol type="1">
<li>Apply raw count filters to the raw counts, if they are enabled.</li>
<li>Update the thresholds if the SmartSense Full Auto-Tuning is enabled.</li>
<li>Update the baselines and difference counts for all the sensors.</li>
<li>Update the sensor and widget output status. Updates on/off status for buttons and proximity widgets, centroid/position for the sliders and the X/Y position for the touchpads.</li>
</ol>
<p>This function is called by the application program only after all the enabled widgets (and sensors) in the middleware are scanned. Calling this function multiple times without sensor scanning causes unexpected behavior.</p>
<p>The disabled widgets are not processed by this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CapSense context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the processing operation. If CY_CAPSENSE_STATUS_SUCCESS is not received, the processing fails and retries may be required. </dd></dl>

</div>
</div>
<a id="ga52874ea98333723ec92aef1bb4791a7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52874ea98333723ec92aef1bb4791a7d">&#9670;&nbsp;</a></span>Cy_CapSense_ProcessWidget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_ProcessWidget </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>widgetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs full data processing of the specified widget if it is enabled. </p>
<p>This function performs exactly the same tasks as <a class="el" href="group__group__capsense__high__level.html#ga2a185db228d5cae975fbc92bd3bc6367" title="Performs full data processing of all enabled widgets. ">Cy_CapSense_ProcessAllWidgets()</a>, but only for a specified widget. This function can be used along with the Cy_CapSense_SetupWidget() and Cy_CapSense_Scan() functions to scan and process data for a specific widget. This function is called only after all the sensors in the widgets are scanned. A disabled widget is not processed by this function.</p>
<p>A pipeline scan method (i.e. during scanning of a current widget (N), perform processing of the previously scanned widget (N-1)) can be implemented using this function and it may reduce the total execution time, increase the refresh rate, and decrease the average power consumption. See the function usage example below for details on usage.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">widgetId</td><td>Specifies the ID number of the widget. A macro for the widget ID can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;WIDGET_NAME&gt;_WDGT_ID.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CapSense context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the widget processing:<ul>
<li>CY_CAPSENSE_STATUS_SUCCESS - The operation is successfully completed</li>
<li>CY_CAPSENSE_STATUS_BAD_PARAM - The input parameter is invalid</li>
<li>CY_CAPSENSE_STATUS_INVALID_STATE - The specified widget is disabled</li>
<li>CY_CAPSENSE_STATUS_BAD_DATA - The processing is failed</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd></dd></dl>
<p>An example of pipeline implementation: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/*...*/</span></div><div class="line">    currentWidgetId = 0u;</div><div class="line">    previousWidgetId = 0u;</div><div class="line"></div><div class="line"><span class="preprocessor">    #if (!defined(CY_IP_M0S8MSCV3))</span></div><div class="line">        <span class="comment">/* Trigger scanning */</span></div><div class="line">        Cy_CapSense_SetupWidget(currentWidgetId, &amp;cy_capsense_context);</div><div class="line">        Cy_CapSense_Scan(&amp;cy_capsense_context);</div><div class="line"><span class="preprocessor">    #else</span></div><div class="line">        <a class="code" href="group__group__capsense__high__level.html#gad98e953def0673cd879f01a00fb2d01b">Cy_CapSense_ScanWidget</a>(currentWidgetId, &amp;cy_capsense_context);</div><div class="line"><span class="preprocessor">    #endif</span></div><div class="line"></div><div class="line">    <span class="keywordflow">for</span>(;;)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">if</span> (<a class="code" href="group__group__capsense__macros__general.html#ga1bd45eed2be393b7f53c20f1bae2814e">CY_CAPSENSE_NOT_BUSY</a> == <a class="code" href="group__group__capsense__high__level.html#ga7f8739755bba6b51c274f45b569b9ba0">Cy_CapSense_IsBusy</a>(&amp;cy_capsense_context))</div><div class="line">        {</div><div class="line">            currentWidgetId = (currentWidgetId &lt; (cy_capsense_context.ptrCommonConfig-&gt;numWd - 1u)) ? (currentWidgetId + 1u) : 0u;</div><div class="line"></div><div class="line"><span class="preprocessor">        #if (!defined(CY_IP_M0S8MSCV3))</span></div><div class="line">            <span class="comment">/* Trigger scanning of the next widget */</span></div><div class="line">            Cy_CapSense_SetupWidget(currentWidgetId, &amp;cy_capsense_context);</div><div class="line">            Cy_CapSense_Scan(&amp;cy_capsense_context);</div><div class="line"><span class="preprocessor">        #else</span></div><div class="line">            <a class="code" href="group__group__capsense__high__level.html#gad98e953def0673cd879f01a00fb2d01b">Cy_CapSense_ScanWidget</a>(currentWidgetId, &amp;cy_capsense_context);</div><div class="line"><span class="preprocessor">        #endif</span></div><div class="line"></div><div class="line">            <span class="comment">/* Process a previous widget during scanning of the current widget */</span></div><div class="line">            <a class="code" href="group__group__capsense__high__level.html#ga52874ea98333723ec92aef1bb4791a7d">Cy_CapSense_ProcessWidget</a>(previousWidgetId, &amp;cy_capsense_context);</div><div class="line">            previousWidgetId = currentWidgetId;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="comment">/*...*/</span></div><div class="line"></div></div><!-- fragment -->
</div>
</div>
<a id="ga904eb69e694e4daf45bc778281b39d9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga904eb69e694e4daf45bc778281b39d9e">&#9670;&nbsp;</a></span>Cy_CapSense_IncrementGestureTimestamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_CapSense_IncrementGestureTimestamp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increments the timestamp register for the predefined timestamp interval. </p>
<p>A timestamp is required for operation of the Gesture and Ballistic multiplier feature. Hence this function and timestamp is required only if the Gesture detection or Ballistic multiplier feature is enabled.</p>
<p>This function increments the timestamp by the interval specified in the context-&gt;ptrCommonContext-&gt;timestampInterval register. The unit for the timestamp and timestamp interval is milliseconds and the default value of the interval is 1.</p>
<p>The application program must periodically call this function or register a periodic callback to this function to keep the timestamp updated and operational for the operation of the Gesture and Ballistic multiplier feature.</p>
<p>The timestamp can be updated in one of the three methods:</p><ol type="1">
<li>Register a periodic callback for the <a class="el" href="group__group__capsense__high__level.html#ga904eb69e694e4daf45bc778281b39d9e" title="Increments the timestamp register for the predefined timestamp interval. ">Cy_CapSense_IncrementGestureTimestamp()</a> function.</li>
<li>Periodically call the <a class="el" href="group__group__capsense__high__level.html#ga904eb69e694e4daf45bc778281b39d9e" title="Increments the timestamp register for the predefined timestamp interval. ">Cy_CapSense_IncrementGestureTimestamp()</a> function from the application program.</li>
<li>Directly modify the timestamp using the <a class="el" href="group__group__capsense__high__level.html#gabf0789f59e23077cba0005b1499468f9" title="Rewrites the timestamp register by the specified value. ">Cy_CapSense_SetGestureTimestamp()</a> function.</li>
</ol>
<p>See the function usage example below for more details.</p>
<p>The interval at which this function is called should match with interval defined in context-&gt;ptrCommonContext-&gt;timestampInterval register. Either the register value can be updated to match the callback interval or the callback can be made at interval set in the register.</p>
<p>If a timestamp is available from another source, the application program may choose to periodically update the timestamp by using the <a class="el" href="group__group__capsense__high__level.html#gabf0789f59e23077cba0005b1499468f9" title="Rewrites the timestamp register by the specified value. ">Cy_CapSense_SetGestureTimestamp()</a> function instead of registering a callback.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CapSense context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function Usage</dt><dd></dd></dl>
<p>An example of timestamp updating: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* If previous scan complete, process widget data and trigger the next scan */</span></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__capsense__macros__general.html#ga1bd45eed2be393b7f53c20f1bae2814e">CY_CAPSENSE_NOT_BUSY</a> == <a class="code" href="group__group__capsense__high__level.html#ga7f8739755bba6b51c274f45b569b9ba0">Cy_CapSense_IsBusy</a>(&amp;cy_capsense_context))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Increment timestamp: Option 2 */</span></div><div class="line">        <a class="code" href="group__group__capsense__high__level.html#ga904eb69e694e4daf45bc778281b39d9e">Cy_CapSense_IncrementGestureTimestamp</a>(&amp;cy_capsense_context);</div><div class="line">        <span class="comment">/* Increment timestamp: Option 3 */</span></div><div class="line">        cy_capsense_context.ptrCommonContext-&gt;timestamp = newTimestamp;</div><div class="line"></div><div class="line">        <a class="code" href="group__group__capsense__high__level.html#ga52874ea98333723ec92aef1bb4791a7d">Cy_CapSense_ProcessWidget</a>(CY_CAPSENSE_TOUCHPAD0_WDGT_ID, &amp;cy_capsense_context);</div><div class="line">        <a class="code" href="group__group__capsense__high__level.html#ga55fa694191705971b3aa2c29021fb9aa">Cy_CapSense_DecodeWidgetGestures</a>(CY_CAPSENSE_TOUCHPAD0_WDGT_ID, &amp;cy_capsense_context);</div><div class="line"></div><div class="line"><span class="preprocessor">    #if (!defined(CY_IP_M0S8MSCV3))</span></div><div class="line">        <span class="comment">/* Trigger the next scan */</span></div><div class="line">        Cy_CapSense_Scan(&amp;cy_capsense_context);</div><div class="line"><span class="preprocessor">    #else</span></div><div class="line">        <a class="code" href="group__group__capsense__high__level.html#gad98e953def0673cd879f01a00fb2d01b">Cy_CapSense_ScanWidget</a>(CY_CAPSENSE_TOUCHPAD0_WDGT_ID, &amp;cy_capsense_context);</div><div class="line"><span class="preprocessor">    #endif</span></div><div class="line">    }</div><div class="line"></div></div><!-- fragment -->
</div>
</div>
<a id="gabf0789f59e23077cba0005b1499468f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf0789f59e23077cba0005b1499468f9">&#9670;&nbsp;</a></span>Cy_CapSense_SetGestureTimestamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_CapSense_SetGestureTimestamp </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrites the timestamp register by the specified value. </p>
<p>This function writes the specified value into the middleware timestamp context-&gt;ptrCommonContext-&gt;timestamp register.</p>
<p>If a timestamp is available from another source, the application program may choose to periodically update the timestamp by using this function instead of registering a callback.</p>
<p>Do not modify the timestamp arbitrarily or simultaneously use with the <a class="el" href="group__group__capsense__high__level.html#ga904eb69e694e4daf45bc778281b39d9e" title="Increments the timestamp register for the predefined timestamp interval. ">Cy_CapSense_IncrementGestureTimestamp()</a> function, which may result in unexpected result.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Specifies the timestamp value (in ms).</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CapSense context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf9436a7ec9b18880dbc046e91462710b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9436a7ec9b18880dbc046e91462710b">&#9670;&nbsp;</a></span>Cy_CapSense_Wakeup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_CapSense_Wakeup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resumes the middleware after System Deep Sleep. </p>
<p>This function is used to resume the middleware operation after exiting System Deep Sleep. After the MSC HW block is powered off, an extra delay is required to establish the correct operation of the MSC HW block.</p>
<p>This function is called by the <a class="el" href="group__group__capsense__high__level.html#ga9c47887109b22521eba45109b7a27f31" title="Handles CPU active to System Deep Sleep power mode transition for the CapSense middleware. ">Cy_CapSense_DeepSleepCallback()</a> function after exiting System Deep Sleep if the CapSense Deep Sleep callback is registered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CapSense context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9c47887109b22521eba45109b7a27f31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c47887109b22521eba45109b7a27f31">&#9670;&nbsp;</a></span>Cy_CapSense_DeepSleepCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cy_en_syspm_status_t Cy_CapSense_DeepSleepCallback </td>
          <td>(</td>
          <td class="paramtype">cy_stc_syspm_callback_params_t *&#160;</td>
          <td class="paramname"><em>callbackParams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cy_en_syspm_callback_mode_t&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handles CPU active to System Deep Sleep power mode transition for the CapSense middleware. </p>
<p>Calling this function directly from the application program is not recommended. Instead, Cy_SysPm_CpuEnterDeepSleep() should be used for the CPU active to System Deep Sleep power mode transition of the device. </p><dl class="section note"><dt>Note</dt><dd>After the CPU Deep Sleep transition, the device automatically goes to System Deep Sleep if all conditions are fulfilled: another core is in CPU Deep Sleep, all the peripherals are ready to System Deep Sleep, etc. (see details in the device TRM).</dd></dl>
<p>For proper operation of the CapSense middleware during the CPU active to System Deep Sleep mode transition, a callback to this function should be registered using the Cy_SysPm_RegisterCallback() function with CY_SYSPM_DEEPSLEEP type. After the callback is registered, this function is called by the Cy_SysPm_CpuEnterDeepSleep() function to prepare the middleware to the device power mode transition.</p>
<p>When this function is called with CY_SYSPM_CHECK_READY as an input, this function returns CY_SYSPM_SUCCESS if no scanning is in progress or not a single HW block is captured by the CapSense middleware. Otherwise CY_SYSPM_FAIL is returned. If CY_SYSPM_FAIL status is returned, a device cannot change the power mode without completing the current scan as a transition to System Deep Sleep during the scan can disrupt the middleware operation.</p>
<p>When this function is called with CY_SYSPM_AFTER_TRANSITION as an input, then the <a class="el" href="group__group__capsense__high__level.html#gaf9436a7ec9b18880dbc046e91462710b" title="Resumes the middleware after System Deep Sleep. ">Cy_CapSense_Wakeup()</a> function is called to resume the middleware operation after exiting System Deep Sleep. If there are no CapSense captured HW blocks the <a class="el" href="group__group__capsense__high__level.html#gaf9436a7ec9b18880dbc046e91462710b" title="Resumes the middleware after System Deep Sleep. ">Cy_CapSense_Wakeup()</a> function calling is omitted and restoring CapSense immediately after Deep Sleep without the wake-up delay can lead to unpredictable behavior.</p>
<p>For details of SysPm types and macros refer to the SysPm section of the PDL documentation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callbackParams</td><td>Refer to the description of the cy_stc_syspm_callback_params_t type in the Peripheral Driver Library documentation.</td></tr>
    <tr><td class="paramname">mode</td><td>Specifies mode cy_en_syspm_callback_mode_t.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status cy_en_syspm_status_t of the operation requested by the mode parameter:<ul>
<li>CY_SYSPM_SUCCESS - System Deep Sleep power mode can be entered.</li>
<li>CY_SYSPM_FAIL - System Deep Sleep power mode cannot be entered. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga289c4fd495135399a9ad9897920836a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga289c4fd495135399a9ad9897920836a7">&#9670;&nbsp;</a></span>Cy_CapSense_RegisterCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_RegisterCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__capsense__enums.html#gabfbff81b8b80d4ee1a1d53c1fe0c9a11">cy_en_capsense_callback_event_t</a>&#160;</td>
          <td class="paramname"><em>callbackType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__capsense__structures.html#ga908447ccc2720f31c861d9eb79ff75d2">cy_capsense_callback_t</a>&#160;</td>
          <td class="paramname"><em>callbackFunction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers a ures's callback function. </p>
<p>The registered function will be called by the CapSense middleware when the specified event <a class="el" href="group__group__capsense__enums.html#gabfbff81b8b80d4ee1a1d53c1fe0c9a11">cy_en_capsense_callback_event_t</a> has occurred in the CapSense middleware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callbackType</td><td>The event on which the registered user's function is called by the CapSense middleware. Refer to <a class="el" href="group__group__capsense__enums.html#gabfbff81b8b80d4ee1a1d53c1fe0c9a11">cy_en_capsense_callback_event_t</a> for the list of supported events.</td></tr>
    <tr><td class="paramname">callbackFunction</td><td>The pointer to the user's callback function to be called by the middleware.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CapSense context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the callback registration:<ul>
<li>CY_CAPSENSE_STATUS_SUCCESS - The action performed successfully.</li>
<li>CY_CAPSENSE_STATUS_BAD_PARAM - The input parameter is invalid. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaf43b3cdfce7a3e8c0e5622f42e0a6319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf43b3cdfce7a3e8c0e5622f42e0a6319">&#9670;&nbsp;</a></span>Cy_CapSense_UnRegisterCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_UnRegisterCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__capsense__enums.html#gabfbff81b8b80d4ee1a1d53c1fe0c9a11">cy_en_capsense_callback_event_t</a>&#160;</td>
          <td class="paramname"><em>callbackType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function unregisters a previously registered user's callback function in the CapSense middleware. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callbackType</td><td>The event on which the callback function should be unregistered. Refer to <a class="el" href="group__group__capsense__enums.html#gabfbff81b8b80d4ee1a1d53c1fe0c9a11">cy_en_capsense_callback_event_t</a> for the list of supported events.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CapSense context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the callback deregistration:<ul>
<li>CY_CAPSENSE_STATUS_SUCCESS - The action performed successfully.</li>
<li>CY_CAPSENSE_STATUS_BAD_PARAM - The input parameter is invalid. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga55fa694191705971b3aa2c29021fb9aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55fa694191705971b3aa2c29021fb9aa">&#9670;&nbsp;</a></span>Cy_CapSense_DecodeWidgetGestures()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Cy_CapSense_DecodeWidgetGestures </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>widgetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs decoding of all gestures for the specified widget. </p>
<p>This function should be called by application program only after all sensors are scanned and all data processing is executed using <a class="el" href="group__group__capsense__high__level.html#ga2a185db228d5cae975fbc92bd3bc6367" title="Performs full data processing of all enabled widgets. ">Cy_CapSense_ProcessAllWidgets()</a> or <a class="el" href="group__group__capsense__high__level.html#ga52874ea98333723ec92aef1bb4791a7d" title="Performs full data processing of the specified widget if it is enabled. ">Cy_CapSense_ProcessWidget()</a> functions for the widget. Calling this function multiple times without a new sensor scan and process causes unexpected behavior.</p>
<dl class="section note"><dt>Note</dt><dd>The function (Gesture detection functionality) requires a timestamp for its operation. The timestamp should be initialized and maintained in the application program prior to calling this function. See the descriptions of the <a class="el" href="group__group__capsense__high__level.html#gabf0789f59e23077cba0005b1499468f9" title="Rewrites the timestamp register by the specified value. ">Cy_CapSense_SetGestureTimestamp()</a> and <a class="el" href="group__group__capsense__high__level.html#ga904eb69e694e4daf45bc778281b39d9e" title="Increments the timestamp register for the predefined timestamp interval. ">Cy_CapSense_IncrementGestureTimestamp()</a> functions for details.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">widgetId</td><td>Specifies the ID number of the widget. A macro for the widget ID can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;WIDGET_NAME&gt;_WDGT_ID.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CapSense context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the detected Gesture mask and direction of detected gestures. The same information is stored in ptrWdContext-&gt;gestureDetected and ptrWdContext-&gt;gestureDirection registers. Corresponding macros could be found <a class="el" href="group__group__capsense__macros__gesture.html">Gesture Macros</a>.<ul>
<li>bit[0..15] - detected gesture masks gesture<ul>
<li>bit[0] - one-finger single click gesture</li>
<li>bit[1] - one-finger double click gesture</li>
<li>bit[2] - one-finger click and drag gesture</li>
<li>bit[3] - two-finger single click gesture</li>
<li>bit[4] - one-finger scroll gesture</li>
<li>bit[5] - two-finger scroll gesture</li>
<li>bit[6] - one-finger edge swipe</li>
<li>bit[7] - one-finger flick</li>
<li>bit[8] - one-finger rotate</li>
<li>bit[9] - two-finger zoom</li>
<li>bit[13] - touchdown event</li>
<li>bit[14] - liftoff event</li>
</ul>
</li>
<li>bit[16..31] - gesture direction if detected<ul>
<li>bit[0..1] - direction of one-finger scroll gesture</li>
<li>bit[2..3] - direction of two-finger scroll gesture</li>
<li>bit[4..5] - direction of one-finger edge swipe gesture</li>
<li>bit[6] - direction of one-finger rotate gesture</li>
<li>bit[7] - direction of two-finger zoom gesture</li>
<li>bit[8..10] - direction of one-finger flick gesture</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd></dd></dl>
<p>An example of gesture decoding: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* If previous scan complete, process widget data and trigger the next scan */</span></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__capsense__macros__general.html#ga1bd45eed2be393b7f53c20f1bae2814e">CY_CAPSENSE_NOT_BUSY</a> == <a class="code" href="group__group__capsense__high__level.html#ga7f8739755bba6b51c274f45b569b9ba0">Cy_CapSense_IsBusy</a>(&amp;cy_capsense_context))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Increment timestamp before widget data processing if ballistic multiplier is enabled */</span></div><div class="line">        <a class="code" href="group__group__capsense__high__level.html#ga904eb69e694e4daf45bc778281b39d9e">Cy_CapSense_IncrementGestureTimestamp</a>(&amp;cy_capsense_context);</div><div class="line"></div><div class="line">        <span class="comment">/* Process widget data: Calculate diff counts, status, position, etc. */</span></div><div class="line">        <a class="code" href="group__group__capsense__high__level.html#ga52874ea98333723ec92aef1bb4791a7d">Cy_CapSense_ProcessWidget</a>(CY_CAPSENSE_TOUCHPAD0_WDGT_ID, &amp;cy_capsense_context);</div><div class="line"></div><div class="line">        <span class="comment">/* Process gesture for the widget */</span></div><div class="line">        gestureStatus = <a class="code" href="group__group__capsense__high__level.html#ga55fa694191705971b3aa2c29021fb9aa">Cy_CapSense_DecodeWidgetGestures</a>(CY_CAPSENSE_TOUCHPAD0_WDGT_ID, &amp;cy_capsense_context);</div><div class="line"></div><div class="line">        <span class="comment">/* The same gestureStatus can be read from the following registers */</span></div><div class="line">        gestureStatus = cy_capsense_context.ptrWdContext[CY_CAPSENSE_TOUCHPAD0_WDGT_ID].gestureDetected |</div><div class="line">                    (cy_capsense_context.ptrWdContext[CY_CAPSENSE_TOUCHPAD0_WDGT_ID].gestureDirection &lt;&lt; <a class="code" href="group__group__capsense__macros__gesture.html#ga3bfd7aa90e3ef1bf3c124c90ec9c2e13">CY_CAPSENSE_GESTURE_DIRECTION_OFFSET</a>);</div><div class="line"></div><div class="line"><span class="preprocessor">        #if (!defined(CY_IP_M0S8MSCV3))</span></div><div class="line">            <span class="comment">/* Configure the widget if previously configured widget was not TOUCHPAD0 */</span></div><div class="line">            Cy_CapSense_SetupWidget(CY_CAPSENSE_TOUCHPAD0_WDGT_ID, &amp;cy_capsense_context);</div><div class="line"></div><div class="line">            <span class="comment">/* Trigger the next scan */</span></div><div class="line">            Cy_CapSense_Scan(&amp;cy_capsense_context);</div><div class="line"><span class="preprocessor">        #else</span></div><div class="line">            <a class="code" href="group__group__capsense__high__level.html#gad98e953def0673cd879f01a00fb2d01b">Cy_CapSense_ScanWidget</a>(CY_CAPSENSE_TOUCHPAD0_WDGT_ID, &amp;cy_capsense_context);</div><div class="line"><span class="preprocessor">        #endif</span></div><div class="line">    }</div><div class="line"></div></div><!-- fragment --><p> An example of gesture status parsing: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* If Two-finger Scroll gesture is detected */</span></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__capsense__macros__gesture.html#ga438d3109bdaa4dd9bd2a5653c37322f5">CY_CAPSENSE_GESTURE_NO_GESTURE</a> != (gestureStatus &amp; <a class="code" href="group__group__capsense__macros__gesture.html#gae8a61309c25e5255fa4a46436384184d">CY_CAPSENSE_GESTURE_TWO_FNGR_SCROLL_MASK</a>))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Get gesture direction */</span></div><div class="line">        direction = (gestureStatus &gt;&gt; <a class="code" href="group__group__capsense__macros__gesture.html#ga3bfd7aa90e3ef1bf3c124c90ec9c2e13">CY_CAPSENSE_GESTURE_DIRECTION_OFFSET</a>) &amp; <a class="code" href="group__group__capsense__macros__gesture.html#ga2b1afba16625a4f234e167a4580f28af">CY_CAPSENSE_GESTURE_DIRECTION_MASK_TWO_SCROLL</a>;</div><div class="line">        <span class="keywordflow">switch</span> (direction &gt;&gt; <a class="code" href="group__group__capsense__macros__gesture.html#gab65415405b4a5a8e2dcd432aeba8dad5">CY_CAPSENSE_GESTURE_DIRECTION_OFFSET_TWO_SCROLL</a>)</div><div class="line">        {</div><div class="line">            <span class="keywordflow">case</span> <a class="code" href="group__group__capsense__macros__gesture.html#gad81547dd95beb218449d8d209d6f2d90">CY_CAPSENSE_GESTURE_DIRECTION_UP</a>:</div><div class="line">                <span class="comment">/* UP is detected */</span></div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line">            <span class="keywordflow">case</span> <a class="code" href="group__group__capsense__macros__gesture.html#gac6a805800ada8e6f499d063f45fb8ba8">CY_CAPSENSE_GESTURE_DIRECTION_DOWN</a>:</div><div class="line">                <span class="comment">/* DOWN is detected */</span></div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line">            <span class="keywordflow">case</span> <a class="code" href="group__group__capsense__macros__gesture.html#ga5660ae39ff90e08e33a71508d3059817">CY_CAPSENSE_GESTURE_DIRECTION_LEFT</a>:</div><div class="line">                <span class="comment">/* LEFT is detected */</span></div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line">            <span class="keywordflow">case</span> <a class="code" href="group__group__capsense__macros__gesture.html#gabeb98d13bdc3570bca825b5a5d4a4ae0">CY_CAPSENSE_GESTURE_DIRECTION_RIGHT</a>:</div><div class="line">                <span class="comment">/* RIGHT is detected */</span></div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div></div><!-- fragment -->
</div>
</div>
<a id="ga045f3f46ff4e43c4f4dbe087c0156f56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga045f3f46ff4e43c4f4dbe087c0156f56">&#9670;&nbsp;</a></span>Cy_CapSense_ScanAllSlots()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_ScanAllSlots </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiates the non-blocking scan of all slots. </p>
<p>Scanning is initiated only if no scan is in progress. Scan finishing can be checked by the <a class="el" href="group__group__capsense__high__level.html#ga7f8739755bba6b51c274f45b569b9ba0" title="This function returns a status of the CapSense middleware whether a scan is currently in progress or ...">Cy_CapSense_IsBusy()</a> function.</p>
<p>This function initiates a scan only for the first slot for all channels and then exits. Scans for the remaining slots in the Interrupt-driven scan mode are initiated in the interrupt service routine (part of middleware) trigged at the end of each scan completion for each channel. If the syncMode field in the <a class="el" href="structcy__stc__capsense__common__config__t.html" title="Common configuration structure. ">cy_stc_capsense_common_config_t</a> structure is set to CY_CAPSENSE_SYNC_MODE_OFF, then the next slot scan for the channel with the fired interrupt, will start regardless of the another channel readiness for the next scan. If the syncMode field is set to CY_CAPSENSE_SYNC_INTERNAL (for single-chip projects) or to CY_CAPSENSE_SYNC_EXTERNAL (for multi-chip projects), then the next slot scan for the channel with the fired interrupt, will start in lockstep with another channels after they all are ready for the next scan (the next scan configuration is loaded into the channel MSC HW block). Scans for the remaining slots in CS-DMA scan mode are initiated by DMAC trigged at the end of each scan completion for each channel. The channel scan synchronization is performed as in Interrupt-driven scan mode. After all slots are scanned, the FRAME interrupt is fired and the interrupt service routine (part of middleware) updates the busy status.</p>
<p>The status of the current scan should be checked using the <a class="el" href="group__group__capsense__high__level.html#ga7f8739755bba6b51c274f45b569b9ba0" title="This function returns a status of the CapSense middleware whether a scan is currently in progress or ...">Cy_CapSense_IsBusy()</a> function, where there are separate busy bits for each channel and the application program waits until all scans are finished prior to starting a next scan by using this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CapSense context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the operation:<ul>
<li>CY_CAPSENSE_STATUS_SUCCESS - The operation is performed successfully.</li>
<li>CY_CAPSENSE_STATUS_BAD_PARAM - The input parameter is invalid.</li>
<li>CY_CAPSENSE_STATUS_HW_BUSY - The HW is busy with the previous scan. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaf10ce0cc817442374d2df04c9d241f9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf10ce0cc817442374d2df04c9d241f9b">&#9670;&nbsp;</a></span>Cy_CapSense_ScanSlots()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_ScanSlots </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>startSlotId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numberSlots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiates the non-blocking scan of specified slots. </p>
<p>Scanning is initiated only if no scan is in progress. Scan finishing can be checked by the <a class="el" href="group__group__capsense__high__level.html#ga7f8739755bba6b51c274f45b569b9ba0" title="This function returns a status of the CapSense middleware whether a scan is currently in progress or ...">Cy_CapSense_IsBusy()</a> function.</p>
<p>This function initiates a scan only for the first specified slot for all channels and then exits. Scans for the remaining slots in the interrupt-driven scan mode are initiated in the interrupt service routine (part of middleware) trigged at the end of each scan completion for each channel. If the syncMode field in the <a class="el" href="structcy__stc__capsense__common__config__t.html" title="Common configuration structure. ">cy_stc_capsense_common_config_t</a> structure is set to CY_CAPSENSE_SYNC_MODE_OFF, then the next slot scan for the channel with the fired interrupt, will start regardless of the another channel readiness for the next scan. If the syncMode field is set to CY_CAPSENSE_SYNC_INTERNAL (for single-chip projects) or to CY_CAPSENSE_SYNC_EXTERNAL (for multi-chip projects), then the next slot scan for the channel with the fired interrupt, will start in lockstep with another channels after they all are ready for the next scan. The scan for the remaining slots in CS-DMA scan mode are initiated by DMAC trigged at the end of each scan completion for each channel. The channel scan synchronization is performed as in Interrupt-driven scan mode. After all slots are scanned, the FRAME interrupt is fired and the interrupt service routine (part of middleware) updates the busy status.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startSlotId</td><td>The slot ID scan will be started from.</td></tr>
    <tr><td class="paramname">numberSlots</td><td>The number of slots will be scanned.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CapSense context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the operation:<ul>
<li>CY_CAPSENSE_STATUS_SUCCESS - The operation is performed successfully.</li>
<li>CY_CAPSENSE_STATUS_BAD_PARAM - The input parameter is invalid.</li>
<li>CY_CAPSENSE_STATUS_HW_BUSY - The HW is busy with the previous scan. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga50e6ef42f2834083715abe86d8a85b48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50e6ef42f2834083715abe86d8a85b48">&#9670;&nbsp;</a></span>Cy_CapSense_ScanAllWidgets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_ScanAllWidgets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiates the non-blocking scan for all widgets/sensors. </p>
<p>Scanning is initiated only if no scan is in progress. Scan finishing can be checked by the <a class="el" href="group__group__capsense__high__level.html#ga7f8739755bba6b51c274f45b569b9ba0" title="This function returns a status of the CapSense middleware whether a scan is currently in progress or ...">Cy_CapSense_IsBusy()</a> function.</p>
<p>The function is the wrapper for the <a class="el" href="group__group__capsense__high__level.html#ga045f3f46ff4e43c4f4dbe087c0156f56" title="Initiates the non-blocking scan of all slots. ">Cy_CapSense_ScanAllSlots()</a> function to provide the backward compatibility.</p>
<dl class="section note"><dt>Note</dt><dd>The function operates only in single-channel projects for a while.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CapSense context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the operation:<ul>
<li>CY_CAPSENSE_STATUS_SUCCESS - The operation is performed successfully.</li>
<li>CY_CAPSENSE_STATUS_BAD_PARAM - The input parameter is invalid.</li>
<li>CY_CAPSENSE_STATUS_HW_BUSY - The HW is busy with the previous scan. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gad98e953def0673cd879f01a00fb2d01b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad98e953def0673cd879f01a00fb2d01b">&#9670;&nbsp;</a></span>Cy_CapSense_ScanWidget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_ScanWidget </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>widgetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiates the scanning of all sensors in the widget. </p>
<p>Scanning is initiated only if no scan is in progress. Scan finishing can be checked by the <a class="el" href="group__group__capsense__high__level.html#ga7f8739755bba6b51c274f45b569b9ba0" title="This function returns a status of the CapSense middleware whether a scan is currently in progress or ...">Cy_CapSense_IsBusy()</a> function.</p>
<p>The function uses the <a class="el" href="group__group__capsense__high__level.html#gaf10ce0cc817442374d2df04c9d241f9b" title="Initiates the non-blocking scan of specified slots. ">Cy_CapSense_ScanSlots()</a> function with the parameters of startSlotId and numberSlots retrieved from the firstSlotId and numSlots fields of the <a class="el" href="structcy__stc__capsense__widget__config__t.html" title="Widget configuration structure. ">cy_stc_capsense_widget_config_t</a> structure.</p>
<dl class="section note"><dt>Note</dt><dd>The function operates only in single-channel projects for a while.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">widgetId</td><td>Specifies the ID number of the widget. A macro for the widget ID can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;WIDGET_NAME&gt;_WDGT_ID.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CapSense context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the operation:<ul>
<li>CY_CAPSENSE_STATUS_SUCCESS - The operation is performed successfully.</li>
<li>CY_CAPSENSE_STATUS_BAD_PARAM - The input parameter is invalid.</li>
<li>CY_CAPSENSE_STATUS_HW_BUSY - The HW is busy with the previous scan. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gae3f80b48c2596c149ca0b392a9a3da62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3f80b48c2596c149ca0b392a9a3da62">&#9670;&nbsp;</a></span>Cy_CapSense_ScanSensor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__capsense__structures.html#gadb42bb859316b21e708ad01184fba9c7">cy_capsense_status_t</a> Cy_CapSense_ScanSensor </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>widgetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sensorId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiates the scanning of the selected sensor in the widget. </p>
<p>Scanning is initiated only if no scan is in progress. Scan finishing can be checked by the <a class="el" href="group__group__capsense__high__level.html#ga7f8739755bba6b51c274f45b569b9ba0" title="This function returns a status of the CapSense middleware whether a scan is currently in progress or ...">Cy_CapSense_IsBusy()</a> function.</p>
<dl class="section note"><dt>Note</dt><dd>The function is not available for a while.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">widgetId</td><td>Specifies the ID number of the widget. A macro for the widget ID can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;WIDGET_NAME&gt;_WDGT_ID.</td></tr>
    <tr><td class="paramname">sensorId</td><td>Specifies the ID number of the sensor within the widget. A macro for the sensor ID within a specified widget can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;WIDGET_NAME&gt;_SNS&lt;SENSOR_NUMBER&gt;_ID.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CapSense context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the operation:<ul>
<li>CY_CAPSENSE_STATUS_SUCCESS - The operation is performed successfully.</li>
<li>CY_CAPSENSE_STATUS_BAD_PARAM - The input parameter is invalid.</li>
<li>CY_CAPSENSE_STATUS_HW_BUSY - The HW is busy with the previous scan. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga7f8739755bba6b51c274f45b569b9ba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f8739755bba6b51c274f45b569b9ba0">&#9670;&nbsp;</a></span>Cy_CapSense_IsBusy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Cy_CapSense_IsBusy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns a status of the CapSense middleware whether a scan is currently in progress or not. </p>
<p>If the middleware is busy, a new scan or setup widgets should not be initiated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CapSense context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the middleware as a sum of the next masks :<ul>
<li>CY_CAPSENSE_NOT_BUSY - No scan is in progress and a next scan frame can be initiated.</li>
<li>CY_CAPSENSE_BUSY[x] - The set [x] bit of the result means that the previously initiated scan for the [x] channel is in progress. The next scan frame cannot be started.</li>
<li>CY_CAPSENSE_BUSY_CALIBRATION - The auto-calibration is in progress. The next scan frame cannot be started.</li>
<li>CY_CAPSENSE_BUSY_VERIFY_CALIBRATION - The auto-calibration verification is in progress. The next scan frame cannot be started. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga694cd350c85fcdc9dd1bc984a91d2c38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga694cd350c85fcdc9dd1bc984a91d2c38">&#9670;&nbsp;</a></span>Cy_CapSense_InterruptHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_CapSense_InterruptHandler </td>
          <td>(</td>
          <td class="paramtype">const MSC_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements interrupt service routine for CapSense Middleware. </p>
<p>The CSD / MSC HW block generates an interrupt at end of every sensor scan. The CapSense middleware uses this interrupt to implement a non-blocking sensor scan method, in which only the first sensor scan is initiated by the application program and subsequent sensor scans are initiated in the interrupt service routine as soon as the current scan is completed. The above stated interrupt service routine is implemented as a part of the CapSense middleware.</p>
<p>The CapSense middleware does not initialize or modify the priority of interrupts. For the operation of middleware, the application program must configure MSC interrupt and assign interrupt vector to the <a class="el" href="group__group__capsense__high__level.html#ga694cd350c85fcdc9dd1bc984a91d2c38" title="Implements interrupt service routine for CapSense Middleware. ">Cy_CapSense_InterruptHandler()</a> function. Refer to function usage example for details.</p>
<p>Update doc including snippets for CSD &amp; MSC around the MW.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the base register address of the CSD HW block. A macro for the pointer can be found in cycfg_peripherals.h file defined as &lt;Csd_Personality_Name&gt;_HW. If no name is specified then the default name is used csd_&lt;Block_Number&gt;_csd_&lt;Block_Number&gt;_HW.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CapSense context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The calls of the Start Sample and End Of Scan callbacks (see the <a class="el" href="group__group__capsense__callbacks.html">Callbacks</a> section for details) are the part of the <a class="el" href="group__group__capsense__high__level.html#ga694cd350c85fcdc9dd1bc984a91d2c38" title="Implements interrupt service routine for CapSense Middleware. ">Cy_CapSense_InterruptHandler()</a> routine and they lengthen its execution. These callbacks will lengthen the CSD ISR execution in case of a direct call of the <a class="el" href="group__group__capsense__high__level.html#ga694cd350c85fcdc9dd1bc984a91d2c38" title="Implements interrupt service routine for CapSense Middleware. ">Cy_CapSense_InterruptHandler()</a> function from a CSD ISR.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd></dd></dl>
<p>An example of the ISR initialization:</p>
<p>The CapSense_ISR_cfg variable should be declared by the application program according to the examples below:<br />
 For Core CM0+: </p><div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">    #if (!defined(CY_IP_M0S8MSCV3))</span></div><div class="line">        <span class="keyword">const</span> cy_stc_sysint_t CapSense_ISR_cfg =</div><div class="line">        {</div><div class="line">            .intrSrc = csd_interrupt_IRQn,  <span class="comment">/* CM0+ interrupt is NVIC #2 */</span></div><div class="line">            .intrPriority = 3u,             <span class="comment">/* Interrupt priority is 3 */</span></div><div class="line">        };</div><div class="line"><span class="preprocessor">    #else</span></div><div class="line">        <span class="keyword">const</span> cy_stc_sysint_t CapSense_ISR_cfg =</div><div class="line">        {</div><div class="line">            .intrSrc = msc_0_interrupt_IRQn,  <span class="comment">/* CM0+ interrupt is NVIC #2 */</span></div><div class="line">            .intrPriority = 3u,             <span class="comment">/* Interrupt priority is 3 */</span></div><div class="line">        };</div><div class="line"><span class="preprocessor">    #endif</span></div><div class="line"></div></div><!-- fragment --><p> The CapSense interrupt handler should be defined by the application program according to the example below: </p><div class="fragment"><div class="line"></div><div class="line"><span class="keywordtype">void</span> snippet_Cy_CapSense_IntHandler(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group__group__capsense__high__level.html#ga694cd350c85fcdc9dd1bc984a91d2c38">Cy_CapSense_InterruptHandler</a>(CapSense_HW, &amp;cy_capsense_context);</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p> Then, the application program configures and enables the interrupt for each MSC HW block between calls of the <a class="el" href="group__group__capsense__high__level.html#ga19b3aa9e14a04b76188f917c0dc004f5" title="Captures HW blocks (one or more) for CapSense operations and configures them to the default state...">Cy_CapSense_Init()</a> and <a class="el" href="group__group__capsense__high__level.html#gade28f1f915ce6b97f13399074a819c0d" title="Initializes the CapSense firmware modules. ">Cy_CapSense_Enable()</a> functions: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Capture the CapSense HW block and initialize it to the default state. */</span></div><div class="line">    <a class="code" href="group__group__capsense__high__level.html#ga19b3aa9e14a04b76188f917c0dc004f5">Cy_CapSense_Init</a>(&amp;cy_capsense_context);</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize CapSense interrupt */</span></div><div class="line">    Cy_SysInt_Init(&amp;CapSense_ISR_cfg, &amp;snippet_Cy_CapSense_IntHandler);</div><div class="line">    NVIC_ClearPendingIRQ(CapSense_ISR_cfg.intrSrc);</div><div class="line">    NVIC_EnableIRQ(CapSense_ISR_cfg.intrSrc);</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize the CapSense firmware modules. */</span></div><div class="line">    <a class="code" href="group__group__capsense__high__level.html#gade28f1f915ce6b97f13399074a819c0d">Cy_CapSense_Enable</a>(&amp;cy_capsense_context);</div><div class="line"></div></div><!-- fragment --><p> The CY_MSC&lt;X&gt;_HW is the pointer to the base register address of the MSC_X HW block. A macro for the pointer is in the cycfg_peripherals.h file defined as &lt;Msc_Personality_Name&gt;_HW. If no name is specified, the default name msc_&lt;Block_Number&gt;_msc_&lt;Block_Number&gt;_HW is used. </p>

</div>
</div>
<a id="ga036e1061e289e038c3e13df5c8751aed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga036e1061e289e038c3e13df5c8751aed">&#9670;&nbsp;</a></span>Cy_CapSense_IsAnyWidgetActive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Cy_CapSense_IsAnyWidgetActive </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports whether any widget has detected touch. </p>
<p>This function reports whether any widget has detected a touch by extracting information from the widget status registers. This function does not process widget data but extracts previously processed results from the <a class="el" href="group__group__capsense__structures.html">CapSense Structures</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CapSense context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the touch detection status of all the widgets:<ul>
<li>Zero - No touch is detected in any of the widgets or sensors.</li>
<li>Non-zero - At least one widget or sensor has detected a touch. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga4afba79341aef27afc40054d376d7193"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4afba79341aef27afc40054d376d7193">&#9670;&nbsp;</a></span>Cy_CapSense_IsWidgetActive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Cy_CapSense_IsWidgetActive </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>widgetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports whether the specified widget detected touch on any of its sensors. </p>
<p>This function reports whether the specified widget has detected a touch by extracting information from the widget status register. This function does not process widget data but extracts previously processed results from the <a class="el" href="group__group__capsense__structures.html">CapSense Structures</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">widgetId</td><td>Specifies the ID number of the widget. A macro for the widget ID can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;WIDGET_NAME&gt;_WDGT_ID.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CapSense context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the touch detection status of the specified widgets:<ul>
<li>Zero - No touch is detected in the specified widget or a wrong widgetId is specified.</li>
<li>Non-zero if at least one sensor of the specified widget is active, i.e. a touch is detected. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaeaa2dc78e56e2fc1ec0cc2b265851d69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeaa2dc78e56e2fc1ec0cc2b265851d69">&#9670;&nbsp;</a></span>Cy_CapSense_IsSensorActive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Cy_CapSense_IsSensorActive </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>widgetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sensorId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports whether the specified sensor in the widget detected touch. </p>
<p>This function reports whether the specified sensor in the widget has detected a touch by extracting information from the widget status register. This function does not process widget or sensor data but extracts previously processed results from the <a class="el" href="group__group__capsense__structures.html">CapSense Structures</a>.</p>
<p>For proximity sensors, this function returns the proximity detection status. To get the touch status of proximity sensors, use the <a class="el" href="group__group__capsense__high__level.html#ga96509342c580a9c5f6e17bdf8c74e53a" title="Reports the status of the specified proximity widget/sensor. ">Cy_CapSense_IsProximitySensorActive()</a> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">widgetId</td><td>Specifies the ID number of the widget. A macro for the widget ID can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;WIDGET_NAME&gt;_WDGT_ID.</td></tr>
    <tr><td class="paramname">sensorId</td><td>Specifies the ID number of the sensor within the widget. A macro for the sensor ID within a specified widget can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;WIDGET_NAME&gt;_SNS&lt;SENSOR_NUMBER&gt;_ID.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CapSense context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the touch detection status of the specified sensor/widget:<ul>
<li>Zero if no touch is detected in the specified sensor/widget or a wrong widget ID/sensor ID is specified.</li>
<li>Non-zero if the specified sensor is active, i.e. touch is detected. If the specific sensor belongs to a proximity widget, the proximity detection status is returned. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga96509342c580a9c5f6e17bdf8c74e53a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga96509342c580a9c5f6e17bdf8c74e53a">&#9670;&nbsp;</a></span>Cy_CapSense_IsProximitySensorActive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Cy_CapSense_IsProximitySensorActive </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>widgetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sensorId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the status of the specified proximity widget/sensor. </p>
<p>This function reports whether the specified proximity sensor has detected a touch or proximity event by extracting information from the widget status register. This function is used only with proximity widgets. This function does not process widget data but extracts previously processed results from the <a class="el" href="group__group__capsense__structures.html">CapSense Structures</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">widgetId</td><td>Specifies the ID number of the widget. A macro for the widget ID can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;WIDGET_NAME&gt;_WDGT_ID.</td></tr>
    <tr><td class="paramname">sensorId</td><td>Specifies the ID number of the sensor within the widget. A macro for the sensor ID within a specified widget can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;WIDGET_NAME&gt;_SNS&lt;SENSOR_NUMBER&gt;_ID.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CapSense context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the specified sensor of the proximity widget. Zero indicates that no touch is detected in the specified sensor/widget or a wrong widgetId/proxId is specified.<ul>
<li>Bits [31..2] are reserved.</li>
<li>Bit [1] indicates that a touch is detected.</li>
<li>Bit [0] indicates that a proximity is detected. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga6192ba34167662ac9573c0a4cd71682f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6192ba34167662ac9573c0a4cd71682f">&#9670;&nbsp;</a></span>Cy_CapSense_GetTouchInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcy__stc__capsense__touch__t.html">cy_stc_capsense_touch_t</a>* Cy_CapSense_GetTouchInfo </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>widgetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the details of touch position detected on the specified touchpad, matrix buttons or slider widgets. </p>
<p>This function does not process widget data but extracts previously processed results from the <a class="el" href="group__group__capsense__structures.html">CapSense Structures</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">widgetId</td><td>Specifies the ID number of the widget. A macro for the widget ID can be found in the cycfg_capsense.h file defined as CY_CAPSENSE_&lt;WIDGET_NAME&gt;_WDGT_ID.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the CapSense context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the pointer to widget <a class="el" href="structcy__stc__capsense__touch__t.html" title="Declares touch structure used to store positions of Touchpad, Matrix buttons and Slider widgets...">cy_stc_capsense_touch_t</a> structure that contains number of positions and data about each position. </dd></dl>

</div>
</div>
<a id="ga0c613df550388c119fdab4e50341a6b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c613df550388c119fdab4e50341a6b4">&#9670;&nbsp;</a></span>Cy_CapSense_RunTuner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Cy_CapSense_RunTuner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Establishes synchronized operation between the CapSense Middleware and the CapSense Tuner tool. </p>
<p>This function is called periodically in the application program. It serves the CapSense Tuner tool requests and commands to synchronize the operation. Mostly, the best place to call this function is between processing and next scanning. If the user changes some parameters in the Tuner tool, the middleware is re-started - the Tuner issues a restart command to be executed by this function.</p>
<p>The Tuner interface supports two communication protocol: EZI2C and UART.</p>
<p>To use an EZI2C-based tuner interface, only initialization of the EZI2C driver and interface is required in the application program. Refer to the I2C driver documentation for details of the protocol implementation and data package format by the EZI2C interface.</p>
<p>To use a UART-based tuner interface, the user must:</p><ul>
<li>Initialize the UART driver and interface</li>
<li>Use a callback function to facilitate data transmission and reception using the UART driver.</li>
</ul>
<p>The application program must:</p><ul>
<li>Form a transmission data packet</li>
<li>Validate the data package on receiver implementation prior to passing to the CapSense Middleware.</li>
</ul>
<p>The transmission packet includes a CapSense context structure sandwiched between a header (0x0D0A) and a tail (0x00FFFF), hence the package size is dependent on CapSense context information. The receiver packet is 16-byte (fixed length) data explained under the <a class="el" href="group__group__capsense__high__level.html#ga1f0fdedcec1ad936f5e9e4ae28f17274" title="Checks command format, header, tail, CRC, etc. ">Cy_CapSense_CheckTunerCmdIntegrity()</a> function. The <a class="el" href="group__group__capsense__high__level.html#ga1f0fdedcec1ad936f5e9e4ae28f17274" title="Checks command format, header, tail, CRC, etc. ">Cy_CapSense_CheckTunerCmdIntegrity()</a> function is used to validate the received data package prior to passing it to the CapSense middleware.</p>
<p>Periodical calling the <a class="el" href="group__group__capsense__high__level.html#ga0c613df550388c119fdab4e50341a6b4" title="Establishes synchronized operation between the CapSense Middleware and the CapSense Tuner tool...">Cy_CapSense_RunTuner()</a> function is:</p><ul>
<li>mandatory for operation of a UART-based tuner interface. The middleware operation is always synchronous to the Tuner tool.</li>
<li>optional to periodically call <a class="el" href="group__group__capsense__high__level.html#ga0c613df550388c119fdab4e50341a6b4" title="Establishes synchronized operation between the CapSense Middleware and the CapSense Tuner tool...">Cy_CapSense_RunTuner()</a> for EZI2C based interface.</li>
</ul>
<p>If the <a class="el" href="group__group__capsense__high__level.html#ga0c613df550388c119fdab4e50341a6b4" title="Establishes synchronized operation between the CapSense Middleware and the CapSense Tuner tool...">Cy_CapSense_RunTuner()</a> function is not periodically called by the application program, the middleware operation is asynchronous to the Tuner tool and the following disadvantages are applicable:</p><ul>
<li>The raw counts displayed in the CapSense Tuner tool may be filtered and/or non-filtered. Result - noise and SNR measurements are not accurate.</li>
<li>The CapSense Tuner tool can read sensor data (such as raw counts) from a scan multiply. Result - noise and SNR measurement are not accurate.</li>
<li>The CapSense Tuner tool and Host controller should not change the parameters via the Tuner interface - in async mode this leads to abnormal behavior.</li>
<li>Displaying detected gestures may be missed.</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>This function executes received commands. Two commands CY_CAPSENSE_TU_CMD_ONE_SCAN_E and CY_CAPSENSE_TU_CMD_SUSPEND_E change the FW tuner module state to suspend. In this state, the function waits until CY_CAPSENSE_TU_CMD_RESUME_E is received. Use a callback mechanism of command receiving to avoid FW hanging. Refer to the Function Usage section for examples.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>The pointer to the CapSense context structure <a class="el" href="structcy__stc__capsense__context__t.html">cy_stc_capsense_context_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return parameter indicates whether a middleware re-start was executed by this function or not:<ul>
<li>CY_CAPSENSE_STATUS_RESTART_DONE - Based on a received command, the CapSense was re-initialized.</li>
<li>CY_CAPSENSE_STATUS_RESTART_NONE - Re-start was not executed by this function.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd></dd></dl>
<p>An example of synchronization with the Tuner tool using EzI2C: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* EZI2C Initialization and assignment of communication buffer to cy_capsense_tuner */</span></div><div class="line">    Cy_SCB_EZI2C_Init(EZI2C_HW, &amp;EZI2C_config, &amp;EZI2C_context);</div><div class="line">    Cy_SysInt_Init(&amp;EZI2C_ISR_cfg, &amp;EZI2C_Interrupt);</div><div class="line">    NVIC_EnableIRQ(EZI2C_ISR_cfg.intrSrc);</div><div class="line">    Cy_SCB_EZI2C_SetBuffer1(EZI2C_HW, (uint8 *)&amp;cy_capsense_tuner, <span class="keyword">sizeof</span>(cy_capsense_tuner), <span class="keyword">sizeof</span>(cy_capsense_tuner), &amp;EZI2C_context);</div><div class="line">    Cy_SCB_EZI2C_Enable(EZI2C_HW);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span>(;;)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">if</span> (<a class="code" href="group__group__capsense__macros__general.html#ga1bd45eed2be393b7f53c20f1bae2814e">CY_CAPSENSE_NOT_BUSY</a> == <a class="code" href="group__group__capsense__high__level.html#ga7f8739755bba6b51c274f45b569b9ba0">Cy_CapSense_IsBusy</a>(&amp;cy_capsense_context))</div><div class="line">        {</div><div class="line">            <a class="code" href="group__group__capsense__high__level.html#ga2a185db228d5cae975fbc92bd3bc6367">Cy_CapSense_ProcessAllWidgets</a>(&amp;cy_capsense_context);</div><div class="line">            <a class="code" href="group__group__capsense__high__level.html#ga0c613df550388c119fdab4e50341a6b4">Cy_CapSense_RunTuner</a>(&amp;cy_capsense_context);</div><div class="line">            <a class="code" href="group__group__capsense__high__level.html#ga50e6ef42f2834083715abe86d8a85b48">Cy_CapSense_ScanAllWidgets</a>(&amp;cy_capsense_context);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div></div><!-- fragment --><p> An example of synchronization with the Tuner tool using UART.<br />
 Tuner Send callback implementation: Transmitting data through UART interface: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> TunerSend(<span class="keywordtype">void</span> * context)</div><div class="line">{</div><div class="line">    uint8_t uartTxHeader[] = {0x0Du, 0x0Au};</div><div class="line">    uint8_t uartTxTail[] = {0x00u, 0xFFu, 0xFFu};</div><div class="line"></div><div class="line">    (void)context;</div><div class="line"></div><div class="line">    Cy_SCB_UART_PutArrayBlocking(UART_HW, &amp;(uartTxHeader[0u]), <span class="keyword">sizeof</span>(uartTxHeader));</div><div class="line">    Cy_SCB_UART_PutArrayBlocking(UART_HW, (uint8 *)&amp;cy_capsense_tuner, <span class="keyword">sizeof</span>(cy_capsense_tuner));</div><div class="line">    Cy_SCB_UART_PutArrayBlocking(UART_HW, uartTxTail, <span class="keyword">sizeof</span>(uartTxTail));</div><div class="line">}</div></div><!-- fragment --><p> Tuner Receive callback implementation: Receiving data from UART interface: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> TunerReceive(uint8_t ** packet, uint8_t ** tunerPacket, <span class="keywordtype">void</span> * context)</div><div class="line">{</div><div class="line">    uint32_t i;</div><div class="line">    (void) context;</div><div class="line">    <span class="keyword">static</span> uint32_t dataIndex = 0u;</div><div class="line">    <span class="keyword">static</span> uint8_t commandPacket[16u] = {0u};</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span>(0 != Cy_SCB_UART_GetNumInRxFifo(UART_HW))</div><div class="line">    {</div><div class="line">        commandPacket[dataIndex++] = (uint8_t)Cy_SCB_UART_Get(UART_HW);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (CY_CAPSENSE_COMMAND_PACKET_SIZE &lt;= dataIndex)</div><div class="line">        {</div><div class="line">            <span class="keywordflow">if</span> (CY_CAPSENSE_COMMAND_OK == <a class="code" href="group__group__capsense__high__level.html#ga1f0fdedcec1ad936f5e9e4ae28f17274">Cy_CapSense_CheckTunerCmdIntegrity</a>(&amp;commandPacket[0u]))</div><div class="line">            {</div><div class="line">                <span class="comment">/* Found a correct command, reset data index and assign pointers to buffers */</span></div><div class="line">                dataIndex = 0u;</div><div class="line">                *tunerPacket = (uint8_t *)&amp;cy_capsense_tuner;</div><div class="line">                *packet = &amp;commandPacket[0u];</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line">            }</div><div class="line">            <span class="keywordflow">else</span></div><div class="line">            {</div><div class="line">                <span class="comment">/* Command is not correct, remove the first byte in commandPacket FIFO */</span></div><div class="line">                dataIndex--;</div><div class="line">                <span class="keywordflow">for</span>(i = 0u; i &lt; (CY_CAPSENSE_COMMAND_PACKET_SIZE - 1u); i++)</div><div class="line">                {</div><div class="line">                    commandPacket[i] = commandPacket[i + 1u];</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p> A part of the main.c FW flow with registering callbacks: </p><div class="fragment"><div class="line">    <span class="comment">/*...*/</span></div><div class="line"></div><div class="line">    <span class="comment">/* Register communication callbacks */</span></div><div class="line"><span class="preprocessor">    #if (CY_CAPSENSE_PLATFORM_BLOCK_MSCV3)</span></div><div class="line">        cy_capsense_context.ptrInternalContext-&gt;ptrTunerSendCallback = TunerSend;</div><div class="line">        cy_capsense_context.ptrInternalContext-&gt;ptrTunerReceiveCallback = TunerReceive;</div><div class="line"><span class="preprocessor">    #else</span></div><div class="line">        cy_capsense_context.ptrCommonContext-&gt;ptrTunerSendCallback = TunerSend;</div><div class="line">        cy_capsense_context.ptrCommonContext-&gt;ptrTunerReceiveCallback = TunerReceive;</div><div class="line"><span class="preprocessor">    #endif</span></div><div class="line"></div><div class="line">    Cy_SCB_UART_Init(UART_HW, &amp;UART_config, &amp;UART_context);</div><div class="line">    Cy_SCB_UART_Enable(UART_HW);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span>(;;)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">if</span> (<a class="code" href="group__group__capsense__macros__general.html#ga1bd45eed2be393b7f53c20f1bae2814e">CY_CAPSENSE_NOT_BUSY</a> == <a class="code" href="group__group__capsense__high__level.html#ga7f8739755bba6b51c274f45b569b9ba0">Cy_CapSense_IsBusy</a>(&amp;cy_capsense_context))</div><div class="line">        {</div><div class="line">            <a class="code" href="group__group__capsense__high__level.html#ga2a185db228d5cae975fbc92bd3bc6367">Cy_CapSense_ProcessAllWidgets</a>(&amp;cy_capsense_context);</div><div class="line"></div><div class="line">            <span class="comment">/*</span></div><div class="line"><span class="comment">            * Cy_CapSense_RunTuner() calls periodically communication callbacks</span></div><div class="line"><span class="comment">            * for hence the Tuner tool are able to monitor sensor signals/statuses</span></div><div class="line"><span class="comment">            * and change CapSense parameters for easy tuning.</span></div><div class="line"><span class="comment">            */</span></div><div class="line">            <a class="code" href="group__group__capsense__high__level.html#ga0c613df550388c119fdab4e50341a6b4">Cy_CapSense_RunTuner</a>(&amp;cy_capsense_context);</div><div class="line"></div><div class="line">            <a class="code" href="group__group__capsense__high__level.html#ga50e6ef42f2834083715abe86d8a85b48">Cy_CapSense_ScanAllWidgets</a>(&amp;cy_capsense_context);</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="comment">/*...*/</span></div><div class="line"></div></div><!-- fragment --><p> Refer to the <a class="el" href="group__group__capsense__callbacks.html">Callbacks</a> section for details. </p>

</div>
</div>
<a id="ga1f0fdedcec1ad936f5e9e4ae28f17274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f0fdedcec1ad936f5e9e4ae28f17274">&#9670;&nbsp;</a></span>Cy_CapSense_CheckTunerCmdIntegrity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Cy_CapSense_CheckTunerCmdIntegrity </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>commandPacket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks command format, header, tail, CRC, etc. </p>
<p>This function checks whether the specified packet with the size CY_CAPSENSE_COMMAND_PACKET_SIZE could be represented as a command received from the CapSense Tuner tool. The verification includes the following items:</p><ul>
<li>Header</li>
<li>Tail</li>
<li>CRC</li>
<li>Command code</li>
</ul>
<p>Command format is the following:</p><ul>
<li>Byte 0: Header 0 = 0x0D</li>
<li>Byte 1: Header 1 = 0x0A</li>
<li>Byte 2: Command code = cy_en_capsense_tuner_cmd_t</li>
<li>Byte 3: Command counter</li>
<li>Byte 4: Size = either 1, 2 or 4</li>
<li>Byte 5: Offset MSB</li>
<li>Byte 6: Offset LSB</li>
<li>Byte 7: Data MSB</li>
<li>Byte 8: Data</li>
<li>Byte 9: Data</li>
<li>Byte 10: Data LSB</li>
<li>Byte 11: 16-bit CRC MSB</li>
<li>Byte 12: 16-bit CRC LSB</li>
<li>Byte 13: Tail 0 = 0x00</li>
<li>Byte 14: Tail 1 = 0xFF</li>
<li>Byte 15: Tail 2 = 0xFF</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandPacket</td><td>The pointer to the data packet that should be verified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the result of the command verification:<ul>
<li>CY_CAPSENSE_COMMAND_OK - Command is correct.</li>
<li>CY_CAPSENSE_WRONG_HEADER - Wrong header.</li>
<li>CY_CAPSENSE_WRONG_TAIL - Wrong tail.</li>
<li>CY_CAPSENSE_WRONG_CRC - Wrong CRC.</li>
<li>CY_CAPSENSE_WRONG_CODE - Wrong Command code. </li>
</ul>
</dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>CapSense Middleware Library 3.0 (Alpha)</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
